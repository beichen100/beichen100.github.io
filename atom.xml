<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>beichen</title>
  
  
  <link href="https://beichen.link/atom.xml" rel="self"/>
  
  <link href="https://beichen.link/"/>
  <updated>2023-12-07T09:39:19.747Z</updated>
  <id>https://beichen.link/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://beichen.link/2023/12/07/Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/"/>
    <id>https://beichen.link/2023/12/07/Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/</id>
    <published>2023-12-07T09:39:19.747Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://beichen.link/2023/12/07/Study/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://beichen.link/2023/12/07/Study/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-07T09:39:19.747Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231024145425.png" alt="20231024145425"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/beichen100/image_host/master/img/20231024145425.png&quot; alt=&quot;20231024145425&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IDA脚本找jni_load</title>
    <link href="https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/IDA%E8%84%9A%E6%9C%AC%E6%89%BEjni_load/"/>
    <id>https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/IDA%E8%84%9A%E6%9C%AC%E6%89%BEjni_load/</id>
    <published>2023-10-19T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<p>idaPython 脚本 : 支持 libart.so 32&#x2F;64 位下断点。</p><h2 id="手动分析过程"><a href="#手动分析过程" class="headerlink" title="手动分析过程"></a>手动分析过程</h2><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231022102917.png" alt="20231022102917"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231022102934.png" alt="20231022102934"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231022103007.png" alt="20231022103007"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231022103100.png" alt="20231022103100"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231022103110.png" alt="20231022103110"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"><span class="keyword">import</span> ida_funcs</span><br><span class="line"><span class="comment"># time: 2023/1/31</span></span><br><span class="line"><span class="comment"># author: iyue</span></span><br><span class="line"><span class="comment"># 基于aosp10 - 12  源码符号都一样 其他可以自己找一下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">helloIdaPython</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------- start --------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findModules</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取指定模块</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># module = idc.get_first_module()</span></span><br><span class="line">    <span class="comment"># print(&quot;get first module : &#123;&#125;&quot;.format(module))</span></span><br><span class="line">    <span class="comment"># while (module!=None):</span></span><br><span class="line">    <span class="comment">#     moduleName = idc.get_module_name(module)</span></span><br><span class="line">    <span class="comment">#     print(&quot;find module name:&#123;&#125;&quot;.format(moduleName))</span></span><br><span class="line">    <span class="comment">#     if name in moduleName:</span></span><br><span class="line">    <span class="comment">#         return module</span></span><br><span class="line">    <span class="comment">#     module = idc.get_next_module(module)</span></span><br><span class="line">    <span class="comment"># return None</span></span><br><span class="line"></span><br><span class="line">    modules = idc.get_event_module_base()</span><br><span class="line">    <span class="keyword">for</span> module <span class="keyword">in</span> modules:</span><br><span class="line">        <span class="built_in">print</span>(module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setJniOnloadBt</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 获取数据段起始和结束位置</span></span><br><span class="line">    rodata_ea_start = <span class="number">0</span></span><br><span class="line">    rodata_ea_end = <span class="number">0</span></span><br><span class="line">    local_sections = idautils.Segments()</span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> local_sections:</span><br><span class="line">        seg_name = idc.get_segm_name(section)</span><br><span class="line">        <span class="comment"># print(seg_name)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> seg_name == <span class="string">&#x27;.rodata&#x27;</span>:</span><br><span class="line">            rodata_ea_start = section</span><br><span class="line">            rodata_ea_end = idc.get_segm_end(rodata_ea_start)</span><br><span class="line">            <span class="comment"># print(&quot;\t[iyue] find .rodata segment:0x%X&quot;%(rodata_ea_start))</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] find .rodata segment:0x%X - 0x%X&quot;</span>%(rodata_ea_start,rodata_ea_end))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rodata_ea_start == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;\t[iyue] can not locate .rodata segment&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 在rodata段中搜索字符串</span></span><br><span class="line">    jniOnloadStrAddr = <span class="number">0</span></span><br><span class="line">    eaOffset = rodata_ea_start</span><br><span class="line">    <span class="comment"># for debug</span></span><br><span class="line">    <span class="comment"># file = open(r&quot;C:\Users\l\Tools\SCRIPT\test.log&quot;,&#x27;w&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;\t[iyue] start find: [Calling JNI_OnLoad in \&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> eaOffset&lt;rodata_ea_end:</span><br><span class="line">        currentString = idc.get_strlit_contents(eaOffset)</span><br><span class="line">        <span class="keyword">if</span> currentString == <span class="literal">None</span>:</span><br><span class="line">            eaOffset+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sstr = <span class="built_in">bytes</span>(currentString).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> == sstr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] found strlit: %s addr:0x%X&quot;</span>%(sstr,eaOffset))</span><br><span class="line">            jniOnloadStrAddr = eaOffset</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># file.write(sstr+&#x27;\n&#x27;)</span></span><br><span class="line">        eaOffset+=<span class="built_in">len</span>(sstr)</span><br><span class="line">    <span class="comment"># file.flush()</span></span><br><span class="line">    <span class="comment"># file.close()</span></span><br><span class="line">    <span class="keyword">if</span> jniOnloadStrAddr == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] not found strlit: %s&quot;</span>%(<span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 获取jni关键字符串的引用地址</span></span><br><span class="line">    xrefAddr=<span class="number">0</span></span><br><span class="line">    allXref = idautils.XrefsTo(jniOnloadStrAddr)</span><br><span class="line">    <span class="comment"># 通过分析源码可知 前两个挨着的 第三个属于</span></span><br><span class="line">    <span class="keyword">for</span> xref <span class="keyword">in</span> allXref:</span><br><span class="line">        <span class="built_in">print</span>(xref.<span class="built_in">type</span>, idautils.XrefTypeName(xref.<span class="built_in">type</span>),<span class="string">&#x27;from&#x27;</span>, <span class="built_in">hex</span>(xref.frm), <span class="string">&#x27;to&#x27;</span>, <span class="built_in">hex</span>(xref.to))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\t[iyue] first ref in:0x%X&#x27;</span>%xref.frm)</span><br><span class="line">        xrefAddr = xref.frm</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> xrefAddr == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] not found %s Reference!&quot;</span>%(<span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 找到跳转后的地址,其实就是找b跳转，E4B7，loc_2a1a4a以_分割，goNextAddr找2a1a4a地址</span></span><br><span class="line">    <span class="comment"># int version = (*jni_on_load)(this, nullptr); 可以看到函数地址是一个变量</span></span><br><span class="line">    funcItems = idautils.FuncItems(xrefAddr) <span class="comment">#获取xref引用地址所在函数的所有地址</span></span><br><span class="line">    goNextAddr=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> itermAddr <span class="keyword">in</span> funcItems:</span><br><span class="line">        <span class="keyword">if</span> itermAddr &gt;= xrefAddr:</span><br><span class="line">            <span class="comment"># 跳转指令opcode 2 个字节</span></span><br><span class="line">            <span class="comment"># print(itermAddr)</span></span><br><span class="line">            opcode = ida_bytes.get_word(itermAddr)</span><br><span class="line">            <span class="comment"># print(opcode)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0xE4B7</span> == opcode:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] &quot;</span>,<span class="built_in">hex</span>(opcode),idc.GetDisasm(itermAddr))</span><br><span class="line">                gotoAddr = idc.GetDisasm(itermAddr).split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">                goNextAddr= <span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;0x&#x27;</span>+gotoAddr,<span class="number">16</span>))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] find go next addr:&quot;</span>,goNextAddr)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 兼容64位libart.so</span></span><br><span class="line">            <span class="comment"># print(opcode64)</span></span><br><span class="line">            opcode64 = ida_bytes.get_32bit(itermAddr)</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0x17fffe17</span> == opcode64:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] &quot;</span>,<span class="built_in">hex</span>(opcode64),idc.GetDisasm(itermAddr))</span><br><span class="line">                gotoAddr = idc.GetDisasm(itermAddr).split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">                goNextAddr= <span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;0x&#x27;</span>+gotoAddr,<span class="number">16</span>))</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] find go next addr:&quot;</span>,goNextAddr)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> goNextAddr==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] no found go next addr !&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 获取函数起始和结束位置，就是获取loc_2a1a4a的起止，因为后面会遍历每个地址</span></span><br><span class="line">    goNextAddr = <span class="built_in">int</span>(goNextAddr,<span class="number">16</span>)</span><br><span class="line">    tmpFuncName = idc.get_func_name(goNextAddr)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;LoadNativeLibrary&#x27;</span> <span class="keyword">in</span> tmpFuncName:</span><br><span class="line">        LoadNativeLibraryFuncStart = idc.get_func_attr(goNextAddr,idc.FUNCATTR_START)</span><br><span class="line">        LoadNativeLibraryFuncEnd = idc.get_func_attr(goNextAddr,idc.FUNCATTR_END)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6.找到jni_onload 调用位置，就是找同时带BLX和r4的</span></span><br><span class="line">    callJniOnloadAddr=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> goNextAddr &lt; LoadNativeLibraryFuncEnd:</span><br><span class="line">        ssstr = idc.GetDisasm(goNextAddr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\t[iyue] 0x%X %s&#x27;</span>%(goNextAddr,ssstr))</span><br><span class="line">        <span class="comment">#print(&quot;&#x27;%s&#x27;&quot;%ssstr)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;BLX&#x27;</span> <span class="keyword">in</span> ssstr <span class="keyword">and</span> <span class="string">&#x27;R&#x27;</span> <span class="keyword">in</span> ssstr <span class="keyword">or</span> <span class="string">&#x27;BLR&#x27;</span> <span class="keyword">in</span> ssstr <span class="keyword">and</span> <span class="string">&#x27;X&#x27;</span> <span class="keyword">in</span> ssstr:</span><br><span class="line">            callJniOnloadAddr = goNextAddr</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] find call jni_onload  addr:&quot;</span>,goNextAddr)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        goNextAddr+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> callJniOnloadAddr == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\t[iyue] no found call jni_onload fial !&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 7. 在调用位置下断点</span></span><br><span class="line">    idc.add_bpt(callJniOnloadAddr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\t[iyue] add bpt in:%s&#x27;</span>%ssstr)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------- start --------------------&quot;</span>)</span><br><span class="line">    <span class="comment"># findModules(&#x27;libart.so&#x27;)</span></span><br><span class="line">    setJniOnloadBt()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---------------- end --------------------&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;idaPython 脚本 : 支持 libart.so 32&amp;#x2F;64 位下断点。&lt;/p&gt;
&lt;h2 id=&quot;手动分析过程&quot;&gt;&lt;a href=&quot;#手动分析过程&quot; class=&quot;headerlink&quot; title=&quot;手动分析过程&quot;&gt;&lt;/a&gt;手动分析过程&lt;/h2&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>SVC</title>
    <link href="https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/SVC/"/>
    <id>https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/SVC/</id>
    <published>2023-10-19T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-SVC-指令？什么是-Syscall？"><a href="#什么是-SVC-指令？什么是-Syscall？" class="headerlink" title="什么是 SVC 指令？什么是 Syscall？"></a>什么是 SVC 指令？什么是 Syscall？</h2><p>在 Linux 里面内存主要分为 Linux 用户态，内核态。</p><p>用户自定义运行的函数在用户态。内核态是当 Linux 需要处理文件，或者进行中断 IO 等操作的时候就会进入内核态。</p><p>syscall 就是这个内核态的入口。(（systcall 是 Linux 内核的入口，切换到内核态以后，无法被 Hook）)</p><p>而 syscall 函数里面的实现就是一段汇编，汇编里面便是调用了 svc 指令。</p><p>当 arm 系列 cpu 发现 svc 指令的时候，就会陷入中断，简称 0x80 中断。开始执行内核态逻辑，这个时候程序会进入暂停状态, 优先去执行内核的逻辑。以此保证程序的安全性。</p><p>Linux 内核本身提供很多函数，比如常见的文件函数,openat，execve 都是 Linux 内核提供的。这些函数都可以通过 svc 指令的方式去调用，只是实现的 sysnum 不一样。传入的参数不一样而已。</p><p>但是通过 svc 执行的函数无法进行 inlinehook Hook ，所以会提升程序的安全度。</p><p>总结：svc 是一条 arm 指令，Syscall 函数是 libc 函数，实现底层使用了 svc 指令。</p><p>syscall 32&amp;64 位具体实现如下。</p><p>32 位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">raw_syscall:</span><br><span class="line">        MOV             R12, SP</span><br><span class="line">        STMFD           SP!, &#123;R4-R7&#125;</span><br><span class="line">        MOV             R7, R0</span><br><span class="line">        MOV             R0, R1</span><br><span class="line">        MOV             R1, R2</span><br><span class="line">        MOV             R2, R3</span><br><span class="line">        LDMIA           R12, &#123;R3-R6&#125;</span><br><span class="line">        SVC             <span class="number">0</span></span><br><span class="line">        LDMFD           SP!, &#123;R4-R7&#125;</span><br><span class="line">        mov             pc, lr</span><br></pre></td></tr></table></figure><p>64 位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">raw_syscall:</span><br><span class="line">        MOV             X8, X0</span><br><span class="line">        MOV             X0, X1</span><br><span class="line">        MOV             X1, X2</span><br><span class="line">        MOV             X2, X3</span><br><span class="line">        MOV             X3, X4</span><br><span class="line">        MOV             X4, X5</span><br><span class="line">        MOV             X5, X6</span><br><span class="line">        SVC             <span class="number">0</span></span><br><span class="line">        RET</span><br></pre></td></tr></table></figure><p>cmake 里添加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable_language(C ASM)</span><br></pre></td></tr></table></figure><p>编译即可</p><p>比如获取网卡设备信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOG(ERROR) &lt;&lt; <span class="string">&quot;读取文件内容  &quot;</span> &lt;&lt;</span><br><span class="line">            FileUtils::getFileText(<span class="string">&quot;/sys/class/net/p2p0/address&quot;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="对抗"><a href="#对抗" class="headerlink" title="对抗"></a>对抗</h2><p>可以通过 Ptrace 进行 svc 拦截，在使用前需要将 Ptrace 方法堵住</p><p>（因为 Ptrace 作为 Linux 的调试函数，是可以调试 svc 指令的，很多游戏辅助也都是这么搞得）<br>方法也很多，可以像一般壳子的方式提前占坑，或者读取调试状态，去判断是否被调试 都是不错的办法。</p><p>Seccomp(Secure Computing Mode) 是 Linux 的一种安全机制，android 8.1 以上使用了 Seccomp，主要通过限制进程的系统调用来完成部分沙箱隔离功能。seccomp-bpf 是 seccomp 的一个扩展，它可以通过配置来允许应用程序调用其他的系统调用。</p><p>主要功能是限制直接通过 syscall 去调用某些系统函数，当开启了 Seccomp 的进程在此调用的时候会变走异常的回调。</p><p>Seccomp 的过滤模式有两种(strict&amp;filter)，</p><ul><li><p>strict</p><p>strict 模式如果开启以后，只支持四个函数的系统调用(read,write,exit,rt_sigreturn)。如果一旦使用了其他的 syscall 则会收到 SIGKILL 信号</p></li><li><p>filter（BPF）</p><p>全程 Seccomp-bpf，BPF 是一种过滤模式，只有在 Linux 高版本会存在该功能，当某进程调用了 svc 以后，如果发现当前 sysnum 是我们进行过滤的 sysnum，首先会进入我们自己写的 BPF 规则。</p><p>通过我们自己的写的规则，进行判断该系统调用是否被运行调用，应该怎么进行处理.</p><p>当返回规则设置为「SECCOMP_RET_TRAP」，目标系统调用时 seccomp 会产生一个 SIGSYS 系统信号并软中断，这时就可以通过捕获这个 SIGSYS 信号获得 svc 调用和打印具体参数。</p><p>seccomp 发出 SECCOMP_RET_TRAP 信号时，会引发程序阻塞机制，此时系统会产生一个 SIGSYS 信号，并使原程序处于临时阻塞状态。因此我们可以使用 sigaction 来注册一个对 SIGSYS 信号进行处理的 handler，再将处理完的结果返回出去，从而达到 hook 效果。</p><p>常用的指令如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BPF_LD, BPF_LDX加载指令</span><br><span class="line">BPF_ST, BPF_STX存储指令</span><br><span class="line">BPF_ALU, 计算指令</span><br><span class="line">BPF_JMP, 跳转指令</span><br><span class="line">BPF_RET, 返回指令 （结束指令）</span><br><span class="line">BPF_MISC 其他指令</span><br></pre></td></tr></table></figure></li></ul><p>指令之间可以相加或者相减，来完成一条 JUMP 操作</p><h2 id="对-Seccomp-BPF-技术的防护"><a href="#对-Seccomp-BPF-技术的防护" class="headerlink" title="对 Seccomp-BPF 技术的防护"></a>对 Seccomp-BPF 技术的防护</h2><p>Seccomp-BPF 提供了一个钩子函数，在 SVC 系统调用执行之前会进入到这个函数，对系统调用进行检查，并做业务逻辑的修改和绕过。故任何 SVC 调用，都无法逃离 Seccomp-BPF 的魔掌。</p><p>那么，Seccomp-BPF 在 Android 应用攻击中是怎么做的呢？举例如下。</p><p>有的 APP 为了保障自身的安全，不允许 APP 动态调试、二次签名、运行在框架环境等。采用的方案一般使用 open 系统调用的方式打开特定文件检查有无异常特征，例如&#x2F;proc&#x2F;self&#x2F;map 或者&#x2F;proc&#x2F;self&#x2F;status 等。有些开发者比较注重安全，对 open 采用了 svc 的实现方式。但是利用 Seccomp-BPF 完全可以对 open 操作进行拦截，重定位参数路径，完成逻辑的绕过。</p><h3 id="1-基于-prctl-调用的检测"><a href="#1-基于-prctl-调用的检测" class="headerlink" title="1. 基于 prctl 调用的检测"></a>1. 基于 prctl 调用的检测</h3><p>prctl 方法也是一个系统调用。使用 Seccomp-BPF 前，会调用 prctl，并传入特定参数作为前置条件。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231021164409.png" alt="20231021164409"></p><p>为了检测这种方式。我们同样可以调用 prctl，传入 PR_GET_NO_NEW_PRIVS。根据返回值来判断是否 NO_NEW_PRIVS 被设置为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(prctl(PR_GET_NO_NEW_PRIVS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">1</span>) &#123; <span class="keyword">do</span> something… &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是该方案有个缺陷，因为 prctl 本身是个系统调用。所以仍然可以被 Seccomp-BPF 拦截修改进而绕过。</p><h3 id="2-基于-Signal-的捕获检测"><a href="#2-基于-Signal-的捕获检测" class="headerlink" title="2. 基于 Signal 的捕获检测"></a>2. 基于 Signal 的捕获检测</h3><p>将 SECCOMP_RET_TRAP 传入 BPF 指令中，当执行该指令时，将会产生 SIGSYS 信号。我们可以提前通过 sigaction 方法来注册 SIGSYS 信号，当捕获到信号时，会执行对应的 handler 方法。在正常情况下，都是可以正常接收到信号，并执行 handler 方法。但是如果该进程已经提前使用了 Seccomp-BPF，将会无法正常接收到信号，handler 方法也不会执行。所以可以通过这种逻辑来判断该应用是否处在 Seccomp-BPF 环境中。</p><p>不过该方法依然有被绕过的可能性，攻击者可以通过 Hook 的方式，拿到 handler 方法地址并主动去执行。则可以绕过校验。</p><h3 id="3-基于-status-文件的检测方案"><a href="#3-基于-status-文件的检测方案" class="headerlink" title="3. 基于 status 文件的检测方案"></a>3. 基于 status 文件的检测方案</h3><p>当调用代码时，会在对应进程的 status 文件中留下痕迹。如图所示，NoNewPrivs 对应的值变为 1。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231021164641.png" alt="20231021164641"></p><p>我们可以使用 open 打开&#x2F;proc&#x2F;self&#x2F;status 文件，检测该值是否为 1。当然，open 系统调用，我们之前说过了，可以被绕过。但这并不意味着防御到此结束，我们依然可以通过 open 返回的句柄值，来进一步验证句柄的合法性。</p><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><h3 id="1-批量检测-android-app-的-so-中是否有-svc-调用"><a href="#1-批量检测-android-app-的-so-中是否有-svc-调用" class="headerlink" title="1. 批量检测 android app 的 so 中是否有 svc 调用"></a>1. 批量检测 android app 的 so 中是否有 svc 调用</h3><p>原理很容易理解，对于 armv7 svc 0 对应的 00DF 二进制 调用号是在 r7 寄存器中<br>armv8 svc 0 对应的 010000D4 二进制 调用号是在 x8 寄存器中，只要在 so 文件中的.text 段中找到相关的二进制字串就可以确定是否有 svc 调用，再向前看就可以看出 svc 的调用号是多少。不同人不同写法，会导致分析调用号多少不一样</p><p>参考：<a href="https://bbs.kanxue.com/thread-269895.htm">https://bbs.kanxue.com/thread-269895.htm</a></p><p>arm32 关键代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">textStart = <span class="number">0</span></span><br><span class="line">            textEnd = <span class="number">0</span></span><br><span class="line">            FindtextEnd =<span class="literal">False</span></span><br><span class="line">            <span class="comment">#读取elf文件信息，计算代码的地址与终止段 ,取section.name==&#x27;.text&#x27;后，马上取下一个就是textEnd</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                e=ELFFile(f)</span><br><span class="line">                <span class="keyword">for</span> section <span class="keyword">in</span> e.iter_sections():</span><br><span class="line">                    <span class="comment">#打印Elf各段地址</span></span><br><span class="line">                    <span class="comment">#print(section[&#x27;sh_addr&#x27;],hex(section[&#x27;sh_addr&#x27;]),section.name)</span></span><br><span class="line">                    <span class="keyword">if</span> FindtextEnd <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        textEnd = section[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span>(section.name==<span class="string">&#x27;.text&#x27;</span>):</span><br><span class="line">                        textStart=section[<span class="string">&#x27;sh_addr&#x27;</span>]</span><br><span class="line">                        FindtextEnd=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 微信应用是这个svc 0 =&gt;00DF</span></span><br><span class="line">            sub = <span class="string">&quot;00DF&quot;</span></span><br><span class="line">            addr = [substr.start() <span class="keyword">for</span> substr <span class="keyword">in</span> re.finditer(sub, file_str)]</span><br><span class="line">            total_svc=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> addr:</span><br><span class="line">                <span class="keyword">if</span>( i &gt;= textStart <span class="keyword">and</span>  i&lt; textEnd):</span><br><span class="line">                    <span class="comment">#之前有问题是因为地址没对齐，比如 E0 0E F1 转成字串时 E00EF1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 也包含了00EF,这就要用地址必须为偶数</span></span><br><span class="line">                    <span class="comment"># 4FF0140700DF</span></span><br><span class="line">                    m=<span class="built_in">int</span>(i/<span class="number">2</span>)-<span class="number">6</span></span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">4</span>==<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">                        fun_id  = <span class="built_in">int</span>(<span class="string">&quot;0x&quot;</span>+file_str[i - <span class="number">4</span>:i - <span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">                        fun_id_check = <span class="built_in">int</span>(<span class="string">&quot;0x&quot;</span> + file_str[i - <span class="number">2</span>:i ], <span class="number">16</span>)</span><br><span class="line">                        <span class="keyword">if</span>(fun_id_check ==<span class="number">0x7</span>):</span><br><span class="line">                            total_svc = total_svc + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> (fun_id <span class="keyword">in</span> sysCallTab):</span><br><span class="line">                                <span class="built_in">print</span>(file_str[i - <span class="number">8</span>:i + <span class="number">4</span>], <span class="built_in">hex</span>(fun_id),</span><br><span class="line">                                      <span class="string">&quot;addr : 0x%.8x       Func Name : %s     &quot;</span> % (m, sysCallTab[fun_id]))</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                <span class="built_in">print</span>(file_str[i - <span class="number">8</span>:i + <span class="number">4</span>], <span class="built_in">hex</span>(fun_id),</span><br><span class="line">                                      <span class="string">&quot;addr : 0x%.8x       Func Name : need check again*********    &quot;</span> % (m))</span><br><span class="line">            <span class="comment">#print(os.path.basename(file_path), &quot;totoal find svc call &quot;, total_svc)</span></span><br><span class="line">            <span class="keyword">if</span> (total_svc &gt; <span class="number">0</span>):</span><br><span class="line">                <span class="built_in">print</span>(os.path.basename(file_path), <span class="string">&quot;elf infor &quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(os.path.basename(file_path), <span class="string">&quot;.text start &quot;</span>, <span class="built_in">hex</span>(textStart), <span class="string">&quot;.text end &quot;</span>, <span class="built_in">hex</span>(textEnd))</span><br><span class="line">                <span class="built_in">print</span>(os.path.basename(file_path), <span class="string">&quot;find svc call &quot;</span>, total_svc)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;——————————————————————————————\n&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-SVC-指令？什么是-Syscall？&quot;&gt;&lt;a href=&quot;#什么是-SVC-指令？什么是-Syscall？&quot; class=&quot;headerlink&quot; title=&quot;什么是 SVC 指令？什么是 Syscall？&quot;&gt;&lt;/a&gt;什么是 SVC 指令？什么是 Sy</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>hook对抗方法</title>
    <link href="https://beichen.link/2023/10/18/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/hook%E5%AF%B9%E6%8A%97%E6%96%B9%E6%A1%88/"/>
    <id>https://beichen.link/2023/10/18/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/hook%E5%AF%B9%E6%8A%97%E6%96%B9%E6%A1%88/</id>
    <published>2023-10-18T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hook-指令回写"><a href="#hook-指令回写" class="headerlink" title="hook 指令回写"></a>hook 指令回写</h3><p>现在很多 native hook 思路都是 inlinehook ，Got 表 ,异常 hook（异常信号劫持 hook）。</p><p>这些思路都是很好的思路，各有各的好处，但是都是有特征，比如 inlinehook crc 检测很容易就检测出来，并且</p><p>有很多大厂会用 shellcode 进行绕过，我们能去修改这段指令跳转到这个某个函数，他当然也可以修改回来。</p><p>他只需要把某个方法的指令换成原始的指令，这样就可以防止被 inlinehook Hook（他需要获取原始指令，可以解析本地的 So 文件，解析 text 段，得到最真实的指令信息，保存，然后在函数执行之前在 set 回内存,都是很好的办法,还有的干脆直接服务端配置一个服务，直接服务端拉取某个函数的正确指令，都是很好的思路）</p><p>当然对抗这也不是没办法，我只需要在 hook 完毕以后再把内存设置成可读，不可写, 然后 Hook mprotect(mprotect 通过内存属性控制内存的访问权限) ，不让他调用 mprotect 这样就可以被 shellcode 绕过。</p><h3 id="内存检测"><a href="#内存检测" class="headerlink" title="内存检测"></a>内存检测</h3><p>Hook 检测，我们其实只需要检测内存没有被修改即可。</p><p>正常我们知道一个 SO 加载到内存里，本质上是通过 mmap 把 so 分配到内存里面 ，比如 A 函数的指令是 BBB，那么加载到内存里面应该也是 BBB 。</p><p>记住上面这句话 ，我们就可以对内存里面的指令转换成一个 int 值，然后累加 。如果内存没有被修改 ，累加值文件里面和内存里面的值应该是一样的 。</p><p>以检测 libc 为例子，首先获取本地 So 文件的累加值，然后和本地的指令去计算 。计算本地的指令方法就是对 maps 进行遍历，只遍历 text 和 plt 段 ，计算累加值和本地进行判断。</p><p>当然这块就一定是比较完善的检测方案了么？其实有很多对抗思路 。比如把 maps 里面的内存进行隐藏，变成匿名内存，这样他在扫描 maps 的就找不到</p><p>当然这种方式一定是安全的么？</p><p>其实，不是的，因为在他的这个代码里面我发现存在一个遗漏点，可以作为检测入手点 ，某个加固厂商，不仅仅会对 maps item 进行遍历 ，还会对里面的匿名内存进行遍历 ，检测匿名内存里面的 magic ，比如 so 文件的 magic 是 elf ，如果 magic 匹配上一样当 maps 去解析 去遍历。</p><p>所以可以在原有的基础上改改，在将内存变成匿名内存以后，把 elf 的前四个字节抹掉，也就是 magic 的 内容，抹掉以后记得把权限修改成和之前的一样 。防止内存检测。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;hook-指令回写&quot;&gt;&lt;a href=&quot;#hook-指令回写&quot; class=&quot;headerlink&quot; title=&quot;hook 指令回写&quot;&gt;&lt;/a&gt;hook 指令回写&lt;/h3&gt;&lt;p&gt;现在很多 native hook 思路都是 inlinehook ，Got 表 ,异</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>签名对抗</title>
    <link href="https://beichen.link/2023/10/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%8A%97/"/>
    <id>https://beichen.link/2023/10/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%8A%97/</id>
    <published>2023-10-10T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<p>提到环境检测不得不说的就是 Apk 重打包检测 ，现在检测方法千奇百怪，我这边也是一一罗列一下，把一些可能存在的风险点，检测和绕过的原理详细叙述一下 。</p><h2 id="Native-层获取签名方法"><a href="#Native-层获取签名方法" class="headerlink" title="Native 层获取签名方法"></a>Native 层获取签名方法</h2><p>核心就三部分</p><ul><li>svc openat 读 apk，去解析签名 。</li><li>检测打开的 fd，对 fd 的路径进行反查，这块有个细节 buff[len] &#x3D; ‘\0’; 就是加这个，如果攻击者没修改 readlinkat 的返回值，就可以检测出来 。</li><li>检测完毕路径以后对这个文件的权限进行反查，正常 apk 是在系统下的，权限 GID 和 UID 应该是 1000 ，如果攻击者忘记修改权限也可以检测出来 。</li></ul><p>针对上面的检测对抗也很简单，对 svc 的 openat 拦截了以后，对 readlinkat 和 stat 函数进行处理即可 。很轻松即可绕过检测 。很多加壳基本都是检测 ROOT 检测 LSP 调用栈之类的 ，并不只是单一的去检测签名一个纬度 。比如发现了开启了 seccomp 就会闪退，发现 Root 就会闪退 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提到环境检测不得不说的就是 Apk 重打包检测 ，现在检测方法千奇百怪，我这边也是一一罗列一下，把一些可能存在的风险点，检测和绕过的原理详细叙述一下 。&lt;/p&gt;
&lt;h2 id=&quot;Native-层获取签名方法&quot;&gt;&lt;a href=&quot;#Native-层获取签名方法&quot; class=</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Fart脱壳机原理</title>
    <link href="https://beichen.link/2023/10/09/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Fart%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <id>https://beichen.link/2023/10/09/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Fart%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%8E%9F%E7%90%86/</id>
    <published>2023-10-09T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现有脱壳技术"><a href="#现有脱壳技术" class="headerlink" title="现有脱壳技术"></a>现有脱壳技术</h2><p>当前 ART 环境下的脱壳技术还有基于 dex2oat 编译生成 oat 过程的内存中的 dex 的 dump 技术，该方法依然是整体型 dump，无法应对指令抽取型加固,同时，当前一些壳对于动态加载 dex 的流程进行了 hook，这些 dex 也不会走 dex2oat 流程；</p><p>以及基于 dex 加载过程中内存中的 DexFile 结构体的 dump 技术。例如，在 ART 下通过 hook OpenMem 函数来实现在壳进行加载 DexFile 时对内存中的 dex 的 dump 的脱壳技术，以及在 2017 年的 DEF CON 25 黑客大会中，Avi Bashan 和 SlavaMakkaveev 提出的通过修改 DexFile 的构造函数 DexFile::DexFile()，以及 OpenAndReadMagic()函数来实现对加壳应用的内存中的 dex 的 dump 来脱壳技术。上面这些脱壳技术均无法实现对指令抽取型壳的完全脱壳。</p><h2 id="FART-脱壳原理以及实现"><a href="#FART-脱壳原理以及实现" class="headerlink" title="FART 脱壳原理以及实现"></a>FART 脱壳原理以及实现</h2><p>FART 脱壳的步骤主要分为三步：</p><p>1.内存中 DexFile 结构体完整 dex 的 dump</p><p>2.主动调用类中的每一个方法，并实现对应 CodeItem 的 dump</p><p>3.通过主动调用 dump 下来的方法的 CodeItem 进行 dex 中被抽取的方法的修复</p><h3 id="1-内存中-DexFile-结构体完整-dex-的-dump"><a href="#1-内存中-DexFile-结构体完整-dex-的-dump" class="headerlink" title="1 内存中 DexFile 结构体完整 dex 的 dump"></a>1 内存中 DexFile 结构体完整 dex 的 dump</h3><p>该步同 Avi Bashan 和 SlavaMakkaveev 在 DefCon 2017 上提出的通过修改 DexFile 的构造函数 DexFile::DexFile()，以及 OpenAndReadMagic()函数来实现对加壳应用的内存中的 dex 的 dump 来脱壳的原理类似。</p><p>不同之处在于 Avi Bashan 和 SlavaMakkaveev 是通过修改系统中 DexFile 中提供的相关函数来实现 dump，实际上壳完全可以自实现一套 Dex 文件的内存加载机制从而绕过这种 dump 方法。</p><p>本文提出的是通过选择合适的时机点获取到应用解密后的 dex 文件最终依附的 Classloader，进而通过 java 的反射机制最终获取到对应的 DexFile 的结构体，并完成 dex 的 dump。接下来主要介绍具体实现细节。</p><p>首先，对于获取 Classloader 的时机点的选择，APP 中的 Application 类中的 attachBaseContext 和 onCreate 函数是 app 中最先执行的方法。壳都是通过替换 APP 的 Application 类并自己实现这两个函数，并在这两个函数中实现 dex 的解密加载，hook 系统中 Class 和 method 加载执行流程中的关键函数，最后通过反射完成关键变量如最终的 Classloader，Application 等的替换从而完成执行权的交付。所有的应用中加载的 dex 文件最终都在应用的 Classloader 中。所以我们只要取到加壳的应用最后修复完，正常加载时的 Classloader 就脱壳成功了。这种脱壳方式就是所谓的整体 dump。</p><p>因此，我们可以选在任意一个在 Application 的 onCreate 函数执行之后才开始被调用的任意一个函数中。众所周知，对于一个正常的应用来说，最终都要由一个个的 Activity 来展示应用的界面并和用户完成交互，那么我们就可以选择在 ActivityThread 中的 performLaunchActivity 函数作为时机，来获取最终的应用的 Classloader。选择该函数还有一个好处在于该函数和应用的最终的 application 同在 ActivityThread 类中，可以很方便获取到该类的成员。</p><p>performLaunchActivity 调用 getDexFilesByClassLoader 函数通过一系列的反射，最终获取到当前 Classloader 中的 mCookie，即 Native 层中的 DexFile，然后完成 dex 的 dump</p><p>上面实现了对 Classloader 中加载的 dex 的 dump，那么如何实现对类中函数的主动调用来实现函数粒度的脱壳呢？下面开始介绍主动调用的设计</p><h3 id="2-类函数的主动调用设计实现"><a href="#2-类函数的主动调用设计实现" class="headerlink" title="2 类函数的主动调用设计实现"></a>2 类函数的主动调用设计实现</h3><p>后来的第二代壳所谓的函数抽取，就是为了防止修复后的 dex 被直接整体 dump 给脱下来，然后将类和函数的关键流程在调用时，才进行解密修复。而 fart 的主动调用所有函数，就会触发解密修复，然后再进行 dump，从而实现函数抽取壳的脱壳。</p><p>获取 classloader 之后，反射获取 mCookie 字段（mCookie 装载的，是 art 中的 DexFile 的对象的内存地址），最后遍历所有类，调用每个类中的所有函数</p><p>对类函数的主动调用链的构造我们或许可以从 JNI 提供的相关函数的源码可以得出参考。JNI 提供了一系列 java 层函数与 Native 层函数交互的接口。当需要在 Native 层中的 c&#x2F;c++函数中调用位于 java 层的函数时，需要先获取到该函数的 jmethodid 然后再通过诸如 jni 中提供的 call 开头的一系列函数来完成对 java 层中函数的调用，最终通过调用 ArtMethod 类中的 Invoke 函数完成对 java 层中的函数的调用。</p><p>由此，我们可以看到 ArtMethod 类中的 Invoke 方法在 jni 中扮演着至关重要的地位。于是，我们可以构造出自己的 invoke 函数，在该函数中再调用 ArtMethod 的 Invoke 方法从而完成主动调用，并在 ArtMethod 的 Invoke 函数中首先进行判断，当发现是我们自己的主动调用时就进行方法体的 dump 并直接返回，从而完成对壳的欺骗，达到方法体的 dump。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231009161439.png" alt="20231009161439"></p><p>可以看到代码非常简洁，首先是对 Java 层传来的 Method 结构体进行了类型转换，转成 Native 层的 ArtMethod 对象，接下来就是调用 ArtMethod 类中 myfartInvoke 实现虚拟调用，并完成方法体的 dump。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231009161506.png" alt="20231009161506"></p><p>这里代码依然很简洁，只是对 ArtMethod 类中的 Invoke 的一个调用包装，不同的是在参数方面，我们直接给 Thread*传递了一个 nullptr，作为对主动调用的标识。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231009161534.png" alt="20231009161534"></p><p>该函数只是在最开头添加了对 Thread*参数的判断，当发现该参数为 nullptr 时，即表示是我们自己构造的主动调用链到达，则此时调用 dumpArtMethod()函数完成对该 ArtMethod 的 CodeItem 的 dump。到这里，我们就完成了内存中 DexFile 结构体中的 dex 的整体 dump 以及主动调用完成对每一个类中的函数体的 dump，下面就是修复被抽取的函数部分。</p><h3 id="3-抽取类函数的修复"><a href="#3-抽取类函数的修复" class="headerlink" title="3 抽取类函数的修复"></a>3 抽取类函数的修复</h3><p>壳在完成对内存中加载的 dex 的解密后，该 dex 的索引区即 stringid，typeid,methodid,classdef 和对应的 data 区中的 string 列表并未加密。而对于 classdef 中类函数的 CodeItem 部分可能被加密存储或者直接指向内存中另一块区域。这里我们只需要使用 dump 下来的 method 的 CodeItem 来解析对应的被抽取的方法即可</p><h2 id="fart-对抗"><a href="#fart-对抗" class="headerlink" title="fart 对抗"></a>fart 对抗</h2><p>一句话概括： 在 DEX 中插入无用类，检测到无用类的加载后随机 kill 自己</p><p>在 DEX 中插入无用类，记录这些类的 debug info offset 作为黑名单；正常运行时不会加载这些无用类（没有任何引用），而当 FART 进行枚举方法主动调用时，会触发这些类的加载，从而导致计数器置 1。计数器递增到达上限后触发 kill self，App 表现为随机的 crash，从而中断枚举过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现有脱壳技术&quot;&gt;&lt;a href=&quot;#现有脱壳技术&quot; class=&quot;headerlink&quot; title=&quot;现有脱壳技术&quot;&gt;&lt;/a&gt;现有脱壳技术&lt;/h2&gt;&lt;p&gt;当前 ART 环境下的脱壳技术还有基于 dex2oat 编译生成 oat 过程的内存中的 dex 的 dum</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>国内风控的几大隐藏检测特征</title>
    <link href="https://beichen.link/2023/10/08/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E9%A3%8E%E6%8E%A7/"/>
    <id>https://beichen.link/2023/10/08/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E9%A3%8E%E6%8E%A7/</id>
    <published>2023-10-08T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-检测锁屏密码"><a href="#1-检测锁屏密码" class="headerlink" title="1. 检测锁屏密码"></a>1. 检测锁屏密码</h3><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110538.png" alt="20231206110538"></p><h3 id="2-通过-binder-检测是否真的有-SIM-卡"><a href="#2-通过-binder-检测是否真的有-SIM-卡" class="headerlink" title="2. 通过 binder 检测是否真的有 SIM 卡"></a>2. 通过 binder 检测是否真的有 SIM 卡</h3><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110652.png" alt="20231206110652"></p><p>获取远程 binder 接口：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110716.png" alt="20231206110716"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110718.png" alt="20231206110718"></p><h3 id="3-build-prop-修改时间"><a href="#3-build-prop-修改时间" class="headerlink" title="3. build.prop 修改时间"></a>3. build.prop 修改时间</h3><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110752.png" alt="20231206110752"></p><p>因为高版本 SELinux 限制了无法读取&#x2F;system&#x2F;build.prop，但是有很多模拟器或者比较弱的黑产还是采用修改 build.prop 重启的方式修改数据。</p><p>而且 SELinux 并未先对该文件的 stat&#x2F;statfs 访问，所以可以通过读取改文件的修改时间判断是否修改（正常通过编译出来的 build.prop 的修改时间要么是 1970 年 1 月要么是 2009 年 1 月 1 日）</p><h3 id="4-检测手机上的应用商店包名"><a href="#4-检测手机上的应用商店包名" class="headerlink" title="4. 检测手机上的应用商店包名"></a>4. 检测手机上的应用商店包名</h3><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231206110925.png" alt="20231206110925"></p><h3 id="5-传感器"><a href="#5-传感器" class="headerlink" title="5. 传感器"></a>5. 传感器</h3><p>主要入口：</p><ul><li>Sensor.getVendor() &#x2F;&#x2F;获取传感器厂商</li><li>Sensor.getMaximumRange() &#x2F;&#x2F;获取传感器最大范围</li><li>Sensor.getResolution() &#x2F;&#x2F;获取传感器精度</li><li>Sensor.getMinDelay() &#x2F;&#x2F;获取传感器最小延迟</li></ul><p>原理： 通过传感器信息对设备进行分析，可以结合大数据对设备指纹进行检测，也可以通过数据库对每一样设备的传感器进行对比检测作弊。</p><p>应用厂商：某盟、某美、某多、某宝、某音</p><h3 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6. 文件系统"></a>6. 文件系统</h3><p><code>stat -f /</code></p><p>执行结果：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231021192541.png" alt="20231021192541"></p><p>原理：第一个是文件系统 ID，每个设备都是不一样的，但是无论清除数据还是刷机都不会变。第 2、3 个是 Blocks 和 Inodes 的数量，一般情况下很难改变。</p><p>应用厂商：某多、某美、某宝</p><h3 id="7-字体列表"><a href="#7-字体列表" class="headerlink" title="7. 字体列表"></a>7. 字体列表</h3><p><code>ls /system/fonts</code></p><p>原理：读取&#x2F;system&#x2F;fonts 可以获取到安卓的系统字体列表，可以通过 md5 或者 sha-1 进行标注，方便对系统 ROM 识别。因为一般情况下，同一个 ROM 字体数量、文件名都是基本相差无几</p><p>应用厂商：某美、某多、某音</p><h3 id="8-OpenGL"><a href="#8-OpenGL" class="headerlink" title="8. OpenGL"></a>8. OpenGL</h3><ul><li>com.google.android.gles_jni.GLImpl</li><li>String glGetString(int name);</li></ul><p>name 值：</p><ul><li>GLVendor 7936 GPU 厂商</li><li>GLRenderer 7937 GPU 名称</li><li>GLVersion 7938 GPU 驱动版本</li></ul><p>原理：通过这些属性获取到 GPU 的相关信息（也可以通过 native 层获取，这里只演示 Java 层的），可以通过这些信息和机型数据对比即可得出是否有作弊。并且这些信息也可以用于设备指纹识别。</p><p>应用厂商：某盟、某美、某多等所有厂商</p><h3 id="9-boot-id-和-uuid"><a href="#9-boot-id-和-uuid" class="headerlink" title="9. boot_id 和 uuid"></a>9. boot_id 和 uuid</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/random/boot_id</span><br><span class="line">cat /proc/sys/kernel/random/uuid</span><br></pre></td></tr></table></figure><p>这些 ID 由安卓系统在开机时生成，并且在开机状态下不会改变。风控厂商通过这些 ID 进行关联检测，并且可以联合其他信息推断是否为同一设备操作。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231021192844.png" alt="20231021192844"></p><p>应用厂商：某盟、某美、某多等所有厂商</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-检测锁屏密码&quot;&gt;&lt;a href=&quot;#1-检测锁屏密码&quot; class=&quot;headerlink&quot; title=&quot;1. 检测锁屏密码&quot;&gt;&lt;/a&gt;1. 检测锁屏密码&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android进程启动流程</title>
    <link href="https://beichen.link/2023/09/29/Study/Android%E7%9F%A5%E8%AF%86/Android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://beichen.link/2023/09/29/Study/Android%E7%9F%A5%E8%AF%86/Android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2023-09-29T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><p>本文要介绍的是进程的创建，先简单说说进程与线程的区别。</p><ul><li><p>进程：每个 App 在启动前必须先创建一个进程，该进程是由 Zygote fork 出来的，进程具有独立的资源空间，用于承载 App 上运行的各种 Activity&#x2F;Service 等组件。进程对于上层应用来说是完全透明的，这也是 google 有意为之，让 App 程序都是运行在 Android Runtime。大多数情况一个 App 就运行在一个进程中，除非在 AndroidManifest.xml 中配置 Android:process 属性，或通过 native 代码 fork 进程。</p></li><li><p>线程：线程对应用开发者来说非常熟悉，比如每次 new Thread().start()都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从 Linux 角度来说进程与线程都是一个 task_struct 结构体，除了是否共享资源外，并没有其他本质的区别。</p></li></ul><p>在接下来的文章，会涉及到 system_server 进程和 Zygote 进程，下面简要介绍这两个进程：</p><ul><li><p>system_server 进程：是用于管理整个 Java framework 层，包含 ActivityManager，PowerManager 等各种系统服务;</p></li><li><p>Zygote 进程：是 Android 系统的首个 Java 进程，Zygote 是所有 Java 进程的父进程，包括 system_server 进程以及所有的 App 进程都是 Zygote 的子进程，注意这里说的是子进程，而非子线程</p></li></ul><h2 id="进程创建图"><a href="#进程创建图" class="headerlink" title="进程创建图"></a>进程创建图</h2><p>先来看一张进程创建过程的简要图：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231005103214.png" alt="20231005103214"></p><p>图解：</p><ol><li><p>App 发起进程：当从桌面启动应用，则发起进程便是 Launcher 所在进程；当从某 App 内启动远程进程，则发送进程便是该 App 所在进程。发起进程先通过 binder 发送消息给 system_server 进程；</p></li><li><p>system_server 进程：调用 Process.start()方法，通过 socket 向 zygote 进程发送创建新进程的请求；</p></li><li><p>zygote 进程：在执行 ZygoteInit.main()后便进入 runSelectLoop()循环体内，当有客户端连接时便会执行 ZygoteConnection.runOnce()方法，再经过层层调用后 fork 出新的应用进程；</p><blockquote><p>fork()采用 copy on write 技术，这是 linux 创建进程的标准方法，调用一次，返回两次，返回值有 3 种类型。</p><p>在父进程中，fork 返回新创建的子进程的 pid;<br>在子进程中，fork 返回 0；<br>当出现错误时，fork 返回负数。（当进程数超过上限或者系统内存不足时会出错）</p><p>copy-on-write 原理：<br>写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork 过程只拷贝父进程的页表，并标记这些页表是只读的。<br>父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux 收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。</p><p>Copy On Write 技术好处是什么？</p><ol><li>COW 技术可减少分配和复制大量资源时带来的瞬间延时。</li><li>COW 技术可减少不必要的资源分配。比如 fork 进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。</li></ol><p>Copy On Write 技术缺点是什么？<br>如果在 fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断 page-fault)，这样就得不偿失。</p></blockquote><p>fork()的主要工作是寻找空闲的进程号 pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。</p><p>Zygote 进程是所有 Android 进程的母体，包括 system_server 和各个 App 进程。zygote 利用 fork()方法生成新进程，对于新进程 A 复用 Zygote 进程本身的资源，再加上新进程 A 相关的资源，构成新的应用进程 A。</p></li><li><p>新进程：执行 handleChildProc 方法，最后调用 ActivityThread.main()方法。</p></li></ol><p>参考：<a href="http://gityuan.com/2016/03/26/app-process-create/">http://gityuan.com/2016/03/26/app-process-create/</a></p><p>ActivityThread 是应用进程的初始化类，它的 main()方法就是应用的入口方法，也就是说应用进程被创建后会调用 ActivityThread.main()方法</p><p>ActivityThread 也是我们常说的主线程，但是这种描述不太准确，ActivityThread 不是线程，只不过它是在运行在主线程（main）的 main()方法中创建的对象，自然它也是运行在主线程中。只能说 ActivityThread 是主线程的一部分，但不并能代表主线程。</p><p>在 ActivityThread 的 main 中：</p><ol><li><p>创建一个调用一个 Looper.prepareMainLooper(),创建一个 Looper 对象，这就是我们 activity 的主线程。</p></li><li><p>创建 ActivityThread 对象，ActivityThread 就是一个普通的 java 类。</p></li><li><p>调用 thread.attach 方法。主要是为了和 ActivityManagerService 进行交互通信。在里面通过 ActivityManagerService 的代理对象 ActivityManagerNative.getDefault()获取代理对象和 ActivityManagerService 通信。代理对象通过传递 ApplicationThread 对象 mAppThread 进行通信。</p></li></ol><p>ApplicationThread 继承自 ApplicationThreadNative（一个实现 binder 的子类）目的是和 ActivityManagerService（AMS）通信。所以 ApplicationThread 仅仅是和 AMS 通信的一个工具类。</p><p>主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的 bindapplication 的进程间调用时，调用函数 handlebindapplication 来处理该请求</p><p>在 handleBindApplication 函数中第一次进入了 app 的代码世界，该函数功能是启动一个 application，并把系统收集的 apk 组件等相关信息绑定到 application 里.</p><blockquote><p>Application 是维护应用全局状态的基类，Android 系统会在启动应用进程时创建一个 Application 对象（应用只有一个 Application 对象）</p><p>Applicaiton 类的应用场景有：</p><ol><li>初始化应用程序级别的资源，如全局对象、环境配置变量等 数据共享、数据缓存，如设置全局共享变量、方法等</li><li>获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死</li><li>监听应用程序配置信息的改变，如屏幕旋转等</li><li>监听应用程序内 所有 Activity 的生命周期</li></ol></blockquote><p>在创建完 application 对象后，接着调用了 application 的 attachBaseContext 方法，之后调用了 application 的 onCreate 函数。由此可以发现，app 的 Application 类中的 attachBaseContext 和 onCreate 这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换 app 入口 Application，并自实现这两个函数，在这两个函数中进行代码的脱壳以及执行权交付的原因。</p><blockquote><p>在 Android 应用程序中，attachBaseContext() 方法是一个回调方法，它在 onCreate() 方法之前被调用，其作用是向应用程序的 Context 对象中添加或修改一些信息。通常，开发人员会在这个方法中执行一些初始化操作，如创建全局对象、设置默认语言等。</p><p>具体来说，attachBaseContext() 方法的主要作用有以下几个方面：</p><ol><li><p>为应用程序的 Context 对象添加一些额外的功能和信息，如修改 Resources 对象以支持多语言、修改 DisplayMetrics 对象以适应不同的屏幕尺寸等。</p></li><li><p>初始化全局变量和对象，例如创建数据库、设置全局的异常处理器等。</p></li><li><p>配置应用程序的一些基本参数，例如设置应用程序的主题、字体大小、默认语言等。</p></li></ol><p>需要注意的是，在 attachBaseContext() 方法中，必须调用父类的 attachBaseContext() 方法，以确保系统在应用程序启动时正确地初始化 Context 对象。例如，在 Activity 类的 attachBaseContext() 方法中，必须调用父类的方法 super.attachBaseContext()。</p><p>总之，attachBaseContext() 方法是 Android 应用程序中非常重要的一个回调方法，通过重写该方法，开发人员可以在应用程序启动时进行一些必要的初始化操作，以确保应用程序的正确运行。</p></blockquote><p>简单第一代壳加固程序脱壳运行的话：</p><ol><li><p>通过反射将 android.app.ActivityThread 中的 mClassLoader 置换为加载解密后的 APK 的 DexClassLoader，该 DexClassLoader 一方面加载了源程序，另一方面以原 mClassLoader 为父节点，这就保证了既加载了源程序又没有放弃原先加载的资源与系统代码。</p></li><li><p>找到源程序的 Application，通过反射建立并运行。这里需要注意的是，现在是加载一个完整的 APK 让它运行起来，一个 APK 运行的时候都是有一个 Application 对象的，这个也是一个程序运行之后的全局类。所以必须找到解密之后的源 Apk 的 Application 类，运行它的 onCreate 方法，这样源 Apk 才能开始它的运行生命周期。</p></li></ol><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20231009145338.png" alt="20231009145338"></p><p>根据以上流程图，我们需要在 Android Studio 中新建一个项目，创建一个继承自 Application 的 ProxyApplication 类，并在 attachBaseContext 方法中解密和动态加载源 APK，在 onCreate 方法中找到源 APK 的 Application 类并运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;p&gt;本文要介绍的是进程的创建，先简单说说进程与线程的区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程：每个 App 在启动前必须先创</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="Android知识" scheme="https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>deepIntent学习</title>
    <link href="https://beichen.link/2023/09/23/Paper/deepIntent%E5%AD%A6%E4%B9%A0/"/>
    <id>https://beichen.link/2023/09/23/Paper/deepIntent%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-23T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="paper-学习"><a href="#paper-学习" class="headerlink" title="paper 学习"></a>paper 学习</h2><p>DeepIntent，一个深度图标行为学习框架，从大量流行应用程序中学习图标行为模型并检测意图-行为差异的框架。</p><p>特别是，DeepIntent 提供了程序分析技术，将意图（即图标和上下文文本）与 UI 窗口小部件的程序行为相关联，并基于程序行为推断 UI 窗口小组件的标签（即权限使用），从而能够构建大规模高质量的训练数据集。</p><p>DeepIntent 的设计基于三个关键见解。</p><p>首先，移动应用的用户界面（UI）应该对用户明显可见，并且指示相同类型敏感行为的图标应该具有相似的外观。这启发我们借鉴了 CNN 在图像识别方面的成功经验[35, 36]，使用 CNN 来对图标（即图标的像素）进行建模，以识别相似的图标。</p><p>其次，在不同的 UI 上下文中，图标可能反映不同的意图。例如，在不同的上下文中，“发送”按钮可能表示发送电子邮件或短信。虽然仅通过比较图标很难区分意图，但上下文文本，如附近的文本标签和 UI 的标题，可以用来帮助区分图标的上下文。</p><p>第三，用户期望与具有特定外观的图标小部件进行交互时产生特定的行为，并且不希望出现与用户期望相矛盾的行为。例如，当用户查看图 1(a)中的第一个突出显示的图标时，他们期望该应用程序读取他们的联系人，而不是公开他们的位置信息。</p><p>为了捕捉这种普遍的期望，我们提出开发程序分析技术，可以将图标与其敏感行为关联起来，并将这些技术应用于从一组流行应用程序的语料库中提取关联，以学习具有特定外观的图标小部件的预期行为模型。</p><p>DeepIntent 包括三个主要阶段</p><ul><li><p>图标小部件分析。</p><p>我们学习模型中使用的输入包括图标、上下文文本和与图标相关的权限使用。为了提取图标及其权限使用，DeepIntent 提供了一种静态分析方法，通过分析 APK 文件来识别图标小部件并提取相应的图标-权限映射，即将 UI 小部件中使用的图标映射到其权限使用。</p><p>具体而言，静态分析(1)通过分析 UI 布局文件和代码将图标与 UI 小部件关联起来，(2)将图标小部件与 UI 处理程序关联起来，(3)通过考虑多线程和 ICC 构建 UI 处理程序的调用图，(4)将调用图中的方法调用映射到权限使用。从提取的图标中，DeepIntent 提供了一种文本提取技术，通过分析 UI 布局文件、图标中嵌入的文本和图标文件名来提取图标的上下文文本。</p><p>以电话呼叫按钮为例。DeepIntent 从 UI 布局文件中提取资源 ID，分析处理该按钮的代码，构建调用图，并将按钮映射到其权限使用（即 CALL 权限）。图标行为关联的输出是一组⟨图标，文本，权限⟩三元组。</p></li><li><p>学习图标-行为模型。</p><p>DeepIntent 采用并行共同关注机制[47, 90]来共同建模图标及其上下文文本。具体而言，DeepIntent 首先使用 DenseNet [30]和 GRUs [10]分别提取图标图像和上下文文本的初始化特征。然后，DeepIntent 通过共同关注将这两个特征合并成一个联合特征向量，其基本思想是通过突出显示彼此相关的图像&#x2F;文本区域来同时更新图像&#x2F;文本特征。 接下来，DeepIntent 通过使用映射的图标权限来训练模型，学习图标的联合特征向量。由于每个图标可能与多个权限使用相关，我们将其构建为一个多标签分类问题来学习联合特征。</p></li><li><p>检测意图-行为差异。</p><p>利用学习到的图标行为模型，DeepIntent 首先提取图标小部件的联合特征向量，然后通过计算和聚合图标小部件使用的每个权限的异常值得分来检测意图-行为差异。具体而言，我们通过自动编码器[3]计算每个使用的权限的异常值得分，并根据图标行为模型将这些得分聚合成最终的异常值得分。实际的权限使用是通过用于提取图标-权限映射的程序分析获得的。</p></li></ul><h3 id="图标-行为关联"><a href="#图标-行为关联" class="headerlink" title="图标-行为关联"></a>图标-行为关联</h3><p>该模块提供了静态分析技术，用于识别图标小部件，提取它们的图标和文本，并推断图标小部件的权限使用。</p><p>该模块包含四个主要组件：1）图标小部件关联，2）扩展调用图构建，3）小部件-API 关联，以及 4）API 权限检查</p><h3 id="实验复现"><a href="#实验复现" class="headerlink" title="实验复现"></a>实验复现</h3><p>如果出现这样的问题：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230921214221.png" alt="20230921214221"></p><p>则需要更换 java 版本，原来本机是 java11，现在改成了 java8</p><p>更改教程如下：</p><p><a href="https://blog.csdn.net/qq_42824983/article/details/114674833">https://blog.csdn.net/qq_42824983/article/details/114674833</a></p><p><a href="https://www.cnblogs.com/xnancy/p/15656733.html">https://www.cnblogs.com/xnancy/p/15656733.html</a></p><p>实际上按照网址 1 修过了后不起作用，然后又改了 etc&#x2F;profile，然后 source，才改过来</p><p>改完 apkcallgraph 后，需要重新打包成 jar 包，使用 eclipse 本地打包再上传服务器，导入包问题在 eclipse 上解决</p><p>具体打包步骤，eclipse 里 export 然后 runnable jar，设置主类，然后选 extract jar 选项，打包完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;paper-学习&quot;&gt;&lt;a href=&quot;#paper-学习&quot; class=&quot;headerlink&quot; title=&quot;paper 学习&quot;&gt;&lt;/a&gt;paper 学习&lt;/h2&gt;&lt;p&gt;DeepIntent，一个深度图标行为学习框架，从大量流行应用程序中学习图标行为模型并检测意</summary>
      
    
    
    
    <category term="Paper" scheme="https://beichen.link/categories/Paper/"/>
    
    
    <category term="OSS Security" scheme="https://beichen.link/tags/OSS-Security/"/>
    
  </entry>
  
  <entry>
    <title>frida 脱壳原理</title>
    <link href="https://beichen.link/2023/09/20/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Frida%E8%84%B1%E5%A3%B3%E5%8E%9F%E7%90%86/"/>
    <id>https://beichen.link/2023/09/20/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Frida%E8%84%B1%E5%A3%B3%E5%8E%9F%E7%90%86/</id>
    <published>2023-09-20T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Frida-dexdump-脱壳原理"><a href="#Frida-dexdump-脱壳原理" class="headerlink" title="Frida-dexdump 脱壳原理"></a>Frida-dexdump 脱壳原理</h2><p>frida-dexdump 通过以下步骤实现 DEX 文件的解析：</p><ol><li>使用 Frida 注入到目标应用程序中，并找到 DEX 文件的内存地址。</li><li>将 DEX 文件的内存数据读取到 Frida 的 JavaScript 环境中，并使用 Frida 提供的 Memory API 将其转换成 JavaScript 的 ArrayBuffer 类型。</li><li>使用 JavaScript 实现的 DEX 文件解析器，解析 ArrayBuffer 中的 DEX 数据，并构建出 DEX 文件的数据结构，包括文件头、字符串池、类型池、方法池、字段池等。</li><li>将解析后的 DEX 文件数据结构转换成可读的文本格式，并输出到控制台或文件中。</li></ol><p>需要注意的是，Frida-dexdump 仅能解析已经加载到内存中的 DEX 文件，对于已经被加固或混淆的应用程序，DEX 文件可能会被加密或修改，导致无法正确解析。</p><h3 id="Frida-提供的-Memory-API"><a href="#Frida-提供的-Memory-API" class="headerlink" title="Frida 提供的 Memory API"></a>Frida 提供的 Memory API</h3><p>Frida 提供了一组 Memory API，用于在 Frida 的 JavaScript 环境中操作目标进程的内存数据。这些 API 包括：</p><ul><li>Memory.alloc(size)：在目标进程中分配指定大小的内存，并返回其内存地址。</li><li>Memory.copy(dest, src, size)：将目标进程中 src 地址开始的 size 字节数据复制到 dest 地址中。</li><li>Memory.protect(address, size, protection)：设置目标进程中指定内存区域的保护属性，包括读、写、执行等。</li><li>Memory.readByteArray(address, size)：从目标进程中指定地址读取指定大小的内存数据，并返回一个 Uint8Array 类型的数组。</li><li>Memory.readUtf8String(address)：从目标进程中指定地址读取以 NULL 结尾的 UTF8 字符串，并返回一个 JavaScript 字符串。</li><li>Memory.writeByteArray(address, bytes)：向目标进程中指定地址写入一个 Uint8Array 类型的数组。</li><li>Memory.writeUtf8String(address, str)：向目标进程中指定地址写入一个以 NULL 结尾的 UTF8 字符串。</li><li>Memory.scan(base, size, pattern, callbacks)：用于在目标进程的内存中搜索指定的内容。</li></ul><p>其中上面提到的 Memory.scan，也是 frida-dexdump 的第一步的原理，通过扫描内存中数据，判断是否包含 dex 头部相关信息，然后通过 readByteArray 返回具体内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Frida-dexdump-脱壳原理&quot;&gt;&lt;a href=&quot;#Frida-dexdump-脱壳原理&quot; class=&quot;headerlink&quot; title=&quot;Frida-dexdump 脱壳原理&quot;&gt;&lt;/a&gt;Frida-dexdump 脱壳原理&lt;/h2&gt;&lt;p&gt;frida-</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC</title>
    <link href="https://beichen.link/2023/09/16/Study/Android%E7%9F%A5%E8%AF%86/Android%20IPC/"/>
    <id>https://beichen.link/2023/09/16/Study/Android%E7%9F%A5%E8%AF%86/Android%20IPC/</id>
    <published>2023-09-16T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。</p><p>进程(process)和线程(thread)是两个不同的概念。进程一般指一个一个执行单元，是程序运行的实例，在移动设备上指一个应用；而线程是 CPU 调度和分派的最小单位。一个进程中可以有多个线程，两者是包含与被包含关系。</p><p>每一个 Android 应用程序都在它自己的进程中运行，都拥有一个独立的虚拟机实例。而每一个虚拟机都是在 Linux 中的一个进程，所以说可以认为是同一个概念。</p><p>任何一个操作系统都有相应的 IPC 机制，Linux 上面可以通过命名管道、共享内存、信号量等来进行 IPC。而在 Android 中，最有特色的就是 Binder，通过 Binder 可以轻松进行 IPC 操作。</p><h2 id="Andoid-IPC-基础概念"><a href="#Andoid-IPC-基础概念" class="headerlink" title="Andoid IPC 基础概念"></a>Andoid IPC 基础概念</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>Serializable 接口是 Java 提供的一个序列化接口，它是一个空接口，使用时只需要实现 Serializable 并声明一个 serialVersionUID 就可以，无需 override 任何方法。</p><p><code>private static final long serialVersionUID = 32163781263816L; </code></p><p>可以将实现了 Serializable 接口的对象序列化到文件中或者从文件中反序列化，操作非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化过程</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line">oos.writeObject(user);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过程</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> (user) ins.readObject();</span><br><span class="line">ins.close();</span><br></pre></td></tr></table></figure><p>实际上，甚至 serialVersionUID 常量都不是必须的，如果我们不声明这个常量，序列化会正常进行，但是会影响反序列化。</p><h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p>Parcelable 接口也是一种 Android 中的序列化接口,主要用在内存序列化上，性能比 Serializable 要好，性能要高，但是需要实现额外的方法。</p><p>通过 Parcelable 可以将对象序列化到存储设备中或将对象序列化后通过网络传输也都是可以的，这是过程会稍显复杂，这种情况下建议使用 Serializable。</p><p>实现 Parcelable 接口需要 override describeContents()和 writeToParcel()两个方法，以及一个 Parcelable.Creator<T>的内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyParcelable</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mData;</span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// describeContents方法一般返回0，仅当当前对象中存在文件描述符时，才返回1。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel out, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        out.writeInt(mData);</span><br><span class="line">        out.writeParcelable(book, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;MyParcelable&gt; CREATOR</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;MyParcelable&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> MyParcelable <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyParcelable</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> MyParcelable[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyParcelable</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyParcelable</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        mData = in.readInt();</span><br><span class="line">        book = in.readParcelable(Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>直观来说，Binder 是 Android 中的一个类，它实现了 IBinder 接口。</p><ul><li><p>从 IPC 角度来说，Binder 是 Android 中的一种跨进程通信方式。Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是&#x2F;dev&#x2F;binder，该通信方式在 Linux 中没有；</p></li><li><p>从 Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager 等等）和相应的 ManagerService 的桥梁；</p></li><li><p>从应用层来说，Binder 是客户端和服务端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于 AIDL 的服务。</p></li></ul><p>Binder 在 Android 应用开发中主要用于 Service 中，包括 AIDL 和 Messenger。</p><p>传统的 IPC 方式中，进程之间是如何实现通信的。</p><p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。</p><p>同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230828183707.png" alt="20230828183707"></p><p>这种传统的 IPC 通信方式有两个问题：</p><ul><li><p>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</p></li><li><p>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</p></li></ul><p>Binder IPC 是基于内存映射（mmap）来实现的，mmap 用来在内核空间创建数据接收的缓存空间。</p><p>mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p><p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p><p>一次完整的 Binder IPC 通信过程通常是这样：</p><ol><li><p>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</p></li><li><p>接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系；</p></li><li><p>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</p></li></ol><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230828183830.png" alt="20230828183830"></p><p>Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230828184122.png" alt="20230828184122"></p><h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><p>Android 中可以实现 IPC 方式的有很多，比如通过 Intent 附加 extras 传递信息，通过共享文件传递数据，还可以采用 Binder 方式来进行 IPC。另外，ContentProvider 天生就是支持 IPC 的，通过网络通信也是可以的，因此还可以采用 Socket。</p><p>下表是常见 IPC 方式的优缺点以及使用场景</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230828165029.png" alt="20230828165029"></p><h3 id="1-基于序列化-Serializable-x2F-Parcelable-接口"><a href="#1-基于序列化-Serializable-x2F-Parcelable-接口" class="headerlink" title="1 基于序列化 Serializable&#x2F;Parcelable 接口"></a>1 基于序列化 Serializable&#x2F;Parcelable 接口</h3><h4 id="1-1-Java-Serializable"><a href="#1-1-Java-Serializable" class="headerlink" title="1.1 Java Serializable"></a>1.1 Java Serializable</h4><p>将对象序列化到文件中或者从文件中反序列化</p><h4 id="1-2-Android-Parcelable-接口"><a href="#1-2-Android-Parcelable-接口" class="headerlink" title="1.2 Android Parcelable 接口"></a>1.2 Android Parcelable 接口</h4><p>bundle 就实现了 parcelable 接口，可用于不同进程间传输</p><p>我们知道 Intent 的启动 Activity、Service、Receiver 都是通过构造 ComponentName 来实现的，我们可以使用 intent.setComponent(new ComponentName())的方式来显示开启另一进程的组件，或者以隐式的方式开启。<br>当然缺点是 Bundle 支持的数据类型有限。</p><h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2 使用文件共享"></a>2 使用文件共享</h3><p>两个进程读写同一个文件来交换数据。在 Window 上，一个文件加了锁会导致其他进程无法访问该文件，但是在 Linux 上，对其进行并发读写是没有任何限制的，甚至可以并发写，尽管这很可能出问题。</p><p>文件共享适合在数据同步不高的进程间进行通信，并且需要妥善处理好读写问题。</p><p>SharedPreferences 也属于文件的一种，但是系统会在内存中持有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对其进行的读写就不可靠，面对高并发的读写访问，SharedPreferences 有很大几率会丢失数据。</p><h3 id="3-AIDL-方案"><a href="#3-AIDL-方案" class="headerlink" title="3 AIDL 方案"></a>3 AIDL 方案</h3><p>一种基于 Binder 机制的接口定义语言，用于定义客户端和服务端之间进行通信的规则。AIDL 文件会被编译成 Java 文件，生成对应的 Stub 类和 Proxy 类，分别用于服务端和客户端实现和调用跨进程方法。</p><h4 id="3-1-使用-Messenger"><a href="#3-1-使用-Messenger" class="headerlink" title="3.1 使用 Messenger"></a>3.1 使用 Messenger</h4><p>一种基于 AIDL 和 Handler 机制的简单 IPC 方式，用于在不同进程之间发送和接收 Message 对象。Messenger 内部封装了一个实现了 AIDL 接口的 Binder 对象，并使用 Handler 来处理 Message 对象。</p><p>但它一次只能处理一个请求，因此不需要在服务端考虑因并发执行而产生的线程同步问题。</p><h4 id="3-2-使用-AIDL"><a href="#3-2-使用-AIDL" class="headerlink" title="3.2 使用 AIDL"></a>3.2 使用 AIDL</h4><p>AIDL(Android Interface Definition Language)</p><h5 id="3-2-1-使用-AIDL-的必要条件"><a href="#3-2-1-使用-AIDL-的必要条件" class="headerlink" title="3.2.1 使用 AIDL 的必要条件"></a>3.2.1 使用 AIDL 的必要条件</h5><ul><li>只有当你需要来自不同应用的客户端通过 IPC（进程间通信）通信来访问你的服务时，并且想在服务里处理多线程的业务，这时就需要使用 AIDL。</li><li>如果你不需要同时对几个应用进程 IPC 操作，你最好通过实现 Binder 接口来创建你的接口。</li><li>如果你仍需要执行 IPC 操作，但不需要处理多线程，使用 Messenger 来实现接口即可。</li></ul><h5 id="3-2-2-AIDL-的使用"><a href="#3-2-2-AIDL-的使用" class="headerlink" title="3.2.2 AIDL 的使用"></a>3.2.2 AIDL 的使用</h5><h4 id="3-3-使用-ContentProvider"><a href="#3-3-使用-ContentProvider" class="headerlink" title="3.3 使用 ContentProvider"></a>3.3 使用 ContentProvider</h4><p>和 Messenger 一样，ContentProvider 底层实现同样也是 Binder，但是使用过程比 AIDL 要简单的多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。&lt;/p&gt;
&lt;p&gt;进程(process)和线程(thread)是两个不同的概念。进程一般指一个一个执行单元，是程序运行的实例，在移动</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="Android知识" scheme="https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>找到的面试题</title>
    <link href="https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%89%BE%E5%88%B0%E7%9A%84%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%89%BE%E5%88%B0%E7%9A%84%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-09-15T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-initarry-的作用，可以没有-initarry-么？"><a href="#1-initarry-的作用，可以没有-initarry-么？" class="headerlink" title="1. initarry 的作用，可以没有 initarry 么？"></a>1. initarry 的作用，可以没有 initarry 么？</h2><p>移动端 Android 安全的发展，催生了各种 Android 加固的诞生，基于 ELF 文件的特性，很多的加固厂商在进行 Android 逆向的对抗的时，都会在 Android 的 so 文件中进行动态的对抗，对抗的点一般在 so 文件的. init 段和 JNI_OnLoad 处。因此，我们在逆向分析各种厂商的加固 so 时，需要在 so 文件的. init 段和 JNI_OnLoad 处下断点进行分析，过掉这些加固的 so 对抗。</p><p>init 和.init_array 两个 section 用于在 so 文件被加载时做初始化工作，系统在加载 so 文件时会先执行.init 中的代码，然后再顺序执行.init_array 中的各个代码块，且.init 和.init_array 的执行时机均早于 JNI_OnLoad 方法，所以这两个 section 的执行时间是比较早的</p><p>init_array 是 ELF 文件中的一个特殊 section，用于存储全局构造函数（global constructors）的地址。在程序启动时，动态链接器会按照 init_array 中的顺序调用这些构造函数，用于全局对象的初始化。</p><p>在 Android NDK 编程中，.init 和.init_array 中函数的定义方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _init();   <span class="comment">//编译生成后在.init段</span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="type">void</span> _init();      <span class="comment">//编译生成后在.init_array段</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不难看出，若函数名指定为_init，则通过 NDK 编译以后该函数的代码会在.init 中；若函数被<strong>attribute</strong>((constructor))属性修饰，则编译以后该函数会在.init_array 中。</p><p>_init 函数经过编译后就是 .init_proc 函数</p><p>可以没有 init_array，但这意味着全局构造函数将不被执行。对于某些程序，这可能导致未定义的行为或程序错误。如果程序不依赖全局构造函数进行初始化，则可以没有 init_array。</p><h2 id="2-为什么可以删除-section-节区？"><a href="#2-为什么可以删除-section-节区？" class="headerlink" title="2. 为什么可以删除 section 节区？"></a>2. 为什么可以删除 section 节区？</h2><p>在 ELF 文件中，section 是用来存储各种类型的信息（例如：代码段、数据段、符号表、重定位表等）。链接器（Linker）在链接过程中使用这些信息来生成可执行文件。一旦链接过程完成，生成了可执行文件，某些 section 的信息就不再需要了。</p><p>删除无用的 section 节区可以减小可执行文件的大小，节省存储空间和内存。需要注意的是，并非所有 section 都可以删除。删除关键 section（例如：代码段、数据段等）可能导致程序无法正常运行。</p><p><a href="https://segmentfault.com/a/1190000044097864">https://segmentfault.com/a/1190000044097864</a></p><p><a href="https://pollux.cc/2020/02/19/inlineHookS/">https://pollux.cc/2020/02/19/inlineHookS/</a></p><p><a href="https://eternalsakura13.com/2020/07/04/frida/">https://eternalsakura13.com/2020/07/04/frida/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-initarry-的作用，可以没有-initarry-么？&quot;&gt;&lt;a href=&quot;#1-initarry-的作用，可以没有-initarry-么？&quot; class=&quot;headerlink&quot; title=&quot;1. initarry 的作用，可以没有 initarry </summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>待整理的文章</title>
    <link href="https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E5%9D%80/"/>
    <id>https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E5%9D%80/</id>
    <published>2023-09-15T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sentrylab.cn/blog/2022/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">https://sentrylab.cn/blog/2022/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</a></p><p><a href="https://github.com/CrackerCat/simpread/blob/00738d68838ac1b1c4e6be39f37b8b3714411764/md/%5B%E5%8E%9F%E5%88%9B%5D%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95%20%2B%20ollvm%20%E6%B7%B7%E6%B7%86%E7%9A%84%20Crackme.md?plain=1#L15">https://github.com/CrackerCat/simpread/blob/00738d68838ac1b1c4e6be39f37b8b3714411764/md/%5B%E5%8E%9F%E5%88%9B%5D%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95%20%2B%20ollvm%20%E6%B7%B7%E6%B7%86%E7%9A%84%20Crackme.md?plain=1#L15</a></p><p><a href="https://www.wanandroid.com/blog/show/3490">https://www.wanandroid.com/blog/show/3490</a></p><p><a href="https://juejin.cn/post/7045535769200427045">https://juejin.cn/post/7045535769200427045</a></p><p><a href="https://bbs.kanxue.com/thread-273160.htm">https://bbs.kanxue.com/thread-273160.htm</a></p><p><a href="https://www.bilibili.com/video/BV1Y84y1Y7Nc/?vd_source=8f930e2394b37d35a2e863ca32b036b3">https://www.bilibili.com/video/BV1Y84y1Y7Nc/?vd_source=8f930e2394b37d35a2e863ca32b036b3</a></p><p><a href="https://weishu.me/page/2/">https://weishu.me/page/2/</a></p><p><a href="https://github.com/WindXaa/Android-Vulnerability-Mining">https://github.com/WindXaa/Android-Vulnerability-Mining</a></p><p><a href="http://si1ence.top/">http://si1ence.top/</a></p><p><a href="https://www.bilibili.com/read/cv24212888/">https://www.bilibili.com/read/cv24212888/</a></p><p><a href="https://github.com/bigGreenPeople/SharkInject/blob/1294d428532facac81ef5d19f3d89d3dce453584/app/src/main/cpp/native-lib/native-lib.cpp#L10">https://github.com/bigGreenPeople/SharkInject/blob/1294d428532facac81ef5d19f3d89d3dce453584/app/src/main/cpp/native-lib/native-lib.cpp#L10</a></p><p>签名：<a href="https://github.com/gtf35/how-to-check-sign">https://github.com/gtf35/how-to-check-sign</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sentrylab.cn/blog/2022/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&quot;&gt;htt</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IDA 调试 init_array</title>
    <link href="https://beichen.link/2023/09/13/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E8%B0%83%E8%AF%95init/"/>
    <id>https://beichen.link/2023/09/13/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E8%B0%83%E8%AF%95init/</id>
    <published>2023-09-13T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.751Z</updated>
    
    <content type="html"><![CDATA[<p>在安卓脱壳过程中，经常需要用 ida 动态调试 so,并且在解密代码执行前下断点，下面介绍用 IDA 在 Android so 文件的.init、.init_array 上和 JNI_OnLoad 处下断点方法。</p><h2 id="一、上传-android-server-启动-android-server"><a href="#一、上传-android-server-启动-android-server" class="headerlink" title="一、上传 android_server,启动 android_server"></a>一、上传 android_server,启动 android_server</h2><p>上传 android_server 到手机&#x2F;data&#x2F;local&#x2F;tmp 目录</p><p><code>adb push  android_server   /data/local/tmp</code></p><p>赋予 android_server 执行权限</p><p><code>$ chmod 777 android_server</code></p><p>以 root 身份执行 android_server 文件，android_server 文件默认监听 23946 端口，可以通过-p 端口参数进行设置端口，注意 p 和端口之间无空格</p><p><code>./android_server -p23946</code></p><h2 id="二、打开-DDMS-程序"><a href="#二、打开-DDMS-程序" class="headerlink" title="二、打开 DDMS 程序"></a>二、打开 DDMS 程序</h2><p>打开 DDMS 程序,DDMS 程序会将应用的调试端口映射到电脑上，使用 jdb 命令能够对被挂起的程序恢复执行。</p><h2 id="三、进行端口转发"><a href="#三、进行端口转发" class="headerlink" title="三、进行端口转发"></a>三、进行端口转发</h2><p>使用 adb 命令进行端口转发</p><p><code>adb forward tcp:23946（PC_port） tcp:23946(Phone_port)</code></p><h2 id="四、以调试模式启动-app"><a href="#四、以调试模式启动-app" class="headerlink" title="四、以调试模式启动 app"></a>四、以调试模式启动 app</h2><p>我们以 debug 模式启动程序。程序会出现 waiting for debugger 的调试界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.example.inittest/.MainActivity</span><br><span class="line">Starting: Intent &#123; cmp=com.example.inittest/.MainActivity &#125;</span><br></pre></td></tr></table></figure><p>程序会出现 waiting for debugger 的调试界面</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101358.png" alt="20230906101358"></p><p>这时 DDMS 显示，调试端口在 8700</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101428.png" alt="20230906101428"></p><h2 id="五、用-IDA-附加到启动-ida-并-attach-这个-app-的进程。"><a href="#五、用-IDA-附加到启动-ida-并-attach-这个-app-的进程。" class="headerlink" title="五、用 IDA 附加到启动 ida 并 attach 这个 app 的进程。"></a>五、用 IDA 附加到启动 ida 并 attach 这个 app 的进程。</h2><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101451.png" alt="20230906101451"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101509.png" alt="20230906101509"></p><h2 id="六、当-so-加载的时候挂起"><a href="#六、当-so-加载的时候挂起" class="headerlink" title="六、当 so 加载的时候挂起"></a>六、当 so 加载的时候挂起</h2><p>在 debugger setup 里勾选 suspend on library load。然后点击继续（按 F9 键继续）。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101620.png" alt="20230906101620"></p><h2 id="七、使用-jdb-命令恢复程序执行"><a href="#七、使用-jdb-命令恢复程序执行" class="headerlink" title="七、使用 jdb 命令恢复程序执行"></a>七、使用 jdb 命令恢复程序执行</h2><p>使用 jdb 命令恢复程序执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</span></span><br><span class="line"></span><br><span class="line">设置未捕获的java.lang.Throwable</span><br><span class="line">设置延迟的未捕获的java.lang.Throwable</span><br><span class="line">正在初始化jdb...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时 DDMS 中该应用的颜色变为了绿色：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101826.png" alt="20230906101826"></p><p>程序加载 so,由于之前的设置，程序停在了 liner 处</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101844.png" alt="20230906101844"></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906101859.png" alt="20230906101859"></p><h2 id="八、确定模块的加载地址，在-linker-和-libvm-so-中下断点"><a href="#八、确定模块的加载地址，在-linker-和-libvm-so-中下断点" class="headerlink" title="八、确定模块的加载地址，在 linker 和 libvm.so 中下断点"></a>八、确定模块的加载地址，在 linker 和 libvm.so 中下断点</h2><p>在 android4.4.4_r1 源码中，linker 中 .init 和.init_array 的断点位置为 0000274C,JNI_OnLoad 的断点位置为 00050004</p><p>我们先查看内存中 segment 中 linker 加载的位置</p><p>按 Ctrl+S 组合键打开内存中的 segmets,知道 linker 的内存加载地址 4008B000,那么断点的位置是 4008B000+0000274C&#x3D;4008D74C。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906102308.png" alt="20230906102308"></p><p>按 G 键输入地址 4008D74C 进行跳转，将光标移至该处后按 P 键进行反汇编，看到了汇编代码，在该处 4008D74C 下断点</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230906102439.png" alt="20230906102439"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在安卓脱壳过程中，经常需要用 ida 动态调试 so,并且在解密代码执行前下断点，下面介绍用 IDA 在 Android so 文件的.init、.init_array 上和 JNI_OnLoad 处下断点方法。&lt;/p&gt;
&lt;h2 id=&quot;一、上传-android-serve</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="逆向知识" scheme="https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>System Server</title>
    <link href="https://beichen.link/2023/09/10/Study/Android%E7%9F%A5%E8%AF%86/System_Server%E5%AD%A6%E4%B9%A0/"/>
    <id>https://beichen.link/2023/09/10/Study/Android%E7%9F%A5%E8%AF%86/System_Server%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-10T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>安卓最重要的系统进程当然是 system_process. 这个进程是 zygote 孵化的第一个进程，它管理着安卓系统中各种大大小小的系统 service 的实现（SystemService）。也就是下面图中各种 manager 的 server 端实现（安卓的 C&#x2F;S 架构）。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230830151128.png" alt="20230830151128"></p><p>系统服务其实都是一个远程 Binder 对象，而这个对象都是由 ServiceManager 大管家管理的，用户在使用系统服务的时候，会通过指定服务的 Stub 类的 asInterface 方法 把远程的 Binder 对象转化成本地化对象即可使用，而在这个过程中，我们也知道因为系统服务是在 system_server 进程中的，所以这个系统服务使用过程中属于跨进程调用，那么返回的对象其实就是 Proxy 代理对象。</p><h2 id="系统服务使用流程"><a href="#系统服务使用流程" class="headerlink" title="系统服务使用流程"></a>系统服务使用流程</h2><p>通过系统剪切板服务案例作为分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取剪切板服务</span></span><br><span class="line"><span class="type">ClipboardManager</span> <span class="variable">cm</span> <span class="operator">=</span>(ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);</span><br><span class="line"><span class="comment">//设置剪切板内容</span></span><br><span class="line">cm.setPrimaryClip(ClipData.newPlainText(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;jack&quot;</span>));</span><br><span class="line"><span class="comment">//获取剪切板数据对象</span></span><br><span class="line"><span class="type">ClipData</span> <span class="variable">cd</span> <span class="operator">=</span> cm.getPrimaryClip();</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> cd.getItemAt(<span class="number">0</span>).getText().toString();</span><br><span class="line">Log.d(<span class="string">&quot;jw&quot;</span>, <span class="string">&quot;msg:&quot;</span>+ msg);</span><br></pre></td></tr></table></figure><p>使用系统服务的时候都是用了 getSystemService 方法，通过定义在 Context 中的服务描述符常量来获取服务对象 ClipboardManager</p><p>但是实际上内部是先通过 ServiceManager 获取到 ClipboardManager 的远程 IBinder 对象，然后再通过 IClipboard$Stub方法将IBinder对象转化成本地对象，即IClipboard$Proxy 对象</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230830154313.png" alt="20230830154313"></p><p>每次获取系统服务的流程都是一样的，先通过 ServiceManager 的 getService 方法获取远端服务的 IBinder 对象，然后在通过指定服务的 Stub 类的 asInterface 方法转化成本地可使用对象，而这个对象其实就是一个 Proxy 对象</p><h2 id="Java-代理模式"><a href="#Java-代理模式" class="headerlink" title="Java 代理模式"></a>Java 代理模式</h2><p>意图：为其他对象提供一种代理以控制对这个对象的访问。</p><p>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p>何时使用：想在访问一个类时做一些控制。</p><p>如何解决：增加中间层。</p><p>关键代码：实现与被代理类组合。</p><p>应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。</p><p>优点： 1、职责清晰。 2、高扩展性。 3、智能化。</p><p>缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理是指代理类在程序运行前就已经存在，这种情况下的代理类通常都是我们在 Java 代码中定义的。</p><p>这种代理方式需要代理对象和目标对象实现一样的接口。</p><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p><p>缺点：</p><ul><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li><li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ul><p>举例：保存用户数据功能的静态代理实现</p><p>接口类： IUserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象：UserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理对象：UserDapProxy 需要实现 IUserDao 接口！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(IUserDao target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);<span class="comment">//扩展了额外功能</span></span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：TestProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticUserProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStaticProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(target);</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">提交事务</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是指代理类在程序运行时进行创建的代理方式。这种情况下，代理类并不是在 Java 代码中定义的，而是在运行时根据 Java 代码中的“指示”动态生成的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p><ul><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的 class 文件</li><li>动态代理是在运行时动态生成的，即编译完成后没有实际的 class 文件，而是在运行时动态生成类字节码，并加载到 JVM 中</li></ul><h4 id="基于-JDK-原生动态代理实现"><a href="#基于-JDK-原生动态代理实现" class="headerlink" title="基于 JDK 原生动态代理实现"></a>基于 JDK 原生动态代理实现</h4><p>实现动态代理通常有两种方式：JDK 原生动态代理和 CGLIB 动态代理。这里，我们以 JDK 原生动态代理为例来进行讲解。</p><p>JDK 动态代理需要目标对象实现业务接口，代理类只需实现 InvocationHandler 接口, 通过反射代理方法，尽管比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</p><p>JDK 动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler。</p><p>InvocationHandler 接口定义了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，实现了该接口的中介类用做“调用处理器”。当调用代理类对象的方法时，这个“调用”会转送到 invoke 方法中，代理类对象作为 proxy 参数传入，参数 method 标识了具体调用的是代理类的哪个方法，args 为该方法的参数。这样对代理类中的所有方法的调用都会变为对 invoke 的调用，可以在 invoke 方法中添加统一的处理逻辑(也可以根据 method 参数对不同的代理类方法做不同的处理)。</p><p>Proxy 类用于获取指定代理对象所关联的调用处理器。java.lang.reflect Proxy，主要方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">    ClassLoader loader,  //指定当前目标对象使用类加载器</span></span><br><span class="line"><span class="params">    Class&lt;?&gt;[] interfaces,    //目标对象实现的接口的类型</span></span><br><span class="line"><span class="params">    InvocationHandler h      //事件处理器</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"><span class="comment">//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span></span><br></pre></td></tr></table></figure><p>需要实现的中介类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object target;  <span class="comment">// 被代理的对象，实际的方法执行者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);  <span class="comment">// 调用 target 的 method 方法</span></span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回方法的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之前执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log start time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用invoke方法之后执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;log end time [%s] &quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端编写程序使用动态代理代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建中介类实例</span></span><br><span class="line">        <span class="type">LogHandler</span> <span class="variable">logHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(<span class="keyword">new</span> <span class="title class_">Vendor</span>()); <span class="comment">//vendor为被代理对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理类实例Sell</span></span><br><span class="line">        <span class="type">Sell</span> <span class="variable">sell</span> <span class="operator">=</span> (Sell) (Proxy.newProxyInstance(Sell.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Sell.class&#125;, logHandler));  <span class="comment">//sell为接口类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代理类对象调用代理类方法，实际上会转到invoke方法调用</span></span><br><span class="line">        sell.sell();</span><br><span class="line">        sell.ad();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安卓最重要的系统进程当然是 system_process. 这个进程是 zygote 孵化的第一个进程，它管理着安卓系统中各种大大小小的系统 service 的实现（SystemService）。也就是下面图中各种 manager 的 server 端实现（安卓的 C&amp;#x</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="Android知识" scheme="https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>算法题java语法</title>
    <link href="https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98java%E8%AF%AD%E6%B3%95/"/>
    <id>https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98java%E8%AF%AD%E6%B3%95/</id>
    <published>2023-08-27T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入、输出"><a href="#输入、输出" class="headerlink" title="输入、输出"></a>输入、输出</h2><p>远程在线面试的手撕代码环节，通常需要白板上写代码。如果需要在控制台输入、输出，需要借助 Scanner 类。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//方法1：一般用来接收数组。以空格分界</span></span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="comment">/*或者*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法2：一般用来接受字符串。以换行符分界</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><ol><li><p>String -&gt; int：int value &#x3D; Integer.parseInt(str);</p></li><li><p>将 str 转换成二进制的 int： int binary &#x3D; Integer.parseInt(str,2);</p></li><li><p>十进制转二进制：String binaryN &#x3D; Integer.toBinaryString(N);</p></li></ol><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol><li><p>Object -&gt; String：String str &#x3D; String.valueOf(o);</p></li><li><p>char[ ] -&gt; String：String str &#x3D; String.valueOf(charArray);</p></li><li><p>int -&gt; String：String str &#x3D; String.valueOf(N);</p></li></ol><h2 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h2><ol><li><p>长度：int len &#x3D; str.length();</p></li><li><p>字符串比较：str1.equals()</p></li><li><p>字符串替换：String newStr &#x3D; str.replaceAll(“a”,”.”); &#x2F;&#x2F;replace 只能换 char</p></li><li><p>字符串分割：String newStr &#x3D; str.split(“ “); &#x2F;&#x2F;根据括号里的分割</p></li><li><p>String -&gt; char[ ]：char[] charStr &#x3D; str.toCharArray();</p><p>String -&gt; char：char charS &#x3D; str.charAt(index);</p></li><li><p>字符串变小写：String lowerStr &#x3D; str.toLowerCase();</p><p>字符串变大写：String upperStr &#x3D; str.toUpperCase();</p></li><li><p>字符串截取：str.substring(start,end); &#x2F;&#x2F;包含 start,不包含 end</p></li><li><p>数字转字符串：String str &#x3D; String.valueOf(123456);</p></li><li><p>辅助工具类：StringBuider sb &#x3D; new StringBuilder(“”);</p><p>&#x2F;&#x2F;添加<br>sb.append(“”);<br>&#x2F;&#x2F;删除<br>sb.deleteCharAt();<br>&#x2F;&#x2F;反转<br>sb.reverse();<br>&#x2F;&#x2F; 转 string<br>sb.toString();</p></li></ol><h2 id="对-Map-的方法"><a href="#对-Map-的方法" class="headerlink" title="对 Map 的方法"></a>对 Map 的方法</h2><ol><li><p>map 中是否包含 key：boolean isContain &#x3D; map.containsKey(key);</p></li><li><p>map 的 get()：Object value &#x3D; map.get(key);</p><p>map 的 getOrDefault()： map.getOrDefault(key,default);&#x2F;&#x2F;没找到就 return default</p></li><li><p>map 的 put()：map.put(key,value); &#x2F;&#x2F;若 key 已存在，则替代并返回旧的 value 值</p></li><li><p>map 的遍历：for(Object key : map.keySet()){ &#x2F;&#x2F;… }</p></li></ol><h2 id="求长度"><a href="#求长度" class="headerlink" title="求长度"></a>求长度</h2><ol><li><p>数组：用 arr.length length 是数组的一个属性。</p></li><li><p>字符串：用 str.length() length() 是 StringObject 的一个方法。</p></li><li><p>集合：用 list.size() size()是 list 的一个方法。</p></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>长度：int h &#x3D; height.length</p></li><li><p>新建：int[] tmp &#x3D; new int[arr.length];</p></li><li><p>排序：Arrays.sort(nums); &#x2F;&#x2F;从小到大排序，时间复杂度为 o(nlog n)</p></li><li><p>复制：Arrays.copyOf 复制一个数组：int[] newA &#x3D; Array.copyOf(a, 5); &#x2F;&#x2F;5 为数组 size</p></li><li><p>初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type[] names = new Type[capacity];</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Type[] names = new Type[]&#123;Tpye ...a&#125;;</span></span><br><span class="line"> <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// int[] a = &#123;1, 2, 3, 4&#125;;</span></span><br><span class="line"> <span class="type">char</span>[] b = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;; <span class="comment">// char[] b = &#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;;</span></span><br><span class="line"> String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="HashMap-和-HashSet"><a href="#HashMap-和-HashSet" class="headerlink" title="HashMap 和 HashSet"></a>HashMap 和 HashSet</h2><p>HashMap 即：映射 (Map 接口，将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值) 性质：使用健值对的方式存储数据 &lt;Key,Value&gt;</p><p>初始化：Map&lt;Characters, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</p><ol><li><p>map 中是否包含 key：boolean isContain &#x3D; map.containsKey(key);</p></li><li><p>map 的 put()将键值对&lt;K,V&gt;放入 map ：map.put(key,value);</p></li><li><p>map 的 get()获得指定 key 值对应键值：Object value &#x3D; map.get(key);<br>map 的 getOrDefault()： map.getOrDefault(key,default);&#x2F;&#x2F;没找到就 return default</p></li><li><p>map.keySet(): 返回一个 Set,这个 Set 中包含 Map 中所有的 Key<br>map.values(): 返回一个 Collection<v>,里面全是对应的每一个 value<br>map 的遍历：for(Object key : map.keySet()){ &#x2F;&#x2F;… }<br>for (Integer value : map.values()) {·····}</p></li><li><p>map 删除指定键值:map.remove(Object key)</p></li><li><p>map.isEmpty(): 判断是不是空：</p></li><li><p>map.size(): 返回 Map 中中键值对&lt;K, V&gt;的个数:</p></li></ol><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>集合(Set 接口是一个不包含重复元素的集合)性质：Set 中没有重复元素，重复添加的元素抛弃</p><p>导入库 java.util.HashSet</p><p>HashSet 初始化: HashSet<T> setname &#x3D; new HashSet&lt;&gt;();</p><ol><li><p>.add() 增加元素</p></li><li><p>.contains():判断是否存在一个元素</p></li><li><p>.remove() 删除一个制定元素</p></li><li><p>.isEmpty() 判断集合是否为空</p></li><li><p>.clear() 清空集合</p></li><li><p>.size() 返回集合中中元素个数</p></li></ol><h2 id="Stack-先进后出"><a href="#Stack-先进后出" class="headerlink" title="Stack 先进后出"></a>Stack 先进后出</h2><p>初始化 : Stack<Integer> stack &#x3D; new Stack<Integer>();</p><ol><li>入栈：stack.push(Object o)&#x2F;&#x2F; 入栈元素 o， 返回值为元素 o</li><li>出栈：stack.pop()&#x2F;&#x2F; 出栈一个元素，返回出栈元素 o</li><li>返回栈顶：stack.peek()&#x2F;&#x2F; 查看栈顶元素， 返回值为栈顶元素 o</li><li>栈空：stack.isEmpty()&#x2F;&#x2F; 若栈空返回 true， 否则返回 false</li><li>元素个数：stack.size() &#x2F;&#x2F; 返回栈中元素个数</li><li>遍历用 for (Integer x : s)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;输入、输出&quot;&gt;&lt;a href=&quot;#输入、输出&quot; class=&quot;headerlink&quot; title=&quot;输入、输出&quot;&gt;&lt;/a&gt;输入、输出&lt;/h2&gt;&lt;p&gt;远程在线面试的手撕代码环节，通常需要白板上写代码。如果需要在控制台输入、输出，需要借助 Scanner 类。示例如下</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="算法" scheme="https://beichen.link/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法练习</title>
    <link href="https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    <id>https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/</id>
    <published>2023-08-27T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><h3 id="1-反转链表-leetcode-206"><a href="#1-反转链表-leetcode-206" class="headerlink" title="1. 反转链表 leetcode 206"></a>1. 反转链表 leetcode 206</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-链表翻转-II-leetcode-92"><a href="#2-链表翻转-II-leetcode-92" class="headerlink" title="2. 链表翻转 II leetcode 92"></a>2. 链表翻转 II leetcode 92</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表。</p><p>头插法，一轮遍历即可。</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230823151106.png" alt="20230823151106"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">            next.next = pre.next;</span><br><span class="line">            <span class="comment">//z=这里不能用next.next = cur; 因为cur的值没变，但位置在变，只有pre.next 一直指向开头节点</span></span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-二叉树的层序遍历-leetcode-102"><a href="#3-二叉树的层序遍历-leetcode-102" class="headerlink" title="3. 二叉树的层序遍历 leetcode 102"></a>3. 二叉树的层序遍历 leetcode 102</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先遍历，BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">                tmp.add(t.val);</span><br><span class="line">                <span class="keyword">if</span> (t.left != <span class="literal">null</span> )&#123;</span><br><span class="line">                    queue.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// dfs,深度优先遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>,root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span> <span class="params">(<span class="type">int</span> index,TreeNode root,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt; index)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(index-<span class="number">1</span>).add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>,root.left,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>,root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-全排列-leetcode-46"><a href="#4-全排列-leetcode-46" class="headerlink" title="4. 全排列 leetcode 46"></a>4. 全排列 leetcode 46</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List &lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,used,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> len,<span class="type">int</span> depth,List&lt;Integer&gt; path ,<span class="type">boolean</span>[] used,List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs( nums,len,depth+<span class="number">1</span>,path,used,res);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-数组中第-k-个最大元素-leetcode-215"><a href="#5-数组中第-k-个最大元素-leetcode-215" class="headerlink" title="5. 数组中第 k 个最大元素 leetcode 215"></a>5. 数组中第 k 个最大元素 leetcode 215</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机选择基准数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums.get(rand.nextInt(nums.size()));</span><br><span class="line">        <span class="comment">// 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中</span></span><br><span class="line">        List&lt;Integer&gt; big = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; equal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; pivot)</span><br><span class="line">                big.add(num);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pivot)</span><br><span class="line">                small.add(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                equal.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 k 大元素在 big 中，递归划分</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= big.size())</span><br><span class="line">            <span class="keyword">return</span> quickSelect(big, k);</span><br><span class="line">        <span class="comment">// 第 k 大元素在 small 中，递归划分</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size() - small.size() &lt; k)</span><br><span class="line">            <span class="keyword">return</span> quickSelect(small, k - nums.size() + small.size());</span><br><span class="line">        <span class="comment">// 第 k 大元素在 equal 中，直接返回 pivot</span></span><br><span class="line">        <span class="keyword">return</span> pivot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            numList.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(numList, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-无重复字符的最长子串-leetcode-3"><a href="#6-无重复字符的最长子串-leetcode-3" class="headerlink" title="6. 无重复字符的最长子串 leetcode 3"></a>6. 无重复字符的最长子串 leetcode 3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-合并两个有序链表-leetcode-21"><a href="#7-合并两个有序链表-leetcode-21" class="headerlink" title="7. 合并两个有序链表 leetcode 21"></a>7. 合并两个有序链表 leetcode 21</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;快手&quot;&gt;&lt;a href=&quot;#快手&quot; class=&quot;headerlink&quot; title=&quot;快手&quot;&gt;&lt;/a&gt;快手&lt;/h2&gt;&lt;h3 id=&quot;1-反转链表-leetcode-206&quot;&gt;&lt;a href=&quot;#1-反转链表-leetcode-206&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="算法" scheme="https://beichen.link/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python学习</title>
    <link href="https://beichen.link/2023/08/25/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/python%E7%9F%A5%E8%AF%86/"/>
    <id>https://beichen.link/2023/08/25/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/python%E7%9F%A5%E8%AF%86/</id>
    <published>2023-08-25T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述下-Python-中的字符串、列表、元组和字典"><a href="#简述下-Python-中的字符串、列表、元组和字典" class="headerlink" title="简述下 Python 中的字符串、列表、元组和字典"></a>简述下 Python 中的字符串、列表、元组和字典</h2><ul><li><p>字符串（str）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。</p></li><li><p>列表（list）：列表是有序的集合，可以向其中添加或删除元素。</p></li><li><p>元组（tuple）：元组也是有序集合，但是是无法修改的。即元组是不可变的。</p></li><li><p>字典（dict）：字典是无序的集合，是由 key-value 组成的。</p></li><li><p>集合（set）：是一组 key 的集合，每个元素都是唯一，不重复且无序的</p></li></ul><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><a href="https://blog.csdn.net/weixin_44992737/article/details/125868592">参考</a><br>装饰器，装饰的对象是函数或者方法。各种装饰器的作用都是一样的：改变被装饰函数或者方法的功能，性质</p><p>场景：装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_time</span>(<span class="params">func</span>):</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">  time1 = time.time()</span><br><span class="line">  func()</span><br><span class="line">  time2 = time.time()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;cost time:&quot;</span> + <span class="built_in">str</span>(time2 - time1))</span><br><span class="line"> <span class="keyword">return</span> inner()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep1</span>():</span><br><span class="line"> time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_time </span><span class="comment"># 相当于sleep2 = get_time(sleep2)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleep2</span>():</span><br><span class="line"> time.sleep(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">sleep1 = get_time(sleep1)</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器就是用于迭代操作（for 循环）的对象，它像列表一样可以迭代获取其中的每一个元素，任何实现了 <strong>next</strong> 方法 （python2 是 next）的对象都可以称为迭代器。</p><p>它与列表的区别在于，构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算（lazy evaluation）方式返回元素，这正是它的优点。比如列表含有中一千万个整数，需要占超过 400M 的内存，而迭代器只需要几十个字节的空间。因为它<strong>并没有把所有元素装载到内存</strong>中，而是等到调用 next 方法时候才返回该元素（按需调用 call by need 的方式，本质上 for 循环就是不断地调用迭代器的 next 方法）</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>yield 语句返回值，yeild 存在的函数为生成器函数</p><p>生成器本质上还是一个迭代器，唯一的区别在于实现方式不同</p><p>生成器函数调用时不会立刻返回，而是调用 next 方法时才会返回</p><h2 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h2><p>编译型（需要编译器）：编译型语言执行速度快，不依赖语言环境运行，跨平台差，如 C&#x2F;C++、Go 执行速度快，调试麻烦</p><p>解释型（需要解释器）：解释型跨平台好，一份代码，到处使用，缺点是执行速度慢，依赖解释器运行，如 Python、JAVA 执行速度慢，调试方便</p><h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2><p>引用传递</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>函数内部有一个内嵌函数<br>内嵌函数引用外部函数的变量<br>外部函数的返回值是内嵌函数</p><h2 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h2><p>匿名函数 可以包含任意数量的参数，但是只能有一个执行操作的语句</p><p><code>lambda x：x = x + 1</code></p><h2 id="装饰器-1"><a href="#装饰器-1" class="headerlink" title="装饰器"></a>装饰器</h2><p>为已经存在的对象添加额外的功能</p><ul><li>执行函数后的清除功能</li><li>执行函数前的预备功能</li><li>引入日志（我理解的是：函数功能运行前日志记录）</li></ul><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;he&#x27;</span>]</span><br><span class="line">list2 = <span class="built_in">list</span>.copy()</span><br><span class="line"></span><br><span class="line">对于可变对象：</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">list2也会改变</span><br><span class="line"></span><br><span class="line">对于不可变对象：</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>] = <span class="string">&#x27;be&#x27;</span></span><br><span class="line">list2 不会改变</span><br><span class="line"></span><br><span class="line">可变对象：<span class="built_in">list</span> dic <span class="built_in">set</span> 不可变对象：number string <span class="built_in">tuple</span></span><br></pre></td></tr></table></figure><p>深拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [[<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;he&#x27;</span>]</span><br><span class="line">list2 = <span class="built_in">list</span>.deepcopy()</span><br><span class="line"></span><br><span class="line">无论<span class="built_in">list</span>如何变化 list2不变</span><br></pre></td></tr></table></figure><h2 id="python-实现多线程"><a href="#python-实现多线程" class="headerlink" title="python 实现多线程"></a>python 实现多线程</h2><p>Python 有一个名为 Global Interpreter Lock（GIL）的结构。GIL 确保每次只能执行一个“线程”。一个线程获取 GIL 执行相关操作，然后将 GIL 传递到下一个线程。</p><p>虽然看起来程序被多线程并行执行，但它们实际上只是轮流使用相同的 CPU 核心。</p><p>所有这些 GIL 传递都增加了执行的开销。这意味着多线程并不能让程序运行的更快。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>简单点说协程是进程和线程的升级版，进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态。</p><h2 id="python-中的单下划线和双下划线"><a href="#python-中的单下划线和双下划线" class="headerlink" title="python 中的单下划线和双下划线"></a>python 中的单下划线和双下划线</h2><p>双下划线”<strong>变量或函数</strong>“，是 Python 内部为了防止和用户自定义命名冲突。</p><p>双下划线”<strong>变量或函数”，解析器用_classname</strong>foo 来代替这个名字，以区别和其他类相同的命名,它无法直接像公有成员一样随便访问，通过对象名._类名__xxx 这样的方式可以访问。</p><p>单下划线”_变量或函数”，是指定变量私有，不能通过 from module import *导入，其他地方和公有一样。</p><h2 id="python2-和-python3-的区别"><a href="#python2-和-python3-的区别" class="headerlink" title="python2 和 python3 的区别"></a>python2 和 python3 的区别</h2><ol><li><p>print 函数<br>python2 print 语句 python3 print 函数</p></li><li><p>unicode</p><p>Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。<br>现在， 在 Python 3，我们最终有了 Unicode (utf-8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python2:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&quot;我爱北京天安门&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span></span><br><span class="line"><span class="string">&#x27;\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8&#x27;</span></span><br><span class="line"></span><br><span class="line">python3:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">&quot;我爱北京天安门&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span></span><br><span class="line"><span class="string">&#x27;我爱北京天安门&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>除法运算<br>python2 除法整数返回整数 浮点数返回浮点数<br>python3 除法整数也返回浮点数</p></li><li><p>异常<br>捕获异常的语法由 except exc, var 改为 except exc as var。使用 except (exc1, exc2) as var 可以同时捕获多种类别的异常。</p></li><li><p>xrange</p><ul><li>range 和 xrange 都是在循环中使用，输出结果一样。</li><li>range 返回的是一个 list 对象，而 xrange 返回的是一个生成器对象(xrange object)。</li><li>xrange 则不会直接生成一个 list，而是每次调用返回其中的一个值，内存空间使用极少，因而性能非常好。</li></ul></li></ol><h2 id="python-tuple-和-list-和-set-的区别"><a href="#python-tuple-和-list-和-set-的区别" class="headerlink" title="python tuple 和 list 和 set 的区别"></a>python tuple 和 list 和 set 的区别</h2><p>tuple 是不可变数据类型。</p><p>tuple 不可以删除，修改元素</p><p>不可以添加，没有 append，insert 方法。</p><p>可以用+&#x3D;添加（相当于创建新对象，赋值）</p><p>set 是保证集合内没有重复元素，可以用 add 添加，是可变数据类型</p><h2 id="python-垃圾回收机制（GC-机制）内存管理"><a href="#python-垃圾回收机制（GC-机制）内存管理" class="headerlink" title="python 垃圾回收机制（GC 机制）内存管理"></a>python 垃圾回收机制（GC 机制）内存管理</h2><p><a href="https://blog.csdn.net/weixin_45620619/article/details/114304424">参考</a></p><p>访问变量可以通过<strong>直接引用</strong>和<strong>间接引用</strong>来使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">直接引用：</span><br><span class="line">x = <span class="number">10</span> <span class="comment"># 使用x就可以得到值</span></span><br><span class="line">间接引用：</span><br><span class="line">l = [x, <span class="number">2</span>] 通过访问l[<span class="number">0</span>]也可以间接访问到值</span><br></pre></td></tr></table></figure><p>垃圾回收机制（简称 GC）是 python 解释器自带的一种机制，专门用来回收没有绑定任何引用（直接引用和间接引用）的变量值所在的内存空间</p><p>引用计数-存在栈中变量回收后，堆中的️值依旧存在，且无法通过变量名访问它的问题</p><p>解决方法：<br><strong>标记-清除</strong>：扫描栈，能通过栈中变量直接或者间接访问到的对象都标记为存活对象，清除非存活对象</p><p>改进：<br><strong>分代回收</strong>：分代指的是根据存活时间来划分不同等级（也就是不同的代）,假如分成了幼儿代，青春代，中年代，老年代五个代，一个变量一开始假如在幼儿代，一段时间内被扫描了三次，依然有绑定关系，此时就把这个变量移入更加高级的青春代，扫描的时候会优先扫描幼儿代，然后再扫描更高级的代</p><h2 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h2><p>GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。</p><p>在 IO 操作等可能会引起阻塞的 system call 之前,可以暂时释放 GIL,但在执行完毕后,必须重新获取 GIL</p><p>Python 3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python 2.x，tickets 计数达到 100</p><h2 id="init和new的区别"><a href="#init和new的区别" class="headerlink" title="init和new的区别"></a><strong>init</strong>和<strong>new</strong>的区别</h2><p><a href="https://blog.csdn.net/qq_23183809/article/details/120819491">参考</a></p><p><strong>init</strong>用于初始化类对象，而<strong>new</strong>的只想还在 init 前</p><p><strong>init</strong> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</p><p><strong>new</strong> 通常用于控制生成一个新实例的过程。它是类级别的方法</p><p>new 主要的作用是继承一些不可变的 class 时(比如 int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简述下-Python-中的字符串、列表、元组和字典&quot;&gt;&lt;a href=&quot;#简述下-Python-中的字符串、列表、元组和字典&quot; class=&quot;headerlink&quot; title=&quot;简述下 Python 中的字符串、列表、元组和字典&quot;&gt;&lt;/a&gt;简述下 Python </summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="语言学习" scheme="https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>System_Server进程注入开发</title>
    <link href="https://beichen.link/2023/08/15/Study/%E5%AE%9E%E4%B9%A0/System_Server%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%BC%80%E5%8F%91/"/>
    <id>https://beichen.link/2023/08/15/Study/%E5%AE%9E%E4%B9%A0/System_Server%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%BC%80%E5%8F%91/</id>
    <published>2023-08-15T00:00:00.000Z</published>
    <updated>2023-12-07T09:39:19.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>通过 ptrace 函数可以跟踪进程，修改被跟踪进程的内存和寄存器值</p><p>在注入之前,简单介绍一下需要用到的 ptrace 的部分功能</p><p>1.PTRACE_ATTACH</p><p>attach 到其他进程上,pid 为目标进程的 id <code>ptrace(PTRACE_ATTACH, pid, NULL, 0)</code></p><p>2.PTRACE_DETACH</p><p>脱离 attach 的进程,pid 为目标进程的 id <code>ptrace(PTRACE_DETACH, pid, NULL, 0)</code></p><p>3.PTRACE_POKETEXT</p><p>向对应进程写入数据,pid 为目标进程 id,dest 为地址,val 为写入的数据 <code>ptrace(PTRACE_POKETEXT, pid, dest, val)</code></p><p>4.PTRACE_PEEKTEXT</p><p>读取对应进程的数据,pid 为目标进程 id,dest 为地址 <code>ptrace(PTRACE_PEEKTEXT, pid, dest, 0)</code></p><p>5.PTRACE_SETREGS&#x2F;PTRACE_GETREGS</p><p>设置&#x2F;读取寄存器,pid 为目标进程地址 <code>ptrace(PTRACE_SETREGS, pid, NULL, regs)</code></p><p>6.PTRACE_CONT</p><p>继续执行,pid 为目标进程地址 <code>ptrace(PTRACE_CONT, pid, 0, signal)</code></p><h2 id="进程注入的实现"><a href="#进程注入的实现" class="headerlink" title="进程注入的实现"></a>进程注入的实现</h2><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230816132340.png" alt="20230816132340"></p><h3 id="Step-1-attach-到目标进程-：ptraceAttach-pid"><a href="#Step-1-attach-到目标进程-：ptraceAttach-pid" class="headerlink" title="Step 1 attach 到目标进程 ：ptraceAttach(pid);"></a>Step 1 attach 到目标进程 ：ptraceAttach(pid);</h3><p>这里其实不光要 attach 到目标进程,还得保存目前寄存器状态,为了一会儿恢复现场.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">currentRegs</span>, <span class="title">orgRegs</span>;</span></span><br><span class="line"><span class="comment">// 获取远程进程的寄存器值</span></span><br><span class="line"><span class="keyword">if</span> (ptraceGetregs(pid, &amp;currentRegs) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;get reg error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后将其保存到 orgRegs 中</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;orgRegs, &amp;currentRegs, <span class="keyword">sizeof</span>(currentRegs));</span><br></pre></td></tr></table></figure><h3 id="Step-2-在目标进程中调用-mmap-申请一段空间"><a href="#Step-2-在目标进程中调用-mmap-申请一段空间" class="headerlink" title="Step 2 在目标进程中调用 mmap 申请一段空间"></a>Step 2 在目标进程中调用 mmap 申请一段空间</h3><p>这里申请空间就是用来在后续调用 dlopen 和 dlsym 时写入参数用的,这一步执行完以后,就可以在进程中看到自己申请到的空间了</p><p>为了调用 mmap 函数，我们需要获取远程进程中的 mmap 函数地址，可通过计算系统库基地址-偏移得出</p><p>同一系统库 (例如 mmap 所在的系统库 libc.so) 的 mmap 地址与 libc.so 基地址的偏移量，在当前进程和远程进程 (被注入进程) 中是相同的</p><p>所以，只要获取到当前进程的 libc 基地址 (假设用变量 local_handle 表示)、当前进程 mmap 地址 (local_addr)、远程进程 libc.so 基地址 (remote_handle)，即可根据如下公式获取远程 mmap 地址 (remote_addr)：</p><p><code>remote_addr = local_addr + remote_handle - local_handle</code></p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230816142441.png" alt="20230816142441"></p><p>接下来首先获取 libc.so 基地址 (local_handle&#x2F;remote_handle) 和当前进程 mmap 函数地址 (local_addr)。</p><h4 id="获取-libc-so-基地址"><a href="#获取-libc-so-基地址" class="headerlink" title="获取 libc.so 基地址"></a>获取 libc.so 基地址</h4><p>获取进程中 libc.so 模块基地址 (local_handle&#x2F;remote_handle) 的方法为:</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230816142914.png" alt="20230816142914"></p><p>即在&#x2F;proc&#x2F;{pid}&#x2F;maps 路径中找到模块名，其中 pid 替换为目标进程的进程 id,对应的行首地址即为模块的基地址。如果在当前进程中读取当前进程的模块基地址，可读取&#x2F;proc&#x2F;self&#x2F;maps 路径下的模块地址即可。通过该方法可求得 local_handle&#x2F;remote_handle 的值。</p><h4 id="获取当前进程-mmap-函数地址"><a href="#获取当前进程-mmap-函数地址" class="headerlink" title="获取当前进程 mmap 函数地址"></a>获取当前进程 mmap 函数地址</h4><p>获取当前进程的 mmap 函数地址，有两种方法：</p><p>方法一：通过 dlopen&#x2F;dlsym 的方式获取，如下图：</p><p><img src="https://raw.githubusercontent.com/beichen100/image_host/master/img/20230816143218.png" alt="20230816143218"></p><p>方法二：根据 elf 文件内容格式获取符号相对基地址的偏移量，加上当前进程中 libc.so 基地址，即可求得当前进程函数地址。</p><h3 id="申请操作"><a href="#申请操作" class="headerlink" title="申请操作"></a>申请操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> parameters[<span class="number">6</span>];</span><br><span class="line">    parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 设置为NULL表示让系统自动选择分配内存的地址</span></span><br><span class="line">    parameters[<span class="number">1</span>] = <span class="number">0x1000</span>; <span class="comment">// 映射内存的大小</span></span><br><span class="line">    parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// 表示映射内存区域可读可写可执行</span></span><br><span class="line">    parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// 建立匿名映射</span></span><br><span class="line">    parameters[<span class="number">4</span>] = <span class="number">-1</span>; <span class="comment">//  若需要映射文件到内存中，则为文件的fd</span></span><br><span class="line">    parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//文件映射偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptraceCallWrapper(pid, <span class="string">&quot;mmap&quot;</span>, remoteMmapAddr, parameters, <span class="number">6</span>, &amp;currentRegs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call target mmap error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint8_t</span> *mmapBase = (<span class="type">uint8_t</span> *) ptraceRetval(&amp;currentRegs);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mmap ret is %x\n&quot;</span>, mmapBase);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ptraceCallWrapper 实际上执行了 ptrace_call 函数，ptrace_call 首先会将调用的函数 (mmap) 所需的参数 (parameters) 从右到左压入堆栈，同时写入返回地址到对应寄存器中，并同步修改栈顶指针。将堆栈和寄存器值都设置完毕后，通过调用 ptrace 函数，并传入参数 PTRACE_CONT 使 mmap 函数得以执行</p><h3 id="Step-3-将注入的-so-路径写入目标进程地址中"><a href="#Step-3-将注入的-so-路径写入目标进程地址中" class="headerlink" title="Step 3 将注入的 so 路径写入目标进程地址中"></a>Step 3 将注入的 so 路径写入目标进程地址中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace_write_data(pid, mmapBase, hookSoPath, <span class="built_in">strlen</span>(hookSoPath) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="Step-4-调用-dlopen-加载-hooker-so"><a href="#Step-4-调用-dlopen-加载-hooker-so" class="headerlink" title="Step 4 调用 dlopen,加载 hooker.so"></a>Step 4 调用 dlopen,加载 hooker.so</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parameters[<span class="number">0</span>] = (<span class="type">long</span>) mmapBase;</span><br><span class="line">parameters[<span class="number">1</span>] = RTLD_NOW | RTLD_GLOBAL;</span><br><span class="line"><span class="comment">//通过ptrace调用</span></span><br><span class="line"><span class="keyword">if</span> (ptraceCallWrapper(pid, <span class="string">&quot;dlopen&quot;</span>, remoteDlopen, parameters, <span class="number">2</span>, &amp;currentRegs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call target dlopen error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就将 hooker.so 加载上去了,执行 cat proc&#x2F;pid&#x2F;map 就能看到</p><h3 id="Step-5-调用-dlsym-获取-hooker-so-中的-hookentry-符号"><a href="#Step-5-调用-dlsym-获取-hooker-so-中的-hookentry-符号" class="headerlink" title="Step 5 调用 dlsym,获取 hooker.so 中的 hookentry 符号"></a>Step 5 调用 dlsym,获取 hooker.so 中的 hookentry 符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *targetFuncName = <span class="string">&quot;hookEntry&quot;</span>;</span><br><span class="line">   ptraceWriteData(pid, mmapBase + FUNCTION_NAME_ADDR_OFFSET, targetFuncName, <span class="built_in">strlen</span>(targetFuncName) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   parameters[<span class="number">0</span>] = (<span class="type">long</span>) targetSoHandle;</span><br><span class="line">   parameters[<span class="number">1</span>] = (<span class="type">long</span>) (mmapBase + FUNCTION_NAME_ADDR_OFFSET);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (ptraceCallWrapper(pid, <span class="string">&quot;dlsym&quot;</span>, targetDlsymAddr, parameters, <span class="number">2</span>, &amp;currentRegs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;call target dlsym error\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> *hookFuncAddr = (<span class="type">void</span> *) (ptraceRetval(&amp;currentRegs));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;hook func addr is %x\n&quot;</span>, ptraceRetval(&amp;currentRegs));</span><br></pre></td></tr></table></figure><h3 id="Step-6-调用-hookentry"><a href="#Step-6-调用-hookentry" class="headerlink" title="Step 6 调用 hookentry"></a>Step 6 调用 hookentry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptraceCallWrapper(pid, targetFuncName, hookFuncAddr, parameters, <span class="number">0</span>, &amp;currentRegs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call target %s error&quot;</span>, targetFuncName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ptrace&quot;&gt;&lt;a href=&quot;#ptrace&quot; class=&quot;headerlink&quot; title=&quot;ptrace&quot;&gt;&lt;/a&gt;ptrace&lt;/h2&gt;&lt;p&gt;通过 ptrace 函数可以跟踪进程，修改被跟踪进程的内存和寄存器值&lt;/p&gt;
&lt;p&gt;在注入之前,简单介绍一下</summary>
      
    
    
    
    <category term="Study" scheme="https://beichen.link/categories/Study/"/>
    
    
    <category term="实习" scheme="https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
</feed>
