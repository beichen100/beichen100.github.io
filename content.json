{"meta":{"title":"beichen","subtitle":null,"description":"","author":"John Doe","url":"https://beichen.link","root":"/"},"pages":[],"posts":[{"title":"","slug":"Study/计算机基础/安全加密","date":"2023-12-07T09:39:19.747Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/12/07/Study/计算机基础/安全加密/","link":"","permalink":"https://beichen.link/2023/12/07/Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"Study/算法/排序算法","date":"2023-12-07T09:39:19.747Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/12/07/Study/算法/排序算法/","link":"","permalink":"https://beichen.link/2023/12/07/Study/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"IDA脚本找jni_load","slug":"Study/逆向知识/IDA脚本找jni_load","date":"2023-10-19T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/19/Study/逆向知识/IDA脚本找jni_load/","link":"","permalink":"https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/IDA%E8%84%9A%E6%9C%AC%E6%89%BEjni_load/","excerpt":"","text":"idaPython 脚本 : 支持 libart.so 32&#x2F;64 位下断点。 手动分析过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import idcimport idautilsimport ida_bytesimport ida_funcs# time: 2023/1/31# author: iyue# 基于aosp10 - 12 源码符号都一样 其他可以自己找一下def helloIdaPython(): print(&quot;---------------- start --------------------&quot;)def findModules(name): &quot;&quot;&quot; 获取指定模块 &quot;&quot;&quot; # module = idc.get_first_module() # print(&quot;get first module : &#123;&#125;&quot;.format(module)) # while (module!=None): # moduleName = idc.get_module_name(module) # print(&quot;find module name:&#123;&#125;&quot;.format(moduleName)) # if name in moduleName: # return module # module = idc.get_next_module(module) # return None modules = idc.get_event_module_base() for module in modules: print(module)def setJniOnloadBt(): # 1. 获取数据段起始和结束位置 rodata_ea_start = 0 rodata_ea_end = 0 local_sections = idautils.Segments() for section in local_sections: seg_name = idc.get_segm_name(section) # print(seg_name) if seg_name == &#x27;.rodata&#x27;: rodata_ea_start = section rodata_ea_end = idc.get_segm_end(rodata_ea_start) # print(&quot;\\t[iyue] find .rodata segment:0x%X&quot;%(rodata_ea_start)) print(&quot;\\t[iyue] find .rodata segment:0x%X - 0x%X&quot;%(rodata_ea_start,rodata_ea_end)) break if rodata_ea_start == 0: print (&quot;\\t[iyue] can not locate .rodata segment&quot;) return False # 2. 在rodata段中搜索字符串 jniOnloadStrAddr = 0 eaOffset = rodata_ea_start # for debug # file = open(r&quot;C:\\Users\\l\\Tools\\SCRIPT\\test.log&quot;,&#x27;w&#x27;) print (&quot;\\t[iyue] start find: [Calling JNI_OnLoad in \\&quot; &quot;) while eaOffset&lt;rodata_ea_end: currentString = idc.get_strlit_contents(eaOffset) if currentString == None: eaOffset+=1 continue sstr = bytes(currentString).decode(&#x27;utf-8&#x27;) if &quot;[Calling JNI_OnLoad in \\&quot;&quot; == sstr: print(&quot;\\t[iyue] found strlit: %s addr:0x%X&quot;%(sstr,eaOffset)) jniOnloadStrAddr = eaOffset break # file.write(sstr+&#x27;\\n&#x27;) eaOffset+=len(sstr) # file.flush() # file.close() if jniOnloadStrAddr == 0: print(&quot;\\t[iyue] not found strlit: %s&quot;%(&quot;[Calling JNI_OnLoad in \\&quot;&quot;)) return False # 3. 获取jni关键字符串的引用地址 xrefAddr=0 allXref = idautils.XrefsTo(jniOnloadStrAddr) # 通过分析源码可知 前两个挨着的 第三个属于 for xref in allXref: print(xref.type, idautils.XrefTypeName(xref.type),&#x27;from&#x27;, hex(xref.frm), &#x27;to&#x27;, hex(xref.to)) print(&#x27;\\t[iyue] first ref in:0x%X&#x27;%xref.frm) xrefAddr = xref.frm break if xrefAddr == 0: print(&quot;\\t[iyue] not found %s Reference!&quot;%(&quot;[Calling JNI_OnLoad in \\&quot;&quot;)) return False # 4. 找到跳转后的地址,其实就是找b跳转，E4B7，loc_2a1a4a以_分割，goNextAddr找2a1a4a地址 # int version = (*jni_on_load)(this, nullptr); 可以看到函数地址是一个变量 funcItems = idautils.FuncItems(xrefAddr) #获取xref引用地址所在函数的所有地址 goNextAddr=0 for itermAddr in funcItems: if itermAddr &gt;= xrefAddr: # 跳转指令opcode 2 个字节 # print(itermAddr) opcode = ida_bytes.get_word(itermAddr) # print(opcode) if 0xE4B7 == opcode: print(&quot;\\t[iyue] &quot;,hex(opcode),idc.GetDisasm(itermAddr)) gotoAddr = idc.GetDisasm(itermAddr).split(&#x27;_&#x27;)[1] goNextAddr= hex(int(&#x27;0x&#x27;+gotoAddr,16)) print(&quot;\\t[iyue] find go next addr:&quot;,goNextAddr) break # 兼容64位libart.so # print(opcode64) opcode64 = ida_bytes.get_32bit(itermAddr) if 0x17fffe17 == opcode64: print(&quot;\\t[iyue] &quot;,hex(opcode64),idc.GetDisasm(itermAddr)) gotoAddr = idc.GetDisasm(itermAddr).split(&#x27;_&#x27;)[1] goNextAddr= hex(int(&#x27;0x&#x27;+gotoAddr,16)) print(&quot;\\t[iyue] find go next addr:&quot;,goNextAddr) break if goNextAddr==0: print(&quot;\\t[iyue] no found go next addr !&quot;) return False # 5. 获取函数起始和结束位置，就是获取loc_2a1a4a的起止，因为后面会遍历每个地址 goNextAddr = int(goNextAddr,16) tmpFuncName = idc.get_func_name(goNextAddr) if &#x27;LoadNativeLibrary&#x27; in tmpFuncName: LoadNativeLibraryFuncStart = idc.get_func_attr(goNextAddr,idc.FUNCATTR_START) LoadNativeLibraryFuncEnd = idc.get_func_attr(goNextAddr,idc.FUNCATTR_END) # 6.找到jni_onload 调用位置，就是找同时带BLX和r4的 callJniOnloadAddr=0 while goNextAddr &lt; LoadNativeLibraryFuncEnd: ssstr = idc.GetDisasm(goNextAddr) print(&#x27;\\t[iyue] 0x%X %s&#x27;%(goNextAddr,ssstr)) #print(&quot;&#x27;%s&#x27;&quot;%ssstr) if &#x27;BLX&#x27; in ssstr and &#x27;R&#x27; in ssstr or &#x27;BLR&#x27; in ssstr and &#x27;X&#x27; in ssstr: callJniOnloadAddr = goNextAddr print(&quot;\\t[iyue] find call jni_onload addr:&quot;,goNextAddr) break goNextAddr+=1 if callJniOnloadAddr == 0: print(&quot;\\t[iyue] no found call jni_onload fial !&quot;) return False # 7. 在调用位置下断点 idc.add_bpt(callJniOnloadAddr) print(&#x27;\\t[iyue] add bpt in:%s&#x27;%ssstr) return Truedef main(): print(&quot;---------------- start --------------------&quot;) # findModules(&#x27;libart.so&#x27;) setJniOnloadBt() print(&quot;---------------- end --------------------&quot;) passif __name__ == &quot;__main__&quot;: main()","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"SVC","slug":"Study/逆向知识/SVC","date":"2023-10-19T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/19/Study/逆向知识/SVC/","link":"","permalink":"https://beichen.link/2023/10/19/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/SVC/","excerpt":"","text":"什么是 SVC 指令？什么是 Syscall？在 Linux 里面内存主要分为 Linux 用户态，内核态。 用户自定义运行的函数在用户态。内核态是当 Linux 需要处理文件，或者进行中断 IO 等操作的时候就会进入内核态。 syscall 就是这个内核态的入口。(（systcall 是 Linux 内核的入口，切换到内核态以后，无法被 Hook）) 而 syscall 函数里面的实现就是一段汇编，汇编里面便是调用了 svc 指令。 当 arm 系列 cpu 发现 svc 指令的时候，就会陷入中断，简称 0x80 中断。开始执行内核态逻辑，这个时候程序会进入暂停状态, 优先去执行内核的逻辑。以此保证程序的安全性。 Linux 内核本身提供很多函数，比如常见的文件函数,openat，execve 都是 Linux 内核提供的。这些函数都可以通过 svc 指令的方式去调用，只是实现的 sysnum 不一样。传入的参数不一样而已。 但是通过 svc 执行的函数无法进行 inlinehook Hook ，所以会提升程序的安全度。 总结：svc 是一条 arm 指令，Syscall 函数是 libc 函数，实现底层使用了 svc 指令。 syscall 32&amp;64 位具体实现如下。 32 位： 1234567891011raw_syscall: MOV R12, SP STMFD SP!, &#123;R4-R7&#125; MOV R7, R0 MOV R0, R1 MOV R1, R2 MOV R2, R3 LDMIA R12, &#123;R3-R6&#125; SVC 0 LDMFD SP!, &#123;R4-R7&#125; mov pc, lr 64 位： 12345678910raw_syscall: MOV X8, X0 MOV X0, X1 MOV X1, X2 MOV X2, X3 MOV X3, X4 MOV X4, X5 MOV X5, X6 SVC 0 RET cmake 里添加 1enable_language(C ASM) 编译即可 比如获取网卡设备信息 12LOG(ERROR) &lt;&lt; &quot;读取文件内容 &quot; &lt;&lt; FileUtils::getFileText(&quot;/sys/class/net/p2p0/address&quot;,20); 对抗可以通过 Ptrace 进行 svc 拦截，在使用前需要将 Ptrace 方法堵住 （因为 Ptrace 作为 Linux 的调试函数，是可以调试 svc 指令的，很多游戏辅助也都是这么搞得）方法也很多，可以像一般壳子的方式提前占坑，或者读取调试状态，去判断是否被调试 都是不错的办法。 Seccomp(Secure Computing Mode) 是 Linux 的一种安全机制，android 8.1 以上使用了 Seccomp，主要通过限制进程的系统调用来完成部分沙箱隔离功能。seccomp-bpf 是 seccomp 的一个扩展，它可以通过配置来允许应用程序调用其他的系统调用。 主要功能是限制直接通过 syscall 去调用某些系统函数，当开启了 Seccomp 的进程在此调用的时候会变走异常的回调。 Seccomp 的过滤模式有两种(strict&amp;filter)， strict strict 模式如果开启以后，只支持四个函数的系统调用(read,write,exit,rt_sigreturn)。如果一旦使用了其他的 syscall 则会收到 SIGKILL 信号 filter（BPF） 全程 Seccomp-bpf，BPF 是一种过滤模式，只有在 Linux 高版本会存在该功能，当某进程调用了 svc 以后，如果发现当前 sysnum 是我们进行过滤的 sysnum，首先会进入我们自己写的 BPF 规则。 通过我们自己的写的规则，进行判断该系统调用是否被运行调用，应该怎么进行处理. 当返回规则设置为「SECCOMP_RET_TRAP」，目标系统调用时 seccomp 会产生一个 SIGSYS 系统信号并软中断，这时就可以通过捕获这个 SIGSYS 信号获得 svc 调用和打印具体参数。 seccomp 发出 SECCOMP_RET_TRAP 信号时，会引发程序阻塞机制，此时系统会产生一个 SIGSYS 信号，并使原程序处于临时阻塞状态。因此我们可以使用 sigaction 来注册一个对 SIGSYS 信号进行处理的 handler，再将处理完的结果返回出去，从而达到 hook 效果。 常用的指令如下 123456BPF_LD, BPF_LDX加载指令BPF_ST, BPF_STX存储指令BPF_ALU, 计算指令BPF_JMP, 跳转指令BPF_RET, 返回指令 （结束指令）BPF_MISC 其他指令 指令之间可以相加或者相减，来完成一条 JUMP 操作 对 Seccomp-BPF 技术的防护Seccomp-BPF 提供了一个钩子函数，在 SVC 系统调用执行之前会进入到这个函数，对系统调用进行检查，并做业务逻辑的修改和绕过。故任何 SVC 调用，都无法逃离 Seccomp-BPF 的魔掌。 那么，Seccomp-BPF 在 Android 应用攻击中是怎么做的呢？举例如下。 有的 APP 为了保障自身的安全，不允许 APP 动态调试、二次签名、运行在框架环境等。采用的方案一般使用 open 系统调用的方式打开特定文件检查有无异常特征，例如&#x2F;proc&#x2F;self&#x2F;map 或者&#x2F;proc&#x2F;self&#x2F;status 等。有些开发者比较注重安全，对 open 采用了 svc 的实现方式。但是利用 Seccomp-BPF 完全可以对 open 操作进行拦截，重定位参数路径，完成逻辑的绕过。 1. 基于 prctl 调用的检测prctl 方法也是一个系统调用。使用 Seccomp-BPF 前，会调用 prctl，并传入特定参数作为前置条件。 为了检测这种方式。我们同样可以调用 prctl，传入 PR_GET_NO_NEW_PRIVS。根据返回值来判断是否 NO_NEW_PRIVS 被设置为 1。 12if(prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) == 1) &#123; do something… &#125; 但是该方案有个缺陷，因为 prctl 本身是个系统调用。所以仍然可以被 Seccomp-BPF 拦截修改进而绕过。 2. 基于 Signal 的捕获检测将 SECCOMP_RET_TRAP 传入 BPF 指令中，当执行该指令时，将会产生 SIGSYS 信号。我们可以提前通过 sigaction 方法来注册 SIGSYS 信号，当捕获到信号时，会执行对应的 handler 方法。在正常情况下，都是可以正常接收到信号，并执行 handler 方法。但是如果该进程已经提前使用了 Seccomp-BPF，将会无法正常接收到信号，handler 方法也不会执行。所以可以通过这种逻辑来判断该应用是否处在 Seccomp-BPF 环境中。 不过该方法依然有被绕过的可能性，攻击者可以通过 Hook 的方式，拿到 handler 方法地址并主动去执行。则可以绕过校验。 3. 基于 status 文件的检测方案当调用代码时，会在对应进程的 status 文件中留下痕迹。如图所示，NoNewPrivs 对应的值变为 1。 我们可以使用 open 打开&#x2F;proc&#x2F;self&#x2F;status 文件，检测该值是否为 1。当然，open 系统调用，我们之前说过了，可以被绕过。但这并不意味着防御到此结束，我们依然可以通过 open 返回的句柄值，来进一步验证句柄的合法性。 额外1. 批量检测 android app 的 so 中是否有 svc 调用原理很容易理解，对于 armv7 svc 0 对应的 00DF 二进制 调用号是在 r7 寄存器中armv8 svc 0 对应的 010000D4 二进制 调用号是在 x8 寄存器中，只要在 so 文件中的.text 段中找到相关的二进制字串就可以确定是否有 svc 调用，再向前看就可以看出 svc 的调用号是多少。不同人不同写法，会导致分析调用号多少不一样 参考：https://bbs.kanxue.com/thread-269895.htm arm32 关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546textStart = 0 textEnd = 0 FindtextEnd =False #读取elf文件信息，计算代码的地址与终止段 ,取section.name==&#x27;.text&#x27;后，马上取下一个就是textEnd # with open(file_path,&#x27;rb&#x27;) as f: e=ELFFile(f) for section in e.iter_sections(): #打印Elf各段地址 #print(section[&#x27;sh_addr&#x27;],hex(section[&#x27;sh_addr&#x27;]),section.name) if FindtextEnd is True: textEnd = section[&#x27;sh_addr&#x27;] break if(section.name==&#x27;.text&#x27;): textStart=section[&#x27;sh_addr&#x27;] FindtextEnd=True # 微信应用是这个svc 0 =&gt;00DF sub = &quot;00DF&quot; addr = [substr.start() for substr in re.finditer(sub, file_str)] total_svc=0 for i in addr: if( i &gt;= textStart and i&lt; textEnd): #之前有问题是因为地址没对齐，比如 E0 0E F1 转成字串时 E00EF1 # 也包含了00EF,这就要用地址必须为偶数 # 4FF0140700DF m=int(i/2)-6 if(i % 4==0): fun_id = int(&quot;0x&quot;+file_str[i - 4:i - 2],16) fun_id_check = int(&quot;0x&quot; + file_str[i - 2:i ], 16) if(fun_id_check ==0x7): total_svc = total_svc + 1 if (fun_id in sysCallTab): print(file_str[i - 8:i + 4], hex(fun_id), &quot;addr : 0x%.8x Func Name : %s &quot; % (m, sysCallTab[fun_id])) else: print(file_str[i - 8:i + 4], hex(fun_id), &quot;addr : 0x%.8x Func Name : need check again********* &quot; % (m)) #print(os.path.basename(file_path), &quot;totoal find svc call &quot;, total_svc) if (total_svc &gt; 0): print(os.path.basename(file_path), &quot;elf infor &quot;) print(os.path.basename(file_path), &quot;.text start &quot;, hex(textStart), &quot;.text end &quot;, hex(textEnd)) print(os.path.basename(file_path), &quot;find svc call &quot;, total_svc) print(&quot;——————————————————————————————\\n&quot;)","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"hook对抗方法","slug":"Study/逆向知识/hook对抗方案","date":"2023-10-18T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/18/Study/逆向知识/hook对抗方案/","link":"","permalink":"https://beichen.link/2023/10/18/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/hook%E5%AF%B9%E6%8A%97%E6%96%B9%E6%A1%88/","excerpt":"","text":"hook 指令回写现在很多 native hook 思路都是 inlinehook ，Got 表 ,异常 hook（异常信号劫持 hook）。 这些思路都是很好的思路，各有各的好处，但是都是有特征，比如 inlinehook crc 检测很容易就检测出来，并且 有很多大厂会用 shellcode 进行绕过，我们能去修改这段指令跳转到这个某个函数，他当然也可以修改回来。 他只需要把某个方法的指令换成原始的指令，这样就可以防止被 inlinehook Hook（他需要获取原始指令，可以解析本地的 So 文件，解析 text 段，得到最真实的指令信息，保存，然后在函数执行之前在 set 回内存,都是很好的办法,还有的干脆直接服务端配置一个服务，直接服务端拉取某个函数的正确指令，都是很好的思路） 当然对抗这也不是没办法，我只需要在 hook 完毕以后再把内存设置成可读，不可写, 然后 Hook mprotect(mprotect 通过内存属性控制内存的访问权限) ，不让他调用 mprotect 这样就可以被 shellcode 绕过。 内存检测Hook 检测，我们其实只需要检测内存没有被修改即可。 正常我们知道一个 SO 加载到内存里，本质上是通过 mmap 把 so 分配到内存里面 ，比如 A 函数的指令是 BBB，那么加载到内存里面应该也是 BBB 。 记住上面这句话 ，我们就可以对内存里面的指令转换成一个 int 值，然后累加 。如果内存没有被修改 ，累加值文件里面和内存里面的值应该是一样的 。 以检测 libc 为例子，首先获取本地 So 文件的累加值，然后和本地的指令去计算 。计算本地的指令方法就是对 maps 进行遍历，只遍历 text 和 plt 段 ，计算累加值和本地进行判断。 当然这块就一定是比较完善的检测方案了么？其实有很多对抗思路 。比如把 maps 里面的内存进行隐藏，变成匿名内存，这样他在扫描 maps 的就找不到 当然这种方式一定是安全的么？ 其实，不是的，因为在他的这个代码里面我发现存在一个遗漏点，可以作为检测入手点 ，某个加固厂商，不仅仅会对 maps item 进行遍历 ，还会对里面的匿名内存进行遍历 ，检测匿名内存里面的 magic ，比如 so 文件的 magic 是 elf ，如果 magic 匹配上一样当 maps 去解析 去遍历。 所以可以在原有的基础上改改，在将内存变成匿名内存以后，把 elf 的前四个字节抹掉，也就是 magic 的 内容，抹掉以后记得把权限修改成和之前的一样 。防止内存检测。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"签名对抗","slug":"Study/逆向知识/签名对抗","date":"2023-10-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/10/Study/逆向知识/签名对抗/","link":"","permalink":"https://beichen.link/2023/10/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%8A%97/","excerpt":"","text":"提到环境检测不得不说的就是 Apk 重打包检测 ，现在检测方法千奇百怪，我这边也是一一罗列一下，把一些可能存在的风险点，检测和绕过的原理详细叙述一下 。 Native 层获取签名方法核心就三部分 svc openat 读 apk，去解析签名 。 检测打开的 fd，对 fd 的路径进行反查，这块有个细节 buff[len] &#x3D; ‘\\0’; 就是加这个，如果攻击者没修改 readlinkat 的返回值，就可以检测出来 。 检测完毕路径以后对这个文件的权限进行反查，正常 apk 是在系统下的，权限 GID 和 UID 应该是 1000 ，如果攻击者忘记修改权限也可以检测出来 。 针对上面的检测对抗也很简单，对 svc 的 openat 拦截了以后，对 readlinkat 和 stat 函数进行处理即可 。很轻松即可绕过检测 。很多加壳基本都是检测 ROOT 检测 LSP 调用栈之类的 ，并不只是单一的去检测签名一个纬度 。比如发现了开启了 seccomp 就会闪退，发现 Root 就会闪退 。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Fart脱壳机原理","slug":"Study/逆向知识/Fart脱壳机原理","date":"2023-10-09T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/09/Study/逆向知识/Fart脱壳机原理/","link":"","permalink":"https://beichen.link/2023/10/09/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Fart%E8%84%B1%E5%A3%B3%E6%9C%BA%E5%8E%9F%E7%90%86/","excerpt":"","text":"现有脱壳技术当前 ART 环境下的脱壳技术还有基于 dex2oat 编译生成 oat 过程的内存中的 dex 的 dump 技术，该方法依然是整体型 dump，无法应对指令抽取型加固,同时，当前一些壳对于动态加载 dex 的流程进行了 hook，这些 dex 也不会走 dex2oat 流程； 以及基于 dex 加载过程中内存中的 DexFile 结构体的 dump 技术。例如，在 ART 下通过 hook OpenMem 函数来实现在壳进行加载 DexFile 时对内存中的 dex 的 dump 的脱壳技术，以及在 2017 年的 DEF CON 25 黑客大会中，Avi Bashan 和 SlavaMakkaveev 提出的通过修改 DexFile 的构造函数 DexFile::DexFile()，以及 OpenAndReadMagic()函数来实现对加壳应用的内存中的 dex 的 dump 来脱壳技术。上面这些脱壳技术均无法实现对指令抽取型壳的完全脱壳。 FART 脱壳原理以及实现FART 脱壳的步骤主要分为三步： 1.内存中 DexFile 结构体完整 dex 的 dump 2.主动调用类中的每一个方法，并实现对应 CodeItem 的 dump 3.通过主动调用 dump 下来的方法的 CodeItem 进行 dex 中被抽取的方法的修复 1 内存中 DexFile 结构体完整 dex 的 dump该步同 Avi Bashan 和 SlavaMakkaveev 在 DefCon 2017 上提出的通过修改 DexFile 的构造函数 DexFile::DexFile()，以及 OpenAndReadMagic()函数来实现对加壳应用的内存中的 dex 的 dump 来脱壳的原理类似。 不同之处在于 Avi Bashan 和 SlavaMakkaveev 是通过修改系统中 DexFile 中提供的相关函数来实现 dump，实际上壳完全可以自实现一套 Dex 文件的内存加载机制从而绕过这种 dump 方法。 本文提出的是通过选择合适的时机点获取到应用解密后的 dex 文件最终依附的 Classloader，进而通过 java 的反射机制最终获取到对应的 DexFile 的结构体，并完成 dex 的 dump。接下来主要介绍具体实现细节。 首先，对于获取 Classloader 的时机点的选择，APP 中的 Application 类中的 attachBaseContext 和 onCreate 函数是 app 中最先执行的方法。壳都是通过替换 APP 的 Application 类并自己实现这两个函数，并在这两个函数中实现 dex 的解密加载，hook 系统中 Class 和 method 加载执行流程中的关键函数，最后通过反射完成关键变量如最终的 Classloader，Application 等的替换从而完成执行权的交付。所有的应用中加载的 dex 文件最终都在应用的 Classloader 中。所以我们只要取到加壳的应用最后修复完，正常加载时的 Classloader 就脱壳成功了。这种脱壳方式就是所谓的整体 dump。 因此，我们可以选在任意一个在 Application 的 onCreate 函数执行之后才开始被调用的任意一个函数中。众所周知，对于一个正常的应用来说，最终都要由一个个的 Activity 来展示应用的界面并和用户完成交互，那么我们就可以选择在 ActivityThread 中的 performLaunchActivity 函数作为时机，来获取最终的应用的 Classloader。选择该函数还有一个好处在于该函数和应用的最终的 application 同在 ActivityThread 类中，可以很方便获取到该类的成员。 performLaunchActivity 调用 getDexFilesByClassLoader 函数通过一系列的反射，最终获取到当前 Classloader 中的 mCookie，即 Native 层中的 DexFile，然后完成 dex 的 dump 上面实现了对 Classloader 中加载的 dex 的 dump，那么如何实现对类中函数的主动调用来实现函数粒度的脱壳呢？下面开始介绍主动调用的设计 2 类函数的主动调用设计实现后来的第二代壳所谓的函数抽取，就是为了防止修复后的 dex 被直接整体 dump 给脱下来，然后将类和函数的关键流程在调用时，才进行解密修复。而 fart 的主动调用所有函数，就会触发解密修复，然后再进行 dump，从而实现函数抽取壳的脱壳。 获取 classloader 之后，反射获取 mCookie 字段（mCookie 装载的，是 art 中的 DexFile 的对象的内存地址），最后遍历所有类，调用每个类中的所有函数 对类函数的主动调用链的构造我们或许可以从 JNI 提供的相关函数的源码可以得出参考。JNI 提供了一系列 java 层函数与 Native 层函数交互的接口。当需要在 Native 层中的 c&#x2F;c++函数中调用位于 java 层的函数时，需要先获取到该函数的 jmethodid 然后再通过诸如 jni 中提供的 call 开头的一系列函数来完成对 java 层中函数的调用，最终通过调用 ArtMethod 类中的 Invoke 函数完成对 java 层中的函数的调用。 由此，我们可以看到 ArtMethod 类中的 Invoke 方法在 jni 中扮演着至关重要的地位。于是，我们可以构造出自己的 invoke 函数，在该函数中再调用 ArtMethod 的 Invoke 方法从而完成主动调用，并在 ArtMethod 的 Invoke 函数中首先进行判断，当发现是我们自己的主动调用时就进行方法体的 dump 并直接返回，从而完成对壳的欺骗，达到方法体的 dump。 可以看到代码非常简洁，首先是对 Java 层传来的 Method 结构体进行了类型转换，转成 Native 层的 ArtMethod 对象，接下来就是调用 ArtMethod 类中 myfartInvoke 实现虚拟调用，并完成方法体的 dump。 这里代码依然很简洁，只是对 ArtMethod 类中的 Invoke 的一个调用包装，不同的是在参数方面，我们直接给 Thread*传递了一个 nullptr，作为对主动调用的标识。 该函数只是在最开头添加了对 Thread*参数的判断，当发现该参数为 nullptr 时，即表示是我们自己构造的主动调用链到达，则此时调用 dumpArtMethod()函数完成对该 ArtMethod 的 CodeItem 的 dump。到这里，我们就完成了内存中 DexFile 结构体中的 dex 的整体 dump 以及主动调用完成对每一个类中的函数体的 dump，下面就是修复被抽取的函数部分。 3 抽取类函数的修复壳在完成对内存中加载的 dex 的解密后，该 dex 的索引区即 stringid，typeid,methodid,classdef 和对应的 data 区中的 string 列表并未加密。而对于 classdef 中类函数的 CodeItem 部分可能被加密存储或者直接指向内存中另一块区域。这里我们只需要使用 dump 下来的 method 的 CodeItem 来解析对应的被抽取的方法即可 fart 对抗一句话概括： 在 DEX 中插入无用类，检测到无用类的加载后随机 kill 自己 在 DEX 中插入无用类，记录这些类的 debug info offset 作为黑名单；正常运行时不会加载这些无用类（没有任何引用），而当 FART 进行枚举方法主动调用时，会触发这些类的加载，从而导致计数器置 1。计数器递增到达上限后触发 kill self，App 表现为随机的 crash，从而中断枚举过程。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"国内风控的几大隐藏检测特征","slug":"Study/逆向知识/风控","date":"2023-10-08T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/10/08/Study/逆向知识/风控/","link":"","permalink":"https://beichen.link/2023/10/08/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E9%A3%8E%E6%8E%A7/","excerpt":"","text":"1. 检测锁屏密码 2. 通过 binder 检测是否真的有 SIM 卡 获取远程 binder 接口： 3. build.prop 修改时间 因为高版本 SELinux 限制了无法读取&#x2F;system&#x2F;build.prop，但是有很多模拟器或者比较弱的黑产还是采用修改 build.prop 重启的方式修改数据。 而且 SELinux 并未先对该文件的 stat&#x2F;statfs 访问，所以可以通过读取改文件的修改时间判断是否修改（正常通过编译出来的 build.prop 的修改时间要么是 1970 年 1 月要么是 2009 年 1 月 1 日） 4. 检测手机上的应用商店包名 5. 传感器主要入口： Sensor.getVendor() &#x2F;&#x2F;获取传感器厂商 Sensor.getMaximumRange() &#x2F;&#x2F;获取传感器最大范围 Sensor.getResolution() &#x2F;&#x2F;获取传感器精度 Sensor.getMinDelay() &#x2F;&#x2F;获取传感器最小延迟 原理： 通过传感器信息对设备进行分析，可以结合大数据对设备指纹进行检测，也可以通过数据库对每一样设备的传感器进行对比检测作弊。 应用厂商：某盟、某美、某多、某宝、某音 6. 文件系统stat -f / 执行结果： 原理：第一个是文件系统 ID，每个设备都是不一样的，但是无论清除数据还是刷机都不会变。第 2、3 个是 Blocks 和 Inodes 的数量，一般情况下很难改变。 应用厂商：某多、某美、某宝 7. 字体列表ls /system/fonts 原理：读取&#x2F;system&#x2F;fonts 可以获取到安卓的系统字体列表，可以通过 md5 或者 sha-1 进行标注，方便对系统 ROM 识别。因为一般情况下，同一个 ROM 字体数量、文件名都是基本相差无几 应用厂商：某美、某多、某音 8. OpenGL com.google.android.gles_jni.GLImpl String glGetString(int name); name 值： GLVendor 7936 GPU 厂商 GLRenderer 7937 GPU 名称 GLVersion 7938 GPU 驱动版本 原理：通过这些属性获取到 GPU 的相关信息（也可以通过 native 层获取，这里只演示 Java 层的），可以通过这些信息和机型数据对比即可得出是否有作弊。并且这些信息也可以用于设备指纹识别。 应用厂商：某盟、某美、某多等所有厂商 9. boot_id 和 uuid12cat /proc/sys/kernel/random/boot_idcat /proc/sys/kernel/random/uuid 这些 ID 由安卓系统在开机时生成，并且在开机状态下不会改变。风控厂商通过这些 ID 进行关联检测，并且可以联合其他信息推断是否为同一设备操作。 应用厂商：某盟、某美、某多等所有厂商","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Android进程启动流程","slug":"Study/Android知识/Android进程启动流程","date":"2023-09-29T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/09/29/Study/Android知识/Android进程启动流程/","link":"","permalink":"https://beichen.link/2023/09/29/Study/Android%E7%9F%A5%E8%AF%86/Android%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"准备知识本文要介绍的是进程的创建，先简单说说进程与线程的区别。 进程：每个 App 在启动前必须先创建一个进程，该进程是由 Zygote fork 出来的，进程具有独立的资源空间，用于承载 App 上运行的各种 Activity&#x2F;Service 等组件。进程对于上层应用来说是完全透明的，这也是 google 有意为之，让 App 程序都是运行在 Android Runtime。大多数情况一个 App 就运行在一个进程中，除非在 AndroidManifest.xml 中配置 Android:process 属性，或通过 native 代码 fork 进程。 线程：线程对应用开发者来说非常熟悉，比如每次 new Thread().start()都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从 Linux 角度来说进程与线程都是一个 task_struct 结构体，除了是否共享资源外，并没有其他本质的区别。 在接下来的文章，会涉及到 system_server 进程和 Zygote 进程，下面简要介绍这两个进程： system_server 进程：是用于管理整个 Java framework 层，包含 ActivityManager，PowerManager 等各种系统服务; Zygote 进程：是 Android 系统的首个 Java 进程，Zygote 是所有 Java 进程的父进程，包括 system_server 进程以及所有的 App 进程都是 Zygote 的子进程，注意这里说的是子进程，而非子线程 进程创建图先来看一张进程创建过程的简要图： 图解： App 发起进程：当从桌面启动应用，则发起进程便是 Launcher 所在进程；当从某 App 内启动远程进程，则发送进程便是该 App 所在进程。发起进程先通过 binder 发送消息给 system_server 进程； system_server 进程：调用 Process.start()方法，通过 socket 向 zygote 进程发送创建新进程的请求； zygote 进程：在执行 ZygoteInit.main()后便进入 runSelectLoop()循环体内，当有客户端连接时便会执行 ZygoteConnection.runOnce()方法，再经过层层调用后 fork 出新的应用进程； fork()采用 copy on write 技术，这是 linux 创建进程的标准方法，调用一次，返回两次，返回值有 3 种类型。 在父进程中，fork 返回新创建的子进程的 pid;在子进程中，fork 返回 0；当出现错误时，fork 返回负数。（当进程数超过上限或者系统内存不足时会出错） copy-on-write 原理：写时拷贝是指子进程与父进程的页表都所指向同一个块物理内存，fork 过程只拷贝父进程的页表，并标记这些页表是只读的。父子进程共用同一份物理内存，如果父子进程任一方想要修改这块物理内存，那么会触发缺页异常(page fault)，Linux 收到该中断便会创建新的物理内存，并将两个物理内存标记设置为可写状态，从而父子进程都有各自独立的物理内存。 Copy On Write 技术好处是什么？ COW 技术可减少分配和复制大量资源时带来的瞬间延时。 COW 技术可减少不必要的资源分配。比如 fork 进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。 Copy On Write 技术缺点是什么？如果在 fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断 page-fault)，这样就得不偿失。 fork()的主要工作是寻找空闲的进程号 pid，然后从父进程拷贝进程信息，例如数据段和代码段，fork()后子进程要执行的代码等。 Zygote 进程是所有 Android 进程的母体，包括 system_server 和各个 App 进程。zygote 利用 fork()方法生成新进程，对于新进程 A 复用 Zygote 进程本身的资源，再加上新进程 A 相关的资源，构成新的应用进程 A。 新进程：执行 handleChildProc 方法，最后调用 ActivityThread.main()方法。 参考：http://gityuan.com/2016/03/26/app-process-create/ ActivityThread 是应用进程的初始化类，它的 main()方法就是应用的入口方法，也就是说应用进程被创建后会调用 ActivityThread.main()方法 ActivityThread 也是我们常说的主线程，但是这种描述不太准确，ActivityThread 不是线程，只不过它是在运行在主线程（main）的 main()方法中创建的对象，自然它也是运行在主线程中。只能说 ActivityThread 是主线程的一部分，但不并能代表主线程。 在 ActivityThread 的 main 中： 创建一个调用一个 Looper.prepareMainLooper(),创建一个 Looper 对象，这就是我们 activity 的主线程。 创建 ActivityThread 对象，ActivityThread 就是一个普通的 java 类。 调用 thread.attach 方法。主要是为了和 ActivityManagerService 进行交互通信。在里面通过 ActivityManagerService 的代理对象 ActivityManagerNative.getDefault()获取代理对象和 ActivityManagerService 通信。代理对象通过传递 ApplicationThread 对象 mAppThread 进行通信。 ApplicationThread 继承自 ApplicationThreadNative（一个实现 binder 的子类）目的是和 ActivityManagerService（AMS）通信。所以 ApplicationThread 仅仅是和 AMS 通信的一个工具类。 主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的 bindapplication 的进程间调用时，调用函数 handlebindapplication 来处理该请求 在 handleBindApplication 函数中第一次进入了 app 的代码世界，该函数功能是启动一个 application，并把系统收集的 apk 组件等相关信息绑定到 application 里. Application 是维护应用全局状态的基类，Android 系统会在启动应用进程时创建一个 Application 对象（应用只有一个 Application 对象） Applicaiton 类的应用场景有： 初始化应用程序级别的资源，如全局对象、环境配置变量等 数据共享、数据缓存，如设置全局共享变量、方法等 获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死 监听应用程序配置信息的改变，如屏幕旋转等 监听应用程序内 所有 Activity 的生命周期 在创建完 application 对象后，接着调用了 application 的 attachBaseContext 方法，之后调用了 application 的 onCreate 函数。由此可以发现，app 的 Application 类中的 attachBaseContext 和 onCreate 这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换 app 入口 Application，并自实现这两个函数，在这两个函数中进行代码的脱壳以及执行权交付的原因。 在 Android 应用程序中，attachBaseContext() 方法是一个回调方法，它在 onCreate() 方法之前被调用，其作用是向应用程序的 Context 对象中添加或修改一些信息。通常，开发人员会在这个方法中执行一些初始化操作，如创建全局对象、设置默认语言等。 具体来说，attachBaseContext() 方法的主要作用有以下几个方面： 为应用程序的 Context 对象添加一些额外的功能和信息，如修改 Resources 对象以支持多语言、修改 DisplayMetrics 对象以适应不同的屏幕尺寸等。 初始化全局变量和对象，例如创建数据库、设置全局的异常处理器等。 配置应用程序的一些基本参数，例如设置应用程序的主题、字体大小、默认语言等。 需要注意的是，在 attachBaseContext() 方法中，必须调用父类的 attachBaseContext() 方法，以确保系统在应用程序启动时正确地初始化 Context 对象。例如，在 Activity 类的 attachBaseContext() 方法中，必须调用父类的方法 super.attachBaseContext()。 总之，attachBaseContext() 方法是 Android 应用程序中非常重要的一个回调方法，通过重写该方法，开发人员可以在应用程序启动时进行一些必要的初始化操作，以确保应用程序的正确运行。 简单第一代壳加固程序脱壳运行的话： 通过反射将 android.app.ActivityThread 中的 mClassLoader 置换为加载解密后的 APK 的 DexClassLoader，该 DexClassLoader 一方面加载了源程序，另一方面以原 mClassLoader 为父节点，这就保证了既加载了源程序又没有放弃原先加载的资源与系统代码。 找到源程序的 Application，通过反射建立并运行。这里需要注意的是，现在是加载一个完整的 APK 让它运行起来，一个 APK 运行的时候都是有一个 Application 对象的，这个也是一个程序运行之后的全局类。所以必须找到解密之后的源 Apk 的 Application 类，运行它的 onCreate 方法，这样源 Apk 才能开始它的运行生命周期。 根据以上流程图，我们需要在 Android Studio 中新建一个项目，创建一个继承自 Application 的 ProxyApplication 类，并在 attachBaseContext 方法中解密和动态加载源 APK，在 onCreate 方法中找到源 APK 的 Application 类并运行。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"deepIntent学习","slug":"Paper/deepIntent学习","date":"2023-09-23T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/09/23/Paper/deepIntent学习/","link":"","permalink":"https://beichen.link/2023/09/23/Paper/deepIntent%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"paper 学习DeepIntent，一个深度图标行为学习框架，从大量流行应用程序中学习图标行为模型并检测意图-行为差异的框架。 特别是，DeepIntent 提供了程序分析技术，将意图（即图标和上下文文本）与 UI 窗口小部件的程序行为相关联，并基于程序行为推断 UI 窗口小组件的标签（即权限使用），从而能够构建大规模高质量的训练数据集。 DeepIntent 的设计基于三个关键见解。 首先，移动应用的用户界面（UI）应该对用户明显可见，并且指示相同类型敏感行为的图标应该具有相似的外观。这启发我们借鉴了 CNN 在图像识别方面的成功经验[35, 36]，使用 CNN 来对图标（即图标的像素）进行建模，以识别相似的图标。 其次，在不同的 UI 上下文中，图标可能反映不同的意图。例如，在不同的上下文中，“发送”按钮可能表示发送电子邮件或短信。虽然仅通过比较图标很难区分意图，但上下文文本，如附近的文本标签和 UI 的标题，可以用来帮助区分图标的上下文。 第三，用户期望与具有特定外观的图标小部件进行交互时产生特定的行为，并且不希望出现与用户期望相矛盾的行为。例如，当用户查看图 1(a)中的第一个突出显示的图标时，他们期望该应用程序读取他们的联系人，而不是公开他们的位置信息。 为了捕捉这种普遍的期望，我们提出开发程序分析技术，可以将图标与其敏感行为关联起来，并将这些技术应用于从一组流行应用程序的语料库中提取关联，以学习具有特定外观的图标小部件的预期行为模型。 DeepIntent 包括三个主要阶段 图标小部件分析。 我们学习模型中使用的输入包括图标、上下文文本和与图标相关的权限使用。为了提取图标及其权限使用，DeepIntent 提供了一种静态分析方法，通过分析 APK 文件来识别图标小部件并提取相应的图标-权限映射，即将 UI 小部件中使用的图标映射到其权限使用。 具体而言，静态分析(1)通过分析 UI 布局文件和代码将图标与 UI 小部件关联起来，(2)将图标小部件与 UI 处理程序关联起来，(3)通过考虑多线程和 ICC 构建 UI 处理程序的调用图，(4)将调用图中的方法调用映射到权限使用。从提取的图标中，DeepIntent 提供了一种文本提取技术，通过分析 UI 布局文件、图标中嵌入的文本和图标文件名来提取图标的上下文文本。 以电话呼叫按钮为例。DeepIntent 从 UI 布局文件中提取资源 ID，分析处理该按钮的代码，构建调用图，并将按钮映射到其权限使用（即 CALL 权限）。图标行为关联的输出是一组⟨图标，文本，权限⟩三元组。 学习图标-行为模型。 DeepIntent 采用并行共同关注机制[47, 90]来共同建模图标及其上下文文本。具体而言，DeepIntent 首先使用 DenseNet [30]和 GRUs [10]分别提取图标图像和上下文文本的初始化特征。然后，DeepIntent 通过共同关注将这两个特征合并成一个联合特征向量，其基本思想是通过突出显示彼此相关的图像&#x2F;文本区域来同时更新图像&#x2F;文本特征。 接下来，DeepIntent 通过使用映射的图标权限来训练模型，学习图标的联合特征向量。由于每个图标可能与多个权限使用相关，我们将其构建为一个多标签分类问题来学习联合特征。 检测意图-行为差异。 利用学习到的图标行为模型，DeepIntent 首先提取图标小部件的联合特征向量，然后通过计算和聚合图标小部件使用的每个权限的异常值得分来检测意图-行为差异。具体而言，我们通过自动编码器[3]计算每个使用的权限的异常值得分，并根据图标行为模型将这些得分聚合成最终的异常值得分。实际的权限使用是通过用于提取图标-权限映射的程序分析获得的。 图标-行为关联该模块提供了静态分析技术，用于识别图标小部件，提取它们的图标和文本，并推断图标小部件的权限使用。 该模块包含四个主要组件：1）图标小部件关联，2）扩展调用图构建，3）小部件-API 关联，以及 4）API 权限检查 实验复现如果出现这样的问题： 则需要更换 java 版本，原来本机是 java11，现在改成了 java8 更改教程如下： https://blog.csdn.net/qq_42824983/article/details/114674833 https://www.cnblogs.com/xnancy/p/15656733.html 实际上按照网址 1 修过了后不起作用，然后又改了 etc&#x2F;profile，然后 source，才改过来 改完 apkcallgraph 后，需要重新打包成 jar 包，使用 eclipse 本地打包再上传服务器，导入包问题在 eclipse 上解决 具体打包步骤，eclipse 里 export 然后 runnable jar，设置主类，然后选 extract jar 选项，打包完成","categories":[{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"}],"tags":[{"name":"OSS Security","slug":"OSS-Security","permalink":"https://beichen.link/tags/OSS-Security/"}]},{"title":"frida 脱壳原理","slug":"Study/逆向知识/Frida脱壳原理","date":"2023-09-20T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/09/20/Study/逆向知识/Frida脱壳原理/","link":"","permalink":"https://beichen.link/2023/09/20/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Frida%E8%84%B1%E5%A3%B3%E5%8E%9F%E7%90%86/","excerpt":"","text":"Frida-dexdump 脱壳原理frida-dexdump 通过以下步骤实现 DEX 文件的解析： 使用 Frida 注入到目标应用程序中，并找到 DEX 文件的内存地址。 将 DEX 文件的内存数据读取到 Frida 的 JavaScript 环境中，并使用 Frida 提供的 Memory API 将其转换成 JavaScript 的 ArrayBuffer 类型。 使用 JavaScript 实现的 DEX 文件解析器，解析 ArrayBuffer 中的 DEX 数据，并构建出 DEX 文件的数据结构，包括文件头、字符串池、类型池、方法池、字段池等。 将解析后的 DEX 文件数据结构转换成可读的文本格式，并输出到控制台或文件中。 需要注意的是，Frida-dexdump 仅能解析已经加载到内存中的 DEX 文件，对于已经被加固或混淆的应用程序，DEX 文件可能会被加密或修改，导致无法正确解析。 Frida 提供的 Memory APIFrida 提供了一组 Memory API，用于在 Frida 的 JavaScript 环境中操作目标进程的内存数据。这些 API 包括： Memory.alloc(size)：在目标进程中分配指定大小的内存，并返回其内存地址。 Memory.copy(dest, src, size)：将目标进程中 src 地址开始的 size 字节数据复制到 dest 地址中。 Memory.protect(address, size, protection)：设置目标进程中指定内存区域的保护属性，包括读、写、执行等。 Memory.readByteArray(address, size)：从目标进程中指定地址读取指定大小的内存数据，并返回一个 Uint8Array 类型的数组。 Memory.readUtf8String(address)：从目标进程中指定地址读取以 NULL 结尾的 UTF8 字符串，并返回一个 JavaScript 字符串。 Memory.writeByteArray(address, bytes)：向目标进程中指定地址写入一个 Uint8Array 类型的数组。 Memory.writeUtf8String(address, str)：向目标进程中指定地址写入一个以 NULL 结尾的 UTF8 字符串。 Memory.scan(base, size, pattern, callbacks)：用于在目标进程的内存中搜索指定的内容。 其中上面提到的 Memory.scan，也是 frida-dexdump 的第一步的原理，通过扫描内存中数据，判断是否包含 dex 头部相关信息，然后通过 readByteArray 返回具体内容。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Android IPC","slug":"Study/Android知识/Android IPC","date":"2023-09-16T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/09/16/Study/Android知识/Android IPC/","link":"","permalink":"https://beichen.link/2023/09/16/Study/Android%E7%9F%A5%E8%AF%86/Android%20IPC/","excerpt":"","text":"IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。 进程(process)和线程(thread)是两个不同的概念。进程一般指一个一个执行单元，是程序运行的实例，在移动设备上指一个应用；而线程是 CPU 调度和分派的最小单位。一个进程中可以有多个线程，两者是包含与被包含关系。 每一个 Android 应用程序都在它自己的进程中运行，都拥有一个独立的虚拟机实例。而每一个虚拟机都是在 Linux 中的一个进程，所以说可以认为是同一个概念。 任何一个操作系统都有相应的 IPC 机制，Linux 上面可以通过命名管道、共享内存、信号量等来进行 IPC。而在 Android 中，最有特色的就是 Binder，通过 Binder 可以轻松进行 IPC 操作。 Andoid IPC 基础概念Serializable 接口Serializable 接口是 Java 提供的一个序列化接口，它是一个空接口，使用时只需要实现 Serializable 并声明一个 serialVersionUID 就可以，无需 override 任何方法。 private static final long serialVersionUID = 32163781263816L; 可以将实现了 Serializable 接口的对象序列化到文件中或者从文件中反序列化，操作非常简单。 12345678910// 序列化过程User user = new User();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;));oos.writeObject(user);oos.close();// 反序列化过程ObjectInputStream ins = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;));User newUser = (user) ins.readObject();ins.close(); 实际上，甚至 serialVersionUID 常量都不是必须的，如果我们不声明这个常量，序列化会正常进行，但是会影响反序列化。 Parcelable 接口Parcelable 接口也是一种 Android 中的序列化接口,主要用在内存序列化上，性能比 Serializable 要好，性能要高，但是需要实现额外的方法。 通过 Parcelable 可以将对象序列化到存储设备中或将对象序列化后通过网络传输也都是可以的，这是过程会稍显复杂，这种情况下建议使用 Serializable。 实现 Parcelable 接口需要 override describeContents()和 writeToParcel()两个方法，以及一个 Parcelable.Creator的内部类。 12345678910111213141516171819202122232425262728293031public class MyParcelable implements Parcelable &#123; private int mData; private Book book; // describeContents方法一般返回0，仅当当前对象中存在文件描述符时，才返回1。 public int describeContents() &#123; return 0; &#125; public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(mData); out.writeParcelable(book, 0); &#125; public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() &#123; public MyParcelable createFromParcel(Parcel in) &#123; return new MyParcelable(in); &#125; public MyParcelable[] newArray(int size) &#123; return new MyParcelable[size]; &#125; &#125;; private MyParcelable(Parcel in) &#123; mData = in.readInt(); book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125;&#125; Binder直观来说，Binder 是 Android 中的一个类，它实现了 IBinder 接口。 从 IPC 角度来说，Binder 是 Android 中的一种跨进程通信方式。Binder 还可以理解为一种虚拟的物理设备，它的设备驱动是&#x2F;dev&#x2F;binder，该通信方式在 Linux 中没有； 从 Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager 等等）和相应的 ManagerService 的桥梁； 从应用层来说，Binder 是客户端和服务端进行通信的媒介，当 bindService 的时候，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于 AIDL 的服务。 Binder 在 Android 应用开发中主要用于 Service 中，包括 AIDL 和 Messenger。 传统的 IPC 方式中，进程之间是如何实现通信的。 通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。 同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图： 这种传统的 IPC 通信方式有两个问题： 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝； 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。 Binder IPC 是基于内存映射（mmap）来实现的，mmap 用来在内核空间创建数据接收的缓存空间。 mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。 内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。 一次完整的 Binder IPC 通信过程通常是这样： 首先 Binder 驱动在内核空间创建一个数据接收缓存区； 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系； 发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。 Android 中的 IPC 方式Android 中可以实现 IPC 方式的有很多，比如通过 Intent 附加 extras 传递信息，通过共享文件传递数据，还可以采用 Binder 方式来进行 IPC。另外，ContentProvider 天生就是支持 IPC 的，通过网络通信也是可以的，因此还可以采用 Socket。 下表是常见 IPC 方式的优缺点以及使用场景 1 基于序列化 Serializable&#x2F;Parcelable 接口1.1 Java Serializable将对象序列化到文件中或者从文件中反序列化 1.2 Android Parcelable 接口bundle 就实现了 parcelable 接口，可用于不同进程间传输 我们知道 Intent 的启动 Activity、Service、Receiver 都是通过构造 ComponentName 来实现的，我们可以使用 intent.setComponent(new ComponentName())的方式来显示开启另一进程的组件，或者以隐式的方式开启。当然缺点是 Bundle 支持的数据类型有限。 2 使用文件共享两个进程读写同一个文件来交换数据。在 Window 上，一个文件加了锁会导致其他进程无法访问该文件，但是在 Linux 上，对其进行并发读写是没有任何限制的，甚至可以并发写，尽管这很可能出问题。 文件共享适合在数据同步不高的进程间进行通信，并且需要妥善处理好读写问题。 SharedPreferences 也属于文件的一种，但是系统会在内存中持有一份 SharedPreferences 文件的缓存，因此在多进程模式下，系统对其进行的读写就不可靠，面对高并发的读写访问，SharedPreferences 有很大几率会丢失数据。 3 AIDL 方案一种基于 Binder 机制的接口定义语言，用于定义客户端和服务端之间进行通信的规则。AIDL 文件会被编译成 Java 文件，生成对应的 Stub 类和 Proxy 类，分别用于服务端和客户端实现和调用跨进程方法。 3.1 使用 Messenger一种基于 AIDL 和 Handler 机制的简单 IPC 方式，用于在不同进程之间发送和接收 Message 对象。Messenger 内部封装了一个实现了 AIDL 接口的 Binder 对象，并使用 Handler 来处理 Message 对象。 但它一次只能处理一个请求，因此不需要在服务端考虑因并发执行而产生的线程同步问题。 3.2 使用 AIDLAIDL(Android Interface Definition Language) 3.2.1 使用 AIDL 的必要条件 只有当你需要来自不同应用的客户端通过 IPC（进程间通信）通信来访问你的服务时，并且想在服务里处理多线程的业务，这时就需要使用 AIDL。 如果你不需要同时对几个应用进程 IPC 操作，你最好通过实现 Binder 接口来创建你的接口。 如果你仍需要执行 IPC 操作，但不需要处理多线程，使用 Messenger 来实现接口即可。 3.2.2 AIDL 的使用3.3 使用 ContentProvider和 Messenger 一样，ContentProvider 底层实现同样也是 Binder，但是使用过程比 AIDL 要简单的多。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"找到的面试题","slug":"Study/逆向知识/找到的逆向面试题","date":"2023-09-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/09/15/Study/逆向知识/找到的逆向面试题/","link":"","permalink":"https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%89%BE%E5%88%B0%E7%9A%84%E9%80%86%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1. initarry 的作用，可以没有 initarry 么？移动端 Android 安全的发展，催生了各种 Android 加固的诞生，基于 ELF 文件的特性，很多的加固厂商在进行 Android 逆向的对抗的时，都会在 Android 的 so 文件中进行动态的对抗，对抗的点一般在 so 文件的. init 段和 JNI_OnLoad 处。因此，我们在逆向分析各种厂商的加固 so 时，需要在 so 文件的. init 段和 JNI_OnLoad 处下断点进行分析，过掉这些加固的 so 对抗。 init 和.init_array 两个 section 用于在 so 文件被加载时做初始化工作，系统在加载 so 文件时会先执行.init 中的代码，然后再顺序执行.init_array 中的各个代码块，且.init 和.init_array 的执行时机均早于 JNI_OnLoad 方法，所以这两个 section 的执行时间是比较早的 init_array 是 ELF 文件中的一个特殊 section，用于存储全局构造函数（global constructors）的地址。在程序启动时，动态链接器会按照 init_array 中的顺序调用这些构造函数，用于全局对象的初始化。 在 Android NDK 编程中，.init 和.init_array 中函数的定义方式如下： 1234void _init(); //编译生成后在.init段__attribute__((constructor)) void _init(); //编译生成后在.init_array段 不难看出，若函数名指定为_init，则通过 NDK 编译以后该函数的代码会在.init 中；若函数被attribute((constructor))属性修饰，则编译以后该函数会在.init_array 中。 _init 函数经过编译后就是 .init_proc 函数 可以没有 init_array，但这意味着全局构造函数将不被执行。对于某些程序，这可能导致未定义的行为或程序错误。如果程序不依赖全局构造函数进行初始化，则可以没有 init_array。 2. 为什么可以删除 section 节区？在 ELF 文件中，section 是用来存储各种类型的信息（例如：代码段、数据段、符号表、重定位表等）。链接器（Linker）在链接过程中使用这些信息来生成可执行文件。一旦链接过程完成，生成了可执行文件，某些 section 的信息就不再需要了。 删除无用的 section 节区可以减小可执行文件的大小，节省存储空间和内存。需要注意的是，并非所有 section 都可以删除。删除关键 section（例如：代码段、数据段等）可能导致程序无法正常运行。 https://segmentfault.com/a/1190000044097864 https://pollux.cc/2020/02/19/inlineHookS/ https://eternalsakura13.com/2020/07/04/frida/","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"待整理的文章","slug":"Study/逆向知识/收藏的网址","date":"2023-09-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/09/15/Study/逆向知识/收藏的网址/","link":"","permalink":"https://beichen.link/2023/09/15/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E5%9D%80/","excerpt":"","text":"https://sentrylab.cn/blog/2022/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/ https://github.com/CrackerCat/simpread/blob/00738d68838ac1b1c4e6be39f37b8b3714411764/md/%5B%E5%8E%9F%E5%88%9B%5D%20%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%8F%8D%E8%B0%83%E8%AF%95%20%2B%20ollvm%20%E6%B7%B7%E6%B7%86%E7%9A%84%20Crackme.md?plain=1#L15 https://www.wanandroid.com/blog/show/3490 https://juejin.cn/post/7045535769200427045 https://bbs.kanxue.com/thread-273160.htm https://www.bilibili.com/video/BV1Y84y1Y7Nc/?vd_source=8f930e2394b37d35a2e863ca32b036b3 https://weishu.me/page/2/ https://github.com/WindXaa/Android-Vulnerability-Mining http://si1ence.top/ https://www.bilibili.com/read/cv24212888/ https://github.com/bigGreenPeople/SharkInject/blob/1294d428532facac81ef5d19f3d89d3dce453584/app/src/main/cpp/native-lib/native-lib.cpp#L10 签名：https://github.com/gtf35/how-to-check-sign","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"IDA 调试 init_array","slug":"Study/逆向知识/调试init","date":"2023-09-13T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/09/13/Study/逆向知识/调试init/","link":"","permalink":"https://beichen.link/2023/09/13/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E8%B0%83%E8%AF%95init/","excerpt":"","text":"在安卓脱壳过程中，经常需要用 ida 动态调试 so,并且在解密代码执行前下断点，下面介绍用 IDA 在 Android so 文件的.init、.init_array 上和 JNI_OnLoad 处下断点方法。 一、上传 android_server,启动 android_server上传 android_server 到手机&#x2F;data&#x2F;local&#x2F;tmp 目录 adb push android_server /data/local/tmp 赋予 android_server 执行权限 $ chmod 777 android_server 以 root 身份执行 android_server 文件，android_server 文件默认监听 23946 端口，可以通过-p 端口参数进行设置端口，注意 p 和端口之间无空格 ./android_server -p23946 二、打开 DDMS 程序打开 DDMS 程序,DDMS 程序会将应用的调试端口映射到电脑上，使用 jdb 命令能够对被挂起的程序恢复执行。 三、进行端口转发使用 adb 命令进行端口转发 adb forward tcp:23946（PC_port） tcp:23946(Phone_port) 四、以调试模式启动 app我们以 debug 模式启动程序。程序会出现 waiting for debugger 的调试界面 12adb shell am start -D -n com.example.inittest/.MainActivityStarting: Intent &#123; cmp=com.example.inittest/.MainActivity &#125; 程序会出现 waiting for debugger 的调试界面 这时 DDMS 显示，调试端口在 8700 五、用 IDA 附加到启动 ida 并 attach 这个 app 的进程。 六、当 so 加载的时候挂起在 debugger setup 里勾选 suspend on library load。然后点击继续（按 F9 键继续）。 七、使用 jdb 命令恢复程序执行使用 jdb 命令恢复程序执行 123456$ jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700设置未捕获的java.lang.Throwable设置延迟的未捕获的java.lang.Throwable正在初始化jdb... 这时 DDMS 中该应用的颜色变为了绿色： 程序加载 so,由于之前的设置，程序停在了 liner 处 八、确定模块的加载地址，在 linker 和 libvm.so 中下断点在 android4.4.4_r1 源码中，linker 中 .init 和.init_array 的断点位置为 0000274C,JNI_OnLoad 的断点位置为 00050004 我们先查看内存中 segment 中 linker 加载的位置 按 Ctrl+S 组合键打开内存中的 segmets,知道 linker 的内存加载地址 4008B000,那么断点的位置是 4008B000+0000274C&#x3D;4008D74C。 按 G 键输入地址 4008D74C 进行跳转，将光标移至该处后按 P 键进行反汇编，看到了汇编代码，在该处 4008D74C 下断点","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"System Server","slug":"Study/Android知识/System_Server学习","date":"2023-09-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/09/10/Study/Android知识/System_Server学习/","link":"","permalink":"https://beichen.link/2023/09/10/Study/Android%E7%9F%A5%E8%AF%86/System_Server%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"安卓最重要的系统进程当然是 system_process. 这个进程是 zygote 孵化的第一个进程，它管理着安卓系统中各种大大小小的系统 service 的实现（SystemService）。也就是下面图中各种 manager 的 server 端实现（安卓的 C&#x2F;S 架构）。 系统服务其实都是一个远程 Binder 对象，而这个对象都是由 ServiceManager 大管家管理的，用户在使用系统服务的时候，会通过指定服务的 Stub 类的 asInterface 方法 把远程的 Binder 对象转化成本地化对象即可使用，而在这个过程中，我们也知道因为系统服务是在 system_server 进程中的，所以这个系统服务使用过程中属于跨进程调用，那么返回的对象其实就是 Proxy 代理对象。 系统服务使用流程通过系统剪切板服务案例作为分析 12345678//获取剪切板服务ClipboardManager cm =(ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);//设置剪切板内容cm.setPrimaryClip(ClipData.newPlainText(&quot;data&quot;,&quot;jack&quot;));//获取剪切板数据对象ClipData cd = cm.getPrimaryClip();String msg = cd.getItemAt(0).getText().toString();Log.d(&quot;jw&quot;, &quot;msg:&quot;+ msg); 使用系统服务的时候都是用了 getSystemService 方法，通过定义在 Context 中的服务描述符常量来获取服务对象 ClipboardManager 但是实际上内部是先通过 ServiceManager 获取到 ClipboardManager 的远程 IBinder 对象，然后再通过 IClipboard$Stub方法将IBinder对象转化成本地对象，即IClipboard$Proxy 对象 每次获取系统服务的流程都是一样的，先通过 ServiceManager 的 getService 方法获取远端服务的 IBinder 对象，然后在通过指定服务的 Stub 类的 asInterface 方法转化成本地可使用对象，而这个对象其实就是一个 Proxy 对象 Java 代理模式意图：为其他对象提供一种代理以控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 何时使用：想在访问一个类时做一些控制。 如何解决：增加中间层。 关键代码：实现与被代理类组合。 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 优点： 1、职责清晰。 2、高扩展性。 3、智能化。 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 静态代理静态代理是指代理类在程序运行前就已经存在，这种情况下的代理类通常都是我们在 Java 代码中定义的。 这种代理方式需要代理对象和目标对象实现一样的接口。 优点：可以在不修改目标对象的前提下扩展目标对象的功能。 缺点： 冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。 不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。 举例：保存用户数据功能的静态代理实现 接口类： IUserDao 12345package com.proxy;public interface IUserDao &#123; public void save();&#125; 目标对象：UserDao 123456789package com.proxy;public class UserDao implements IUserDao&#123; @Override public void save() &#123; System.out.println(&quot;保存数据&quot;); &#125;&#125; 静态代理对象：UserDapProxy 需要实现 IUserDao 接口！ 1234567891011121314151617package com.proxy;public class UserDaoProxy implements IUserDao&#123; private IUserDao target; public UserDaoProxy(IUserDao target) &#123; this.target = target; &#125; @Override public void save() &#123; System.out.println(&quot;开启事务&quot;);//扩展了额外功能 target.save(); System.out.println(&quot;提交事务&quot;); &#125;&#125; 测试类：TestProxy 123456789101112131415package com.proxy;import org.junit.Test;public class StaticUserProxy &#123; @Test public void testStaticProxy()&#123; //目标对象 IUserDao target = new UserDao(); //代理对象 UserDaoProxy proxy = new UserDaoProxy(target); proxy.save(); &#125;&#125; 1234输出结果开启事务保存数据提交事务 动态代理动态代理是指代理类在程序运行时进行创建的代理方式。这种情况下，代理类并不是在 Java 代码中定义的，而是在运行时根据 Java 代码中的“指示”动态生成的。相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。 静态代理在编译时就已经实现，编译完成后代理类是一个实际的 class 文件 动态代理是在运行时动态生成的，即编译完成后没有实际的 class 文件，而是在运行时动态生成类字节码，并加载到 JVM 中 基于 JDK 原生动态代理实现实现动态代理通常有两种方式：JDK 原生动态代理和 CGLIB 动态代理。这里，我们以 JDK 原生动态代理为例来进行讲解。 JDK 动态代理需要目标对象实现业务接口，代理类只需实现 InvocationHandler 接口, 通过反射代理方法，尽管比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 JDK 动态代理主要涉及两个类：java.lang.reflect.Proxy 和 java.lang.reflect.InvocationHandler。 InvocationHandler 接口定义了如下方法： 123456/** * 调用处理程序 */public interface InvocationHandler &#123; Object invoke(Object proxy, Method method, Object[] args);&#125; 顾名思义，实现了该接口的中介类用做“调用处理器”。当调用代理类对象的方法时，这个“调用”会转送到 invoke 方法中，代理类对象作为 proxy 参数传入，参数 method 标识了具体调用的是代理类的哪个方法，args 为该方法的参数。这样对代理类中的所有方法的调用都会变为对 invoke 的调用，可以在 invoke 方法中添加统一的处理逻辑(也可以根据 method 参数对不同的代理类方法做不同的处理)。 Proxy 类用于获取指定代理对象所关联的调用处理器。java.lang.reflect Proxy，主要方法为 123456static Object newProxyInstance( ClassLoader loader, //指定当前目标对象使用类加载器 Class&lt;?&gt;[] interfaces, //目标对象实现的接口的类型 InvocationHandler h //事件处理器)//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。 需要实现的中介类： 1234567891011121314151617181920212223242526import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Date;public class LogHandler implements InvocationHandler &#123; Object target; // 被代理的对象，实际的方法执行者 public LogHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); // 调用 target 的 method 方法 after(); return result; // 返回方法的执行结果 &#125; // 调用invoke方法之前执行 private void before() &#123; System.out.println(String.format(&quot;log start time [%s] &quot;, new Date())); &#125; // 调用invoke方法之后执行 private void after() &#123; System.out.println(String.format(&quot;log end time [%s] &quot;, new Date())); &#125;&#125; 客户端编写程序使用动态代理代码如下： 12345678910111213141516import java.lang.reflect.Proxy;public class DynamicProxyMain &#123; public static void main(String[] args) &#123; // 创建中介类实例 LogHandler logHandler = new LogHandler(new Vendor()); //vendor为被代理对象 // 获取代理类实例Sell Sell sell = (Sell) (Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[]&#123;Sell.class&#125;, logHandler)); //sell为接口类 // 通过代理类对象调用代理类方法，实际上会转到invoke方法调用 sell.sell(); sell.ad(); &#125;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"算法题java语法","slug":"Study/算法/算法题java语法","date":"2023-08-27T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/27/Study/算法/算法题java语法/","link":"","permalink":"https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98java%E8%AF%AD%E6%B3%95/","excerpt":"","text":"输入、输出远程在线面试的手撕代码环节，通常需要白板上写代码。如果需要在控制台输入、输出，需要借助 Scanner 类。示例如下： 12345678910111213141516import java.util.Scanner;public class Solution &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); //方法1：一般用来接收数组。以空格分界 while(scanner.hasNext())&#123; int num = scanner.nextInt(); /*或者*/ String next = scanner.next(); &#125; //方法2：一般用来接受字符串。以换行符分界 while (scanner.hasNextLine()) &#123; String str = scanner.nextLine(); &#125; &#125; 类型转换Integer String -&gt; int：int value &#x3D; Integer.parseInt(str); 将 str 转换成二进制的 int： int binary &#x3D; Integer.parseInt(str,2); 十进制转二进制：String binaryN &#x3D; Integer.toBinaryString(N); String Object -&gt; String：String str &#x3D; String.valueOf(o); char[ ] -&gt; String：String str &#x3D; String.valueOf(charArray); int -&gt; String：String str &#x3D; String.valueOf(N); String 方法 长度：int len &#x3D; str.length(); 字符串比较：str1.equals() 字符串替换：String newStr &#x3D; str.replaceAll(“a”,”.”); &#x2F;&#x2F;replace 只能换 char 字符串分割：String newStr &#x3D; str.split(“ “); &#x2F;&#x2F;根据括号里的分割 String -&gt; char[ ]：char[] charStr &#x3D; str.toCharArray(); String -&gt; char：char charS &#x3D; str.charAt(index); 字符串变小写：String lowerStr &#x3D; str.toLowerCase(); 字符串变大写：String upperStr &#x3D; str.toUpperCase(); 字符串截取：str.substring(start,end); &#x2F;&#x2F;包含 start,不包含 end 数字转字符串：String str &#x3D; String.valueOf(123456); 辅助工具类：StringBuider sb &#x3D; new StringBuilder(“”); &#x2F;&#x2F;添加sb.append(“”);&#x2F;&#x2F;删除sb.deleteCharAt();&#x2F;&#x2F;反转sb.reverse();&#x2F;&#x2F; 转 stringsb.toString(); 对 Map 的方法 map 中是否包含 key：boolean isContain &#x3D; map.containsKey(key); map 的 get()：Object value &#x3D; map.get(key); map 的 getOrDefault()： map.getOrDefault(key,default);&#x2F;&#x2F;没找到就 return default map 的 put()：map.put(key,value); &#x2F;&#x2F;若 key 已存在，则替代并返回旧的 value 值 map 的遍历：for(Object key : map.keySet()){ &#x2F;&#x2F;… } 求长度 数组：用 arr.length length 是数组的一个属性。 字符串：用 str.length() length() 是 StringObject 的一个方法。 集合：用 list.size() size()是 list 的一个方法。 数组 长度：int h &#x3D; height.length 新建：int[] tmp &#x3D; new int[arr.length]; 排序：Arrays.sort(nums); &#x2F;&#x2F;从小到大排序，时间复杂度为 o(nlog n) 复制：Arrays.copyOf 复制一个数组：int[] newA &#x3D; Array.copyOf(a, 5); &#x2F;&#x2F;5 为数组 size 初始化： 12345678// Type[] names = new Type[capacity];int[] a = new int[10];String[] s = new String[3]; // Type[] names = new Type[]&#123;Tpye ...a&#125;; int[] a = new int[]&#123;1, 2, 3, 4&#125;; // int[] a = &#123;1, 2, 3, 4&#125;; char[] b = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;; // char[] b = &#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;; String[] s = new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;; HashMap 和 HashSetHashMap 即：映射 (Map 接口，将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值) 性质：使用健值对的方式存储数据 &lt;Key,Value&gt; 初始化：Map&lt;Characters, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); map 中是否包含 key：boolean isContain &#x3D; map.containsKey(key); map 的 put()将键值对&lt;K,V&gt;放入 map ：map.put(key,value); map 的 get()获得指定 key 值对应键值：Object value &#x3D; map.get(key);map 的 getOrDefault()： map.getOrDefault(key,default);&#x2F;&#x2F;没找到就 return default map.keySet(): 返回一个 Set,这个 Set 中包含 Map 中所有的 Keymap.values(): 返回一个 Collection,里面全是对应的每一个 valuemap 的遍历：for(Object key : map.keySet()){ &#x2F;&#x2F;… }for (Integer value : map.values()) {·····} map 删除指定键值:map.remove(Object key) map.isEmpty(): 判断是不是空： map.size(): 返回 Map 中中键值对&lt;K, V&gt;的个数: HashSet集合(Set 接口是一个不包含重复元素的集合)性质：Set 中没有重复元素，重复添加的元素抛弃 导入库 java.util.HashSet HashSet 初始化: HashSet setname &#x3D; new HashSet&lt;&gt;(); .add() 增加元素 .contains():判断是否存在一个元素 .remove() 删除一个制定元素 .isEmpty() 判断集合是否为空 .clear() 清空集合 .size() 返回集合中中元素个数 Stack 先进后出初始化 : Stack stack &#x3D; new Stack(); 入栈：stack.push(Object o)&#x2F;&#x2F; 入栈元素 o， 返回值为元素 o 出栈：stack.pop()&#x2F;&#x2F; 出栈一个元素，返回出栈元素 o 返回栈顶：stack.peek()&#x2F;&#x2F; 查看栈顶元素， 返回值为栈顶元素 o 栈空：stack.isEmpty()&#x2F;&#x2F; 若栈空返回 true， 否则返回 false 元素个数：stack.size() &#x2F;&#x2F; 返回栈中元素个数 遍历用 for (Integer x : s)","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习","slug":"Study/算法/面试算法","date":"2023-08-27T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/27/Study/算法/面试算法/","link":"","permalink":"https://beichen.link/2023/08/27/Study/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/","excerpt":"","text":"快手1. 反转链表 leetcode 2061234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; ListNode temp = null; while(cur != null)&#123; temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; return pre; &#125;&#125; 2. 链表翻转 II leetcode 92给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表。 头插法，一轮遍历即可。 12345678910111213141516171819202122class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; // 设置 dummyNode 是这一类问题的一般做法 ListNode dummyNode = new ListNode(-1); dummyNode.next = head; ListNode pre = dummyNode; for (int i = 0; i &lt; left - 1; i++) &#123; pre = pre.next; &#125; ListNode cur = pre.next; ListNode next; for (int i = 0; i &lt; right - left; i++) &#123; next = cur.next; cur.next = next.next; next.next = pre.next; //z=这里不能用next.next = cur; 因为cur的值没变，但位置在变，只有pre.next 一直指向开头节点 pre.next = next; &#125; return dummyNode.next; &#125;&#125; 3. 二叉树的层序遍历 leetcode 1021234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */import java.util.*;// 广度优先遍历，BFSclass Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if (root == null)&#123; return new ArrayList&lt;List&lt;Integer&gt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(queue.size()&gt;0)&#123; int size = queue.size(); ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); for (int i = 0;i &lt; size;i++)&#123; TreeNode t = queue.remove(); tmp.add(t.val); if (t.left != null )&#123; queue.add(t.left); &#125; if (t.right!= null)&#123; queue.add(t.right); &#125; &#125; res.add(tmp); &#125; return res; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */import java.util.*;// dfs,深度优先遍历class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if (root == null)&#123; return new ArrayList&lt;List&lt;Integer&gt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(1,root,res); return res; &#125; void dfs (int index,TreeNode root,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(res.size()&lt; index)&#123; res.add(new ArrayList&lt;Integer&gt;()); &#125; res.get(index-1).add(root.val); if (root.left != null)&#123; dfs(index+1,root.left,res); &#125; if (root.right != null)&#123; dfs(index+1,root.right,res); &#125; &#125;&#125; 4. 全排列 leetcode 461234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; int len = nums.length; List &lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(len == 0)&#123; return res; &#125; boolean[] used = new boolean[len]; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(nums,len,0,path,used,res); return res; &#125; public void dfs(int[] nums,int len,int depth,List&lt;Integer&gt; path ,boolean[] used,List&lt;List&lt;Integer&gt;&gt; res)&#123; if (depth == len)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i&lt; len;i++)&#123; if (!used[i])&#123; path.add(nums[i]); used[i] = true; dfs( nums,len,depth+1,path,used,res); used[i] = false; path.remove(path.size()-1); &#125; &#125; &#125;&#125; 5. 数组中第 k 个最大元素 leetcode 215123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; private int quickSelect(List&lt;Integer&gt; nums, int k) &#123; // 随机选择基准数 Random rand = new Random(); int pivot = nums.get(rand.nextInt(nums.size())); // 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中 List&lt;Integer&gt; big = new ArrayList&lt;&gt;(); List&lt;Integer&gt; equal = new ArrayList&lt;&gt;(); List&lt;Integer&gt; small = new ArrayList&lt;&gt;(); for (int num : nums) &#123; if (num &gt; pivot) big.add(num); else if (num &lt; pivot) small.add(num); else equal.add(num); &#125; // 第 k 大元素在 big 中，递归划分 if (k &lt;= big.size()) return quickSelect(big, k); // 第 k 大元素在 small 中，递归划分 if (nums.size() - small.size() &lt; k) return quickSelect(small, k - nums.size() + small.size()); // 第 k 大元素在 equal 中，直接返回 pivot return pivot; &#125; public int findKthLargest(int[] nums, int k) &#123; List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); for (int num : nums) &#123; numList.add(num); &#125; return quickSelect(numList, k); &#125;&#125; 6. 无重复字符的最长子串 leetcode 312345678910111213141516171819class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; int left = 0; for(int i = 0; i &lt; s.length(); i ++)&#123; if(map.containsKey(s.charAt(i)))&#123; left = Math.max(left,map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-left+1); &#125; return max; &#125;&#125; 7. 合并两个有序链表 leetcode 2112345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode dum = new ListNode(0), cur = dum; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; cur.next = list1; list1 = list1.next; &#125; else &#123; cur.next = list2; list2 = list2.next; &#125; cur = cur.next; &#125; cur.next = list1 != null ? list1 : list2; return dum.next; &#125;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Python学习","slug":"Study/语言学习/python知识","date":"2023-08-25T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/25/Study/语言学习/python知识/","link":"","permalink":"https://beichen.link/2023/08/25/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/python%E7%9F%A5%E8%AF%86/","excerpt":"","text":"简述下 Python 中的字符串、列表、元组和字典 字符串（str）：字符串是用引号括起来的任意文本，是编程语言中最常用的数据类型。 列表（list）：列表是有序的集合，可以向其中添加或删除元素。 元组（tuple）：元组也是有序集合，但是是无法修改的。即元组是不可变的。 字典（dict）：字典是无序的集合，是由 key-value 组成的。 集合（set）：是一组 key 的集合，每个元素都是唯一，不重复且无序的 装饰器参考装饰器，装饰的对象是函数或者方法。各种装饰器的作用都是一样的：改变被装饰函数或者方法的功能，性质 场景：装饰器用于有以下场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。 12345678910111213141516171819import timedef get_time(func): def inner(): time1 = time.time() func() time2 = time.time() print(&quot;cost time:&quot; + str(time2 - time1)) return inner()def sleep1(): time.sleep(5)@get_time # 相当于sleep2 = get_time(sleep2)def sleep2(): time.sleep(6)sleep1 = get_time(sleep1) 迭代器迭代器就是用于迭代操作（for 循环）的对象，它像列表一样可以迭代获取其中的每一个元素，任何实现了 next 方法 （python2 是 next）的对象都可以称为迭代器。 它与列表的区别在于，构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算（lazy evaluation）方式返回元素，这正是它的优点。比如列表含有中一千万个整数，需要占超过 400M 的内存，而迭代器只需要几十个字节的空间。因为它并没有把所有元素装载到内存中，而是等到调用 next 方法时候才返回该元素（按需调用 call by need 的方式，本质上 for 循环就是不断地调用迭代器的 next 方法） 生成器yield 语句返回值，yeild 存在的函数为生成器函数 生成器本质上还是一个迭代器，唯一的区别在于实现方式不同 生成器函数调用时不会立刻返回，而是调用 next 方法时才会返回 解释型语言和编译型语言编译型（需要编译器）：编译型语言执行速度快，不依赖语言环境运行，跨平台差，如 C&#x2F;C++、Go 执行速度快，调试麻烦 解释型（需要解释器）：解释型跨平台好，一份代码，到处使用，缺点是执行速度慢，依赖解释器运行，如 Python、JAVA 执行速度慢，调试方便 函数参数传递引用传递 闭包函数内部有一个内嵌函数内嵌函数引用外部函数的变量外部函数的返回值是内嵌函数 lambda 函数匿名函数 可以包含任意数量的参数，但是只能有一个执行操作的语句 lambda x：x = x + 1 装饰器为已经存在的对象添加额外的功能 执行函数后的清除功能 执行函数前的预备功能 引入日志（我理解的是：函数功能运行前日志记录） 深拷贝和浅拷贝浅拷贝： 123456789101112list = [[1, 2], &#x27;he&#x27;]list2 = list.copy()对于可变对象：list[0][0] = 2list2也会改变对于不可变对象：list[1] = &#x27;be&#x27;list2 不会改变可变对象：list dic set 不可变对象：number string tuple 深拷贝： 1234list = [[1, 2], &#x27;he&#x27;]list2 = list.deepcopy()无论list如何变化 list2不变 python 实现多线程Python 有一个名为 Global Interpreter Lock（GIL）的结构。GIL 确保每次只能执行一个“线程”。一个线程获取 GIL 执行相关操作，然后将 GIL 传递到下一个线程。 虽然看起来程序被多线程并行执行，但它们实际上只是轮流使用相同的 CPU 核心。 所有这些 GIL 传递都增加了执行的开销。这意味着多线程并不能让程序运行的更快。 协程简单点说协程是进程和线程的升级版，进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态。 python 中的单下划线和双下划线双下划线”变量或函数“，是 Python 内部为了防止和用户自定义命名冲突。 双下划线”变量或函数”，解析器用_classnamefoo 来代替这个名字，以区别和其他类相同的命名,它无法直接像公有成员一样随便访问，通过对象名._类名__xxx 这样的方式可以访问。 单下划线”_变量或函数”，是指定变量私有，不能通过 from module import *导入，其他地方和公有一样。 python2 和 python3 的区别 print 函数python2 print 语句 python3 print 函数 unicode Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。现在， 在 Python 3，我们最终有了 Unicode (utf-8) 123456789python2:&gt;&gt;&gt; str = &quot;我爱北京天安门&quot;&gt;&gt;&gt; str&#x27;\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe5\\x8c\\x97\\xe4\\xba\\xac\\xe5\\xa4\\xa9\\xe5\\xae\\x89\\xe9\\x97\\xa8&#x27;python3:&gt;&gt;&gt; str = &quot;我爱北京天安门&quot;&gt;&gt;&gt; str&#x27;我爱北京天安门&#x27; 除法运算python2 除法整数返回整数 浮点数返回浮点数python3 除法整数也返回浮点数 异常捕获异常的语法由 except exc, var 改为 except exc as var。使用 except (exc1, exc2) as var 可以同时捕获多种类别的异常。 xrange range 和 xrange 都是在循环中使用，输出结果一样。 range 返回的是一个 list 对象，而 xrange 返回的是一个生成器对象(xrange object)。 xrange 则不会直接生成一个 list，而是每次调用返回其中的一个值，内存空间使用极少，因而性能非常好。 python tuple 和 list 和 set 的区别tuple 是不可变数据类型。 tuple 不可以删除，修改元素 不可以添加，没有 append，insert 方法。 可以用+&#x3D;添加（相当于创建新对象，赋值） set 是保证集合内没有重复元素，可以用 add 添加，是可变数据类型 python 垃圾回收机制（GC 机制）内存管理参考 访问变量可以通过直接引用和间接引用来使用： 1234直接引用：x = 10 # 使用x就可以得到值间接引用：l = [x, 2] 通过访问l[0]也可以间接访问到值 垃圾回收机制（简称 GC）是 python 解释器自带的一种机制，专门用来回收没有绑定任何引用（直接引用和间接引用）的变量值所在的内存空间 引用计数-存在栈中变量回收后，堆中的️值依旧存在，且无法通过变量名访问它的问题 解决方法：标记-清除：扫描栈，能通过栈中变量直接或者间接访问到的对象都标记为存活对象，清除非存活对象 改进：分代回收：分代指的是根据存活时间来划分不同等级（也就是不同的代）,假如分成了幼儿代，青春代，中年代，老年代五个代，一个变量一开始假如在幼儿代，一段时间内被扫描了三次，依然有绑定关系，此时就把这个变量移入更加高级的青春代，扫描的时候会优先扫描幼儿代，然后再扫描更高级的代 GIL 原理GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。 在 IO 操作等可能会引起阻塞的 system call 之前,可以暂时释放 GIL,但在执行完毕后,必须重新获取 GIL Python 3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python 2.x，tickets 计数达到 100 init和new的区别参考 init用于初始化类对象，而new的只想还在 init 前 init 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。 new 通常用于控制生成一个新实例的过程。它是类级别的方法 new 主要的作用是继承一些不可变的 class 时(比如 int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"System_Server进程注入开发","slug":"Study/实习/System_Server进程注入开发","date":"2023-08-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/15/Study/实习/System_Server进程注入开发/","link":"","permalink":"https://beichen.link/2023/08/15/Study/%E5%AE%9E%E4%B9%A0/System_Server%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%BC%80%E5%8F%91/","excerpt":"","text":"ptrace通过 ptrace 函数可以跟踪进程，修改被跟踪进程的内存和寄存器值 在注入之前,简单介绍一下需要用到的 ptrace 的部分功能 1.PTRACE_ATTACH attach 到其他进程上,pid 为目标进程的 id ptrace(PTRACE_ATTACH, pid, NULL, 0) 2.PTRACE_DETACH 脱离 attach 的进程,pid 为目标进程的 id ptrace(PTRACE_DETACH, pid, NULL, 0) 3.PTRACE_POKETEXT 向对应进程写入数据,pid 为目标进程 id,dest 为地址,val 为写入的数据 ptrace(PTRACE_POKETEXT, pid, dest, val) 4.PTRACE_PEEKTEXT 读取对应进程的数据,pid 为目标进程 id,dest 为地址 ptrace(PTRACE_PEEKTEXT, pid, dest, 0) 5.PTRACE_SETREGS&#x2F;PTRACE_GETREGS 设置&#x2F;读取寄存器,pid 为目标进程地址 ptrace(PTRACE_SETREGS, pid, NULL, regs) 6.PTRACE_CONT 继续执行,pid 为目标进程地址 ptrace(PTRACE_CONT, pid, 0, signal) 进程注入的实现 Step 1 attach 到目标进程 ：ptraceAttach(pid);这里其实不光要 attach 到目标进程,还得保存目前寄存器状态,为了一会儿恢复现场. 1234567struct pt_regs currentRegs, orgRegs;// 获取远程进程的寄存器值if (ptraceGetregs(pid, &amp;currentRegs) == -1) &#123; perror(&quot;get reg error&quot;);&#125;//然后将其保存到 orgRegs 中memcpy(&amp;orgRegs, &amp;currentRegs, sizeof(currentRegs)); Step 2 在目标进程中调用 mmap 申请一段空间这里申请空间就是用来在后续调用 dlopen 和 dlsym 时写入参数用的,这一步执行完以后,就可以在进程中看到自己申请到的空间了 为了调用 mmap 函数，我们需要获取远程进程中的 mmap 函数地址，可通过计算系统库基地址-偏移得出 同一系统库 (例如 mmap 所在的系统库 libc.so) 的 mmap 地址与 libc.so 基地址的偏移量，在当前进程和远程进程 (被注入进程) 中是相同的 所以，只要获取到当前进程的 libc 基地址 (假设用变量 local_handle 表示)、当前进程 mmap 地址 (local_addr)、远程进程 libc.so 基地址 (remote_handle)，即可根据如下公式获取远程 mmap 地址 (remote_addr)： remote_addr = local_addr + remote_handle - local_handle 接下来首先获取 libc.so 基地址 (local_handle&#x2F;remote_handle) 和当前进程 mmap 函数地址 (local_addr)。 获取 libc.so 基地址获取进程中 libc.so 模块基地址 (local_handle&#x2F;remote_handle) 的方法为: 即在&#x2F;proc&#x2F;{pid}&#x2F;maps 路径中找到模块名，其中 pid 替换为目标进程的进程 id,对应的行首地址即为模块的基地址。如果在当前进程中读取当前进程的模块基地址，可读取&#x2F;proc&#x2F;self&#x2F;maps 路径下的模块地址即可。通过该方法可求得 local_handle&#x2F;remote_handle 的值。 获取当前进程 mmap 函数地址获取当前进程的 mmap 函数地址，有两种方法： 方法一：通过 dlopen&#x2F;dlsym 的方式获取，如下图： 方法二：根据 elf 文件内容格式获取符号相对基地址的偏移量，加上当前进程中 libc.so 基地址，即可求得当前进程函数地址。 申请操作123456789101112131415long parameters[6]; parameters[0] = 0; // 设置为NULL表示让系统自动选择分配内存的地址 parameters[1] = 0x1000; // 映射内存的大小 parameters[2] = PROT_READ | PROT_WRITE | PROT_EXEC; // 表示映射内存区域可读可写可执行 parameters[3] = MAP_ANONYMOUS | MAP_PRIVATE; // 建立匿名映射 parameters[4] = -1; // 若需要映射文件到内存中，则为文件的fd parameters[5] = 0; //文件映射偏移量 if (ptraceCallWrapper(pid, &quot;mmap&quot;, remoteMmapAddr, parameters, 6, &amp;currentRegs) &lt; 0) &#123; printf(&quot;call target mmap error\\n&quot;); return -1; &#125; uint8_t *mmapBase = (uint8_t *) ptraceRetval(&amp;currentRegs);printf(&quot;mmap ret is %x\\n&quot;, mmapBase); ptraceCallWrapper 实际上执行了 ptrace_call 函数，ptrace_call 首先会将调用的函数 (mmap) 所需的参数 (parameters) 从右到左压入堆栈，同时写入返回地址到对应寄存器中，并同步修改栈顶指针。将堆栈和寄存器值都设置完毕后，通过调用 ptrace 函数，并传入参数 PTRACE_CONT 使 mmap 函数得以执行 Step 3 将注入的 so 路径写入目标进程地址中1ptrace_write_data(pid, mmapBase, hookSoPath, strlen(hookSoPath) + 1); Step 4 调用 dlopen,加载 hooker.so1234567parameters[0] = (long) mmapBase;parameters[1] = RTLD_NOW | RTLD_GLOBAL;//通过ptrace调用if (ptraceCallWrapper(pid, &quot;dlopen&quot;, remoteDlopen, parameters, 2, &amp;currentRegs) &lt; 0) &#123; printf(&quot;call target dlopen error&quot;); return -1;&#125; 这里就将 hooker.so 加载上去了,执行 cat proc&#x2F;pid&#x2F;map 就能看到 Step 5 调用 dlsym,获取 hooker.so 中的 hookentry 符号12345678910111213const char *targetFuncName = &quot;hookEntry&quot;; ptraceWriteData(pid, mmapBase + FUNCTION_NAME_ADDR_OFFSET, targetFuncName, strlen(targetFuncName) + 1); parameters[0] = (long) targetSoHandle; parameters[1] = (long) (mmapBase + FUNCTION_NAME_ADDR_OFFSET); if (ptraceCallWrapper(pid, &quot;dlsym&quot;, targetDlsymAddr, parameters, 2, &amp;currentRegs) &lt; 0) &#123; printf(&quot;call target dlsym error\\n&quot;); return -1; &#125; void *hookFuncAddr = (void *) (ptraceRetval(&amp;currentRegs)); printf(&quot;hook func addr is %x\\n&quot;, ptraceRetval(&amp;currentRegs)); Step 6 调用 hookentry1234if (ptraceCallWrapper(pid, targetFuncName, hookFuncAddr, parameters, 0, &amp;currentRegs) &lt; 0) &#123; printf(&quot;call target %s error&quot;, targetFuncName); return -1; &#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"Fake dlopen","slug":"Study/实习/注入开发之fake_dlopen","date":"2023-08-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/15/Study/实习/注入开发之fake_dlopen/","link":"","permalink":"https://beichen.link/2023/08/15/Study/%E5%AE%9E%E4%B9%A0/%E6%B3%A8%E5%85%A5%E5%BC%80%E5%8F%91%E4%B9%8Bfake_dlopen/","excerpt":"","text":"Android 对 dlopen 和 dlsym 的限制hook 的第一步是拿到被 hook 方法的地址。获取方法地址的常规方法是使用 dlopen() 和 dlsym()，但 Android 平台上对这两个方法的使用有限制，如何突破这个限制呢？ Android 7.0 及以上版本对 dlopen() 和 dlsym() 函数的使用有限制。System.load() 和 System.loadLibrary() 是基于这两个函数实现的，所以也存在同样限制。 测试中发现无论是调用 System.load() 还是 System.loadLibrary() 加载 libart.so (系统的 so 库，非公开 API) 均会导致以下异常： 1234567E/AndroidRuntime: FATAL EXCEPTION: main Process: com.sunmoonblog.cmdemo, PID: 8432 java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;/system/lib/libart.so&quot; needed or dlopened by &quot;/system/lib64/libnativeloader.so&quot; is not accessible for the namespace &quot;classloader-namespace&quot; at java.lang.Runtime.load0(Runtime.java:928) at java.lang.System.load(System.java:1624) 异常信息很明确：第三方应该不应当尝试使用非公开的方法。当然，官方对此早有说明。官方的作出上述限制的理由是只允许应用访问公开的 API(无论是 Java 层还是 Native 层)，不允许访问非公开的方法，以提升应用的稳定性。 系统私有库指的是，存放在 android 系统&#x2F;system&#x2F;lib&#x2F;和&#x2F;vendor&#x2F;lib 下面，但是 Android NDK 中没有公开 API 的 lib 库。 从 Android N 开始（SDK &gt;&#x3D; 24），通过 dlopen 打开系统私有库，或者 lib 库中依赖系统私有库，都会产生异常，甚至可能导致 app 崩溃。 曾经的美好在以前，在 ndk 层面，我们是可以使用一些 hack 的手段得到系统的私有 api 的。 比如，你想使用虚拟机中的一些内部符号，在 N 以下版本，你可以这么搞 12void *handle = dlopen(&quot;libart.so&quot;, RTLD_NOW);void *originFunc = dlsym(handle, &quot;_ZNK3art6Thread13DumpJavaStackERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE&quot;); 这样你就能得到 art::Thread::DumpJavaStack 的函数指针，然后愉快地调用它了。 晴天霹雳但是到了 N 以后， 1234void *handle = dlopen(&quot;libart.so&quot;, RTLD_NOW);// 没问题，返回了 handle 指针。void *originFunc = dlsym(handle, &quot;_ZNK3art6Thread13DumpJavaStackERNSt3__113basic_ostreamIcNS1_11char_traitsIcEEEE&quot;);// 失败！得到的 originFunc 为空！ 这就很奇怪了，我们能够得到 handle 指针，就说明 libart.so 是找到了。但是为什么 libart.so 中却没有找到 art::Thread::DumpJavaStack 的符号呢？ 看一下内存映射表，我们发现了一个有趣的东西 难怪，我们知道 dlopen 参数为 libart.so 的话，系统会先找到&#x2F;system&#x2F;fake-libs64&#x2F;libart.so，而不是&#x2F;system&#x2F;lib64&#x2F;libart.so。 而&#x2F;system&#x2F;fake-libs64&#x2F;libart.so 又是什么鬼？从名字上看，就知道他是个假的 libart。在系统源码文件 art&#x2F;libart_fake&#x2F;README.md 中，我们找到了对他的解释， 这就是为了以防你们这些图谋不轨（misbehaving）的 APP 们做一些奇怪的事而专门设的套啊！ 只要你自己的 lib 库依赖了 libart.so 或者试图打开 libart.so，在 linker 查找 libart.so 时，因为 fake-libs 路径被设置在了查找路径表的靠前处，就会先找到&#x2F;system&#x2F;fake-libs64&#x2F;libart.so，而不是真正的&#x2F;system&#x2F;lib64&#x2F;libart.so。而这个&#x2F;system&#x2F;fake-libs64&#x2F;libart.so 的内容基本上的空的（art&#x2F;libart_fake&#x2F;fake.cc），所以在它里面当然什么符号都找不到啦~ 既然如此，那我们在 dlopen 中直接指定 lib 的绝对路径总行了吧？像这样： 1void *handle = dlopen(&quot;/system/lib64/libart.so&quot;, RTLD_NOW); 可是很遗憾，它报了一个错： 也就是说，你被允许访问的路径（包含 ld_library_paths、default_library_paths、permitted_paths）只有 所以，试图访问&#x2F;system&#x2F;lib64&#x2F;下的 libart.so 当然是不行的啦。 真是魔高一尺道高一丈啊。 至此，我们算是知道了 Google 封杀在 ndk 中访问系统私有库的方法。本质是在 linker 中加入一系列校验机制来做限制。linker 作为最基础的 lib 库链接器，所有链接行为都会被限制住。 解决方案如何突破官方的限制呢？Nougat_dlfunctions 提供了一个不错的解决方案，可以完美避开官方限制。 Android 限制的只是 dlopen 这个途径，而我们访问内存是随心所欲的, 方法就是通过内存映射表找到 libart.so 的真实起始位置： 然后在加载地址起始位置手动解析 libart.so 的 elf 格式，提取出所需符号的位置信息。相当于你自己实现 linker 原本的查找逻辑。 当然，这种遍历内存解析 elf 的实现是比较复杂的。因此，这一次 Google 算是封死了一大波底层 hack 的手段。 Nougat_dlfunctionsNougat_dlfunctions 是这样介绍自己的： A hack for loading system libraries in Android Nougat where dlopen() has been disabled by some wise guys. 它的两个主要 API 如下。形式上跟 dlopen() 和 dlsysm() 完全一致，所以用起来非常简单。 12void *fake_dlopen(const char *libpath, int flags);void *fake_dlsym(void *handle, const char \\*name); fake_dlopen(), 跟 dlopen() 一样，用于 load and link a dynamic library or bundle fake_dlsym(), 跟 dlsym() 一样，用于 get address of a symbol 原理分析Nougat_dlfunctions 库的原理本身并不复杂，但由于涉及到 ELF 文件格式，其中的技术细节理解起来还是要花些时间。 要保证 fake_dlopen() 和 fake_dlsym() 函数可正常运行有一个前提：so 文件本身已经被加载到当前进程。 更准确地说, Nougat_dlfunctions 库并不能主动加载系统库&#x2F;非公开的库，而是从已加载的系统库&#x2F;非公开库中找到感兴趣的方法地址。 比如，以 hook Bitmap 为例，可以利用这个库绕开 Android 系统限制拿到目标方法的地址。 首先，fake_dlopen() 读取 &#x2F;proc&#x2F;self&#x2F;maps 文件。这个文件记录了当前进程的内存布局。 address - 进程地址空间的起始地址 permissions - 访问权限 pathname - 如果该区域是从文件映射来的，pathname 为文件名 知道进程的内存布局后，不难从其中获取到指定路径的 so 文件的基址。基址保存在 load_addr。 然后，Nougat_dlfunctions 调用 mmap() 对该 so 文件进行内存映射，映射结果为 elf 并对其进行解析。elf 数据结构类型是 Elf_Ehdr。Elf_Ehdr 定义如下： 简单来说，一个 ELF 文件由一个 Header 及 多个 Section 组成。每个 Section 也有自己的 Section Header，其类型为 Elf32_Shdr。Elf32_Shdr 定义如下： Nougat_dlfunctions 处理 elf 的方式相当简单粗暴：找到关键信息后直接拷贝一份并保存下来。关键信息包括 .dynsym，.dynstr 等等, 具体可以对照着代码看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void *fake_dlopen(const char *libpath, int flags)&#123; FILE *maps; char buff[256]; struct ctx *ctx = 0; off_t load_addr, size; int k, fd = -1, found = 0; void *shoff; Elf_Ehdr *elf = MAP_FAILED; ... ctx = (struct ctx *) calloc(1, sizeof(struct ctx)); if(!ctx) fatal(&quot;no memory for %s&quot;, libpath); ctx-&gt;load_addr = (void *) load_addr; shoff = ((void *) elf) + elf-&gt;e_shoff; for(k = 0; k &lt; elf-&gt;e_shnum; k++, shoff += elf-&gt;e_shentsize) &#123; Elf_Shdr *sh = (Elf_Shdr *) shoff; log_dbg(&quot;%s: k=%d shdr=%p type=%x&quot;, __func__, k, sh, sh-&gt;sh_type); switch(sh-&gt;sh_type) &#123; case SHT_DYNSYM: if(ctx-&gt;dynsym) fatal(&quot;%s: duplicate DYNSYM sections&quot;, libpath); /* .dynsym */ ctx-&gt;dynsym = malloc(sh-&gt;sh_size); if(!ctx-&gt;dynsym) fatal(&quot;%s: no memory for .dynsym&quot;, libpath); memcpy(ctx-&gt;dynsym, ((void *) elf) + sh-&gt;sh_offset, sh-&gt;sh_size); ctx-&gt;nsyms = (sh-&gt;sh_size/sizeof(Elf_Sym)) ; break; case SHT_STRTAB: if(ctx-&gt;dynstr) break; /* .dynstr is guaranteed to be the first STRTAB */ ctx-&gt;dynstr = malloc(sh-&gt;sh_size); if(!ctx-&gt;dynstr) fatal(&quot;%s: no memory for .dynstr&quot;, libpath); memcpy(ctx-&gt;dynstr, ((void *) elf) + sh-&gt;sh_offset, sh-&gt;sh_size); break; case SHT_PROGBITS: if(!ctx-&gt;dynstr || !ctx-&gt;dynsym) break; /* won&#x27;t even bother checking against the section name */ ctx-&gt;bias = (off_t) sh-&gt;sh_addr - (off_t) sh-&gt;sh_offset; k = elf-&gt;e_shnum; /* exit for */ break; &#125; &#125; ... return 0;&#125; ctx 的结构如下： 1234567struct ctx &#123; void *load_addr; void *dynstr; // 保存了 string table void *dynsym; // 保存了 dynamic linking table int nsyms; // 保存了 dynamic linking table 的条目大小 off_t bias; // ? 不清楚&#125;; 最后，根据指定的方法名在 ctx-&gt;dynsym (即之前保存的 dynamic linking table) 进行查找。代码如下： 1234567891011121314151617void *fake_dlsym(void *handle, const char *name)&#123; int k; struct ctx *ctx = (struct ctx *) handle; Elf_Sym *sym = (Elf_Sym *) ctx-&gt;dynsym; char *strings = (char *) ctx-&gt;dynstr; for(k = 0; k &lt; ctx-&gt;nsyms; k++, sym++) if(strcmp(strings + sym-&gt;st_name, name) == 0) &#123; /* NB: sym-&gt;st_value is an offset into the section for relocatables, but a VMA for shared libs or exe files, so we have to subtract the bias */ void *ret = ctx-&gt;load_addr + sym-&gt;st_value - ctx-&gt;bias; log_info(&quot;%s found at %p&quot;, name, ret); return ret; &#125; return 0;&#125; 如果方法名跟 dynamic linking table 中的某一项匹配上了，对应的方法地址可以这样计算出来：ctx-&gt;load_addr + sym-&gt;st_value - ctx-&gt;bias 看一个实际案例：hook Bitmap。假设我们感兴趣的方法名为 createBitmap， 这个方法在 system&#x2F;lib&#x2F;libandroid_runtime.so 中 应用启动后 Android 系统会为当前进程加载 libandroid_runtime.so proc&#x2F;self&#x2F;maps 中记录了当前进程的内存布局，其中包括 libandroid_runtime.so 获取 createBitmap() 方法地址流程： fake_dlopen() parse - 解析 proc&#x2F;self&#x2F;maps， 得到 libandroid_runtime.so 的基址 load_addr mmap - 将 libandroid_runtime.so mmap 映射成 elf copy - 从 elf 拷贝 .dynstr 和 .dynsym fake_dlsym() search - 在 .dynsym 查找 createBitmap 字符串对应的项 calculate - 如果第 4 步中查找成功，最后一步就是计算 createBitmap 方法的地址。计算规则： load_addr + sym-&gt;st_value - bias 参考：https://www.sunmoonblog.com/2019/06/04/fake-dlopen/","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"Bundle 风水","slug":"Study/Android漏洞/Bundle风水","date":"2023-08-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/15/Study/Android漏洞/Bundle风水/","link":"","permalink":"https://beichen.link/2023/08/15/Study/Android%E6%BC%8F%E6%B4%9E/Bundle%E9%A3%8E%E6%B0%B4/","excerpt":"","text":"Parcelable 接口Android 提供了独有的 Parcelable 接口来实现序列化的方法，只要实现这个接口，一个类的对象就可以实现序列化并可以通过 Intent 进行传输，Intent 也是一个 Parcelable 类，下面示例是 Parcelable 的典型用法。 123456789101112131415161718192021222324252627282930public class MyParcelable implements Parcelable &#123; private int mData; public int describeContents() &#123; return 0; &#125; public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(mData); &#125; public void readFromParcel(Parcel reply) &#123; mData = in.readInt(); &#125; public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() &#123; public MyParcelable createFromParcel(Parcel in) &#123; return new MyParcelable(in); &#125; public MyParcelable[] newArray(int size) &#123; return new MyParcelable[size]; &#125; &#125;; private MyParcelable(Parcel in) &#123; mData = in.readInt(); &#125; &#125; 其中，关键的 writeToParcel 和 readFromParcel 方法，分别调用 Parcel 类中的一系列 write 方法和 read 方法实现序列化和反序列化。 可序列化的 Parcelable 对象一般不单独进行序列化传输，需要通过 Bundle 对象携带。 Bundle 的内部实现实际是 Hashmap，以 Key-Value 键值对的形式存储数据。 例如， Android 中进程间通信频繁使用的 Intent 对象中可携带一个 Bundle 对象，利用 putExtra(key, value)方法，可以往 Intent 的 Bundle 对象中添加键值对(Key Value)。Key 为 String 类型，而 Value 则可以为各种数据类型，包括 int、Boolean、String 和 Parcelable 对象等等，Parcel 类中维护着这些类型信息。 下图是序列化后的数据在 Bundle 中 的简单示意图（注意对于 ByteArray 类型的 Value 还需要增加 value 长度的字段）： 另外，&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Parcel.java 中维护着各种数据类型在 Bundle 中的值分别是什么，下面是部分信息： 12345678910private static final int VAL_NULL = -1;private static final int VAL_STRING = 0;private static final int VAL_INTEGER = 1;private static final int VAL_MAP = 2;private static final int VAL_BUNDLE = 3;private static final int VAL_PARCELABLE = 4;private static final int VAL_SHORT = 5;private static final int VAL_LONG = 6;private static final int VAL_FLOAT = 7; 当所有数据都被序列化装载进 Bundle 后，接下来则需要依次在 Bundle 头部写入携带所有数据的长度、Bundle 魔数 (0x4C444E42) 和键值对的数量。下面是完整的 Bundle 简单结构图： 简单举个例子，我要传递一个 Bundle 对象携带 2 个键值对，分别是： 上述 MyParcelable 类对象（其具有 int 类型的成员变量 mData）； 以及一个 key-value 为 “CSDN”:”Tr0e” 的字符串键值对 ； 那么可以这么写： 1234567891011121314151617181920212223242526Bundle myBundle = new Bundle();// 相当于new 一个 parcelParcel bndlData = Parcel.obtain();Parcel pcelData = Parcel.obtain();//Bundle对象将携带的键值对数量为2pcelData.writeInt(2);//第一个键值对的key值，直接写入字符串，省略了key的长度pcelData.writeString(&quot;test&quot;);pcelData.writeInt(4); //value类型VAL_PACELABLE，4代表为对象pcelData.writeString(&quot;com.Tr0e.MyParcelable&quot;); //name of Class Loader，加载类pcelData.writeInt(1); //mData//写入第二个键值对，key为CSDN，直接写入字符串，省略了key的长度pcelData.writeString(&quot;CSDN&quot;);pcelData.writeInt(0); //VAL_STRING代表value类型为字符串pcelData.writeString(&quot;Tr0e&quot;); //value值int length = pcelData.dataSize();bndlData.writeInt(length); //Bundle对象携带的数据总长度bndlData.writeInt(0x4c444E42); //Bundle魔数bndlData.appendFrom(pcelData, 0, length);bndlData.setDataPosition(0);myBundle.readFromParcel(bndlData);Log.d(TAG, myBundle.toString()); 而反序列化过程则完全是一个对称的逆过程，将依次读入 Bundle 携带所有数据的长度、Bundle 魔数(0x4C444E42)、键值对。读键值对的时候，调用对象的 readFromParcel 方法，从 Bundle 读取相应长度的数据，重新构建这个对象。 前置知识：LaunchAnyWhere 漏洞这是一个 AccountManagerService 的漏洞，利用这个漏洞，我们可以任意调起任意未导出的 Activity，突破进程间组件访问隔离的限制。这个漏洞影响 2.3 ~ 4.3 的安卓系统。 普通应用（记为 AppA）去请求添加某类账户时，会调用 AccountManager.addAccount,然后 AccountManager 会去查找提供账号的应用（记为 AppB）的 Authenticator 类，调用 Authenticator.addAccount 方法；AppA 再根据 AppB 返回的 Intent 去调起 AppB 的账户登录界面。 关于 AccountManagerServiceAccountManagerService 同样也是系统服务之一，暴露给开发者的的接口是 AccountManager。该服务用于管理用户各种网络账号。这使得一些应用可以获取用户网络账号的 token，并且使用 token 调用一些网络服务。很多应用都提供了账号授权功能，比如微信、支付宝、邮件 Google 服务等等。 关于 AccountManager 的使用，可以参考 Launchanywhere 的 Demo：github.com&#x2F;stven0king&#x2F;…由于各家账户的登陆方法和 token 获取机制肯定存在差异，所以 AccountManager 的身份验证也被设计成可插件化的形式：由提供账号相关的应用去实现账号认证。提供账号的应用可以自己实现一套登陆 UI，接收用户名和密码；请求自己的认证服务器返回一个 token；将 token 缓存给 AccountManager。可以从“设置-&gt; 添加账户”中看到系统内可提供网络账户的应用： 如果应用想要出现在这个页面里，应用需要声明一个账户认证服务 AuthenticationService： 1234567891011&lt;service android:name=&quot;.AuthenticationService&quot; android:exported=&quot;true&quot; android:enabled=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accounts.AccountAuthenticator&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accounts.AccountAuthenticator&quot; android:resource=&quot;@xml/authenticator&quot; /&gt;&lt;/service&gt; 并在服务中提供一个 Binder: 1234567891011121314151617181920212223242526public class AuthenticationService extends Service &#123; private AuthenticationService.AccountAuthenticator mAuthenticator; private AuthenticationService.AccountAuthenticator getAuthenticator() &#123; if (mAuthenticator == null) mAuthenticator = new AuthenticationService.AccountAuthenticator(this); return mAuthenticator; &#125; @Override public void onCreate() &#123; mAuthenticator = new AuthenticationService.AccountAuthenticator(this); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.d(&quot;tanzhenxing33&quot;, &quot;onBind&quot;); return getAuthenticator().getIBinder(); &#125; static class AccountAuthenticator extends AbstractAccountAuthenticator &#123; /****部分代码省略****/ @Override public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException &#123; Log.d(&quot;tanzhenxing33&quot;, &quot;addAccount: &quot;); return testBundle(); &#125; &#125;&#125; 漏洞原理普通应用（记为 AppA）去请求添加某类账户时，会调用 AccountManager.addAccount,然后 AccountManager 会去查找提供账号的应用（记为 AppB）的 Authenticator 类，调用 Authenticator.addAccount 方法；AppA 再根据 AppB 返回的 Intent 去调起 AppB 的账户登录界面。 这个过程如图所示： 我们可以将这个流程转化为一个比较简单的事实： AppA 请求添加一个特定类型的网络账号 系统查询到 AppB 可以提供一个该类型的网络账号服务，系统向 AppB 发起请求 AppB 返回了一个 intent 给系统，系统把 intent 转发给 appA AccountManagerResponse 在 AppA 的进程空间内调用 startActivity(intent)调起一个 Activity;并且 AccountManagerResponse 是 FrameWork 中的代码， AppA 对这一调用毫不知情。 这种设计的本意是，AccountManagerService 帮助 AppA 查找到 AppB 账号登陆页面，并呼起这个登陆页面。而问题在于，AppB 可以任意指定这个 intent 所指向的组件，AppA 将在不知情的情况下由 AccountManagerResponse 调用起了一个 Activity. 如果 AppA 是一个 system 权限应用，比如 Settings，那么 AppA 能够调用起任意 AppB 指定的未导出 Activity。 如何利用上文已经提到过，如果假设 AppA 是 Settings，AppB 是攻击程序。那么只要能让 Settings 触发 addAcount 的操作，就能够让 AppB launchAnyWhere。而问题是，怎么才能让 Settings 触发添加账户呢？如果从“设置-&gt;添加账户”的页面去触发，则需要用户手工点击才能触发，这样攻击的成功率将大大降低，因为一般用户是很少从这里添加账户的，用户往往习惯直接从应用本身登陆。 不过现在就放弃还太早，其实 Settings 早已经给我们留下触发接口。只要我们调用 com.android.settings.accounts.AddAccountSettings，并给 Intent 带上特定的参数，即可让 Settings 触发 launchAnyWhere： 12345678Intent intent1 = new Intent();intent1.setComponent(new ComponentName(&quot;com.android.settings&quot;, &quot;com.android.settings.accounts.AddAccountSettings&quot;));intent1.setAction(Intent.ACTION_RUN);intent1.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);String authTypes[] = &#123;&quot;自己的账号类型&quot;&#125;;intent1.putExtra(&quot;account_types&quot;, authTypes);AuthenticatorActivity.this.startActivity(intent1); 这个过程如图 Step 0 所示： 主要的攻击对象还是应用中未导出的 Activity，特别是包含了一些 intenExtra 的 Activity 利用这种类型的漏洞，可以绕过 pin 码认证界面，直接重置手机系统 pin 码，或者绕过原有的锁屏校验，直接重置手机的锁屏密码。 修复安卓 4.4 已经修复了这个漏洞，检查了 Step3 中返回的 intent 所指向的 Activity 和 AppB 是否是有相同签名，避免了 luanchAnyWhere 的可能。 因为 AppA 是根据 AppB 返回的 Intent 去调起 AppB 的账户登录界面，应该只能访问 AppB 的 Activity 这个补丁在当时是没什么问题，但是等到 2017 年，有海外的研究人员在一份恶意样本中发现，可以利用 Parcelable 反序列化绕过这个补丁，由于 Google 的补丁是在 system_server 中检查 Intent，并且又通过 AIDL 传给 Settings 之后启动界面，这其中跨越了进程边界，也就涉及到两次次序列化和反序列化的过程，那么我们如果通过 Parcelable 反序列化漏洞的字节错位，通过精确的布局，使得 system_server 在检查 Intent 时找不到这个 Intent，而在错位后 Settings 却刚好可以找到，这样就可以实现补丁的绕过并再次实现 LaunchAnyWhere，研究人员将发现的这种漏洞利用方式命名为 Bundle mismatch。 CVE-2017-13288漏洞利用CVE-2017-13288 漏洞出现在 PeriodicAdvertisingReport 类中，对比 writeToParcel 和 readFromParcel 函数： 1234567891011121314151617181920212223242526// /frameworks/base/core/java/android/bluetooth/le/PeriodicAdvertisingReport.java@Overridepublic void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(syncHandle); dest.writeLong(txPower); // long dest.writeInt(rssi); dest.writeInt(dataStatus); if (data != null) &#123; dest.writeInt(1); // flag dest.writeByteArray(data.getBytes()); &#125; else &#123; dest.writeInt(0); &#125;&#125;private void readFromParcel(Parcel in) &#123; syncHandle = in.readInt(); txPower = in.readInt(); // int rssi = in.readInt(); dataStatus = in.readInt(); if (in.readInt() == 1) &#123; // flag data = ScanRecord.parseFromBytes(in.createByteArray()); &#125;&#125; 在对 txPower 这个 int 类型成员变量进行操作时，写入为 long，读出却为 int，因此经历一次不匹配的序列化和反序列化后 txPower 之后的成员变量都会错位 4 字节。 那么如何借此错位来绕过 checkKeyIntent 检查并实现 LaunchAnyWhere 提权攻击呢？请看下图： 第一次序列化：在包含 Autherticator 类 App 中构造恶意 Bundle，其携带两个键值对。第一个键值对携带一个 PeriodicAdvertisingReport 对象，并将恶意 KEY_INTENT 的内容放在 data 这个 ByteArray 类型的成员中；第二个键值可任意写入一个键值对。注意由于这一次序列化需要精确控制内容，我们不希望发生不匹配（下文会解释），因此将 PeriodicAdvertisingReport 对象 writeToParcel 时，要和其 readFromParcel 对应。也就是说，toPower 在写入时数据类型应该是 int，而不是 long(按照类定义应该是写入 long)。 第一次反序列化：在 system_server 反序列化过程中生成了 PeriodicAdvertisingReport 对象，且 syncHandle、txPower、rssi、dataStatus 这些 int 型的数据均通过 readInt 读入为 1，同时由于接下来的 flag 也为 1，将 KEY_INTENT 的内容读入到 data 中。此时，KEY_INTENT 作为第一个键值对的 value，而不是一个单独的键值对，因此可以逃避 checkKeyIntent 检查。到这里来说，一切过程正常，除了以 int 写入 txPower 第二次序列化：然后 system_server 将这个 Bundle 序列化，此时 txPower 变量使用 writeLong(这个时候是系统自动按照类原生定义操作) 写入 Bundle，因此会占据 8 个字节，前 4 字节为 1，后 4 字节为 0，而 txPower 后面的内容则原封不动地写入。 第二次反序列化：最后在 Settings 反序列化过程中，读出 txPower 变量调用的是 readInt() 方法，因此 txPower 读出为 1，后面接着 rssi 却读出为 0，这里发生了四字节的错位。接下来 dataStatus 读入为 1，flag 读入为 1，所以 Settings 认为后面还有 ByteArray 类型的 data，但读入的长度域却为 1，因此把后面 KEY_INTENT 的 4 字节 length（ByteArray 4 字节对齐）当做 data。至此，第一个键值对反序列化完毕。最后，原本第一次序列化过程中位于 ByteArray 数组中的恶意 KEY_INTENT 经过两轮序列化与反序列化后，成功作为一个新的独立键值对堂而皇之地出现了 最终的结果就是取得 Settings 应用的 system 权限发送任意 intent，实现启动任意 Activity 的能力。 【注意】由于 system_server 会进行恶意 Intent 的检查，所以第一次反序列化后我们传递的 Bundle 数据不能被解析出恶意 Intent 的键值对（checkKeyIntent 函数进行签名检查时会不通过）关键是通过第二次序列化与反序列化时发生错位、进而在 Settings 中暴露出恶意 Intent。 具体的 poc 程序参见： https://blog.csdn.net/weixin_39190897/article/details/128058136 修复方法Google 提出了一种简单粗暴的缓释方案，即直接从 Bundle 类中下手。虽然 Bundle 本身是 ArrayMap 结构，但在反序列化时候即便只需要获取其中一个 key，也需要把整个 Bundle 反序列化一遍。这其中的主要原因在于序列化数据中每个元素的大小是不固定的，且由元素的类型决定，如果不解析完前面的所有数据，就不知道目标元素在什么地方。 为此在 21 年左右，AOSP 中针对 Bundle 提交了一个称为 LazyBundle(9ca6a5) 的 patch。其主要思想为针对一些长度不固定的自定义类型，比如 Parcelable、Serializable、List 等结构或容器，会在序列化时将对应数据的大小添加到头部。这样在反序列化时遇到这些类型的数据，可以仅通过检查头部去选择性跳过这些元素的解析，而此时 sMap 中对应元素的值会设置为 LazyValue，在实际用到这些值的时候再去对特定数据进行反序列化。 这个 patch 可以在一定程度上缓释针对 Bundle 风水的攻击，而且在提升系统健壮性也有所助益，因为即便对于损坏的 Parcel 数据，如果接收方没有使用到对应的字段，就可以避免异常的发生。对于之前的 Bundle 解析策略，哪怕只调用了 size 方法，也会触发所有元素的解析从而导致异常。 在这个 patch 中 unparcel 还增加了一个 boolean 参数 itemwise，如果为 true 则按照传统方式解析每个元素，否则就会跳过 LazyValue 的解析。 使用 appshark：https://www.anquanke.com/post/id/282588","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android漏洞","slug":"Android漏洞","permalink":"https://beichen.link/tags/Android%E6%BC%8F%E6%B4%9E/"}]},{"title":"FakeLocation原理及重打包 ( 一 )","slug":"Study/实习/FakeLocation分析","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/10/Study/实习/FakeLocation分析/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E5%AE%9E%E4%B9%A0/FakeLocation%E5%88%86%E6%9E%90/","excerpt":"","text":"fakelocation 重打包及原理一 结论在 Android 系统中，获取地理位置信息需调用 Android 系统的位置服务，而位置服务运行在包含了大量系统服务程序的 system_server 进程中，地理位置信息服务程序在 system_server 中的服务名为：LocationManagerService。 Fake Location Hook 了 LocationManagerService 服务中的相关函数。当 App 向 LocationManagerService 发起获取地理位置信息请求时，被劫持的 LocationManagerService 向 App 返回预先设置的地理位置信息，通过这种方式完成地理位置信息篡改。 这也是 Fake Location 的特别之处。不同于市面上传统的改定位工具，通过劫持相关 App（将定位信息注入到目标 App）实现篡改定位，Fake Location 则是直接劫持“系统位置服务”，因不在目标应用进程空间，更加隐蔽而难以检测。 由于 FakeLocation 自签名验证较为复杂，现在还不具备对 APP 做重打包的能力，故采取其他办法，使用 magisk 的相关模块达到改包名类似的效果。 经过验证，通过使用 magisk、Lsposed 的相关模块就能屏蔽掉美团 APP 的应用列表获取功能，将 FakeLocation 的命中标签从 3 减至 1，命中的逻辑应该是检测了 FakeLocation 运行时的 so 相关 二 逆向分析过程1 脱壳过程首先脱壳，frida-dexdump 搞定,但发现脱壳不完全，始终差一部分。 frida_dump 也是脱不完全：https://github.com/lasting-yang/frida_dump 老工具 drizzleDumper 根本跑不完，1w+ dex 文件了 vmos 上的反射大师、ditor3.5、fdex2 都试过了，能脱，但是应该都脱不完全（因为没搜到 umeng） 接下来尝试 tweakme 能不能重打包,pixel3 打开卡死，自已手机及 vmos 安装后显示主界面后闪退 反编译后的代码很多混淆 2 签名验证分析mt、nt 管理器、太极均无法过掉签名验证 发现 libsafety.so 里的 sq 函数有签名验证的功能, java 层会调用 sq 函数 而且 libsafety.so 的 JNI_Onload 函数里会判断 sq 的返回结果，如果是-1 就会 kill 进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int __fastcall sq(JNIEnv *a1)&#123; int v2; // r0 void *v3; // r6 jclass v4; // r9 jclass v5; // r10 jmethodID v6; // r0 int v7; // r8 jmethodID v8; // r6 jstring v9; // r5 void *v10; // r11 int v11; // r5 _jfieldID *v12; // r0 void *v13; // r10 jobject v14; // r9 jobject v15; // r11 jmethodID v16; // r0 void *v17; // r8 const char *v18; // r5 const char *v19; // r6 jclass v21; // [sp+4h] [bp-3Ch] void *v22; // [sp+8h] [bp-38h] void *v23; // [sp+Ch] [bp-34h] void *v24; // [sp+10h] [bp-30h] void *v25; // [sp+14h] [bp-2Ch] void *v26; // [sp+18h] [bp-28h] jclass v27; // [sp+1Ch] [bp-24h] jclass v28; // [sp+20h] [bp-20h] v2 = j_getGlobalContext(); if ( !v2 ) return -2; v3 = (void *)v2; v4 = (*a1)-&gt;FindClass(a1, &quot;android/content/Context&quot;); v5 = (*a1)-&gt;FindClass(a1, &quot;android/content/pm/PackageManager&quot;); v28 = (*a1)-&gt;FindClass(a1, &quot;android/content/pm/PackageInfo&quot;); v27 = (*a1)-&gt;FindClass(a1, &quot;android/content/pm/Signature&quot;); v6 = (*a1)-&gt;GetMethodID(a1, v4, &quot;getPackageManager&quot;, &quot;()Landroid/content/pm/PackageManager;&quot;); v26 = v3; v7 = _JNIEnv::CallObjectMethod(a1, v3, v6); v8 = (*a1)-&gt;GetMethodID(a1, v5, &quot;getPackageInfo&quot;, &quot;(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;&quot;); v9 = (*a1)-&gt;NewStringUTF(a1, &quot;com.lerist.fakelocation&quot;); v10 = (void *)_JNIEnv::CallObjectMethod(a1, v7, v8); if ( ((int (__fastcall *)(JNIEnv *))(*a1)-&gt;ExceptionCheck)(a1) &amp;&amp; ((*a1)-&gt;ExceptionClear(a1), v9 = (*a1)-&gt;NewStringUTF(a1, &quot;assenti-com.lerist.fakelocation&quot;), v10 = (void *)_JNIEnv::CallObjectMethod(a1, v7, v8), ((int (__fastcall *)(JNIEnv *))(*a1)-&gt;ExceptionCheck)(a1)) ) &#123; (*a1)-&gt;ExceptionClear(a1); v11 = -1; &#125; else &#123; v25 = v4; v22 = v9; v23 = (void *)v7; v24 = v5; v12 = (_jfieldID *)((int (__fastcall *)(JNIEnv *, jclass, const char *, const char *, int))(*a1)-&gt;GetFieldID)( a1, v28, &quot;signatures&quot;, &quot;[Landroid/content/pm/Signature;&quot;, 64); v13 = v10; v14 = (*a1)-&gt;GetObjectField(a1, v10, v12); v15 = (*a1)-&gt;GetObjectArrayElement(a1, v14, 0); v21 = (*a1)-&gt;GetObjectClass(a1, v15); v16 = (*a1)-&gt;GetMethodID(a1, v21, &quot;toCharsString&quot;, &quot;()Ljava/lang/String;&quot;); v17 = (void *)_JNIEnv::CallObjectMethod(a1, v15, v16); v18 = (*a1)-&gt;GetStringUTFChars(a1, v17, 0); (*a1)-&gt;DeleteLocalRef(a1, v26); (*a1)-&gt;DeleteLocalRef(a1, v25); (*a1)-&gt;DeleteLocalRef(a1, v24); (*a1)-&gt;DeleteLocalRef(a1, v28); (*a1)-&gt;DeleteLocalRef(a1, v27); (*a1)-&gt;DeleteLocalRef(a1, v23); (*a1)-&gt;DeleteLocalRef(a1, v22); (*a1)-&gt;DeleteLocalRef(a1, v13); (*a1)-&gt;DeleteLocalRef(a1, v14); (*a1)-&gt;DeleteLocalRef(a1, v15); (*a1)-&gt;DeleteLocalRef(a1, v21); v19 = v18; v11 = strcmp(v18, RELEASE_SIGN); // 签名值写死在so文件里 (*a1)-&gt;ReleaseStringUTFChars(a1, v17, v19); (*a1)-&gt;DeleteLocalRef(a1, v17); if ( v11 ) v11 = -1; &#125; return v11;&#125; hook libc 的 kill 函数，发现确实是这样 但是用 tweakMe patch 后的 apk，sq 返回值正常为 0，猜想可能 tweakMe 的签名重定向起作用了 为了验证，hook 了 strcmp 函数，发现比对结果一样，说明就是 tweakMe 签名重定向，这样的话 libsafety.so 应该已经过掉了 assets 目录下的其他 so 文件，很多也有 sq 函数，同样的实现 jadx 打开脱壳的 dex 文件，显示不全，日志报错是因为 dex 的 checksum 不对，解决办法就是不开启 jadx 的 dex checksum 验证：https://github.com/skylot/jadx/issues/1525 根据网上帖子的介绍，一个 fakelocation 的老版本有 umeng 的签名校验，但是我根本没在代码里搜到相关 umeng 的东西：https://www.52pojie.cn/thread-1449780-1-1.html 问过了帖子原作者，他已经忘了细节，不能提供帮助 xposed 的算法助手开启拦截应用退出选项，可使得 tweakMe patch 的最新版 fake location 不闪退 猜想这个选项可能是 hook 了 system 类，下一步准备 frida hook system 类试试，看一下堆栈 hook 的时候出现了一个很奇怪的报错，process crashed，代码应该没写错 搞了很久，问题应该是 Remote updates to the Android Art Runtime change the ClassLinker pointer offset，解决办法：https://github.com/frida/frida/issues/2254 第一步： 第二步重启后： 解决后继续 hook system.exit(), setImmediate(hook_system()) 后没发现 system.exit 调用就闪退了 再继续试试 hook killProcess(), 同样没调用就闪退 说明还有其他的退出方法没找到 到现在（7.16 周四晚）仍未过掉 app 的签名验证，初步判断后续想要重打包 app 难度较大，并且 app 本身还有服务端的校验，在想是不是可以通过其他方式如使用面具的随机包名功能改 App 的包名 app 内提供随机包名服务，但是是付费从服务端拉一个专属 apk 安装包 3 寻找 apk 关键逻辑已脱壳的 dex 里好像没看到最关键的 hook 逻辑，不排除是有些 class 混淆太严重的原因。而且主要是前面提到的 umeng 代码没找到的原因，让我觉得肯定是没脱完壳，接下来放弃过签名，转而分析 App 伪造伪造的原理。 3-1 首先 hook dlopen 看看app 从启动到开启模拟位置选项，加载的 so 文件如下： 有点少，因为 assets 里面还有好多 so 都没看到加载 其中，libBaiduMapSDK_base_v5_2_0.so, ibBaiduMapSDK_map_v5_2_0.so,liblocSDK7b.so 全是与百度定位相关的 SDK 的 so 文件，不重要。 libjiagu_64.so, libjgdtc.so 与 360 加固相关，不管。 3-2 hook runtime.exec 打印调用栈看到脱壳代码里面有执行 shell 命令的，所以 hook runtime.exec 看看。但是函数名字全部混淆了，追不到源码 3-3 hook _android_log_printso 文件里有很多使用_android_log_print 的 log 输出，hook 看看。但是没有有意思的东西，应该是会有的，很奇怪，估计是 hook 代码写的有问题 3-4 hook unlink 和 FilterOutputStream.write尝试 hook unlink 和 java.io.FilterOutputStream.write 函数，看看删除了哪些文件，因为代码里看起来有 rm 的命令，同时 system_dex 目录又很可疑，但也没看到删除了什么 dex 文件，也没删除 so 文件 注：process.getInputStream 是用来读取控制台命令结果的, process.getOutputStream 是用来往控制台写入参数的 结果看到了 busybox 执行命令啥的，也注入了很多 so 文件 补充: fakelocation 很多的文件操作都需要在手机重启后才会进行，前面的结果是正常运行但是没重启的时候进行的，重启后发现反编译代码里展现的全部命令，记录在 log_FilterOutputStream.txt 里 3-5 hook open 函数发现 app 打开了 apk 安装包里没有的 so 文件 最后在&#x2F;data&#x2F;0&#x2F;user&#x2F;com&#x2F;lerist.fakelocation&#x2F;files 里找到了 libfakeloc.so 文件，发现居然是 apk 文件，反编译后找到了 类 com.lerist.inject.fakelocation.InjectDex","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"FakeLocation原理及重打包 ( 二 )","slug":"Study/实习/FakeLocation原理","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/10/Study/实习/FakeLocation原理/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E5%AE%9E%E4%B9%A0/FakeLocation%E5%8E%9F%E7%90%86/","excerpt":"","text":"fakelocation 重打包及原理一 结论二 逆向分析过程三 原理分析1 概况在 Android 系统中，获取地理位置信息需调用 Android 系统的位置服务，而位置服务运行在包含了大量系统服务程序的 system_server 进程中，地理位置信息服务程序在 system_server 中的服务名为：LocationManagerService。 Fake Location Hook 了 LocationManagerService 服务中的相关函数。当 App 向 LocationManagerService 发起获取地理位置信息请求时，被劫持的 LocationManagerService 向 App 返回预先设置的地理位置信息，通过这种方式完成地理位置信息篡改。 这也是 Fake Location 的特别之处。不同于市面上传统的改定位工具，通过劫持相关 App（将定位信息注入到目标 App）实现篡改定位，Fake Location 则是直接劫持“系统位置服务”，因不在目标应用进程空间，更加隐蔽而难以检测。 2 原理细节Fake Location 的核心功能都在 前面找到的 libfakeloc.so 这个 apk 文件中，libfakeloc.so 加载后 libfakeloc_init.so init 方法会执行类 com.lerist.inject.fakelocation.InjectDex 的 init 方法。 在这个方法里，Fake Location 向 system_service 添加了一些系统服务，用于和 fakeLocation 跨进程通信。 可以看到，InjectDex.init 方法向 system_service 添加了一些系统服务 由于混淆太难看懂了，我只找了关键函数分析。 在劫持的 getLastLocation 中，首先判断是否需要改定位(当有用户使用了 Fake Location 的位置模拟功能时则需要篡改)。如果需要改定位，直接调用 getLastLocation_bak(getLastLocation_bak 是原 getLastLocation 的备份)，构造一个 Location 对象(伪造的位置信息)，填充伪造的经纬度信息并返回，达到篡改位置信息目的。如果不需要改定位，则调用原本的 getLastLocation 函数并返回正常的地理位置信息。 伪造的位置对象由 getTempLocation 提供，进入函数体发现伪造的位置被 f82 定义，继续追 过程比较乱，mo61 函数里面调用了 init 函数，hook 系统函数初始化 hook 函数很重要，会 hook 系统服务类的关键函数，完成地理位置篡改。 com.android.server.LocationManagerService 里的很多函数都是与位置信息相关 hook 函数的实现得到 native 层了，在 liblhooker.so 里 Java_com_lerist_lib_lhooker_LHooker_hookMethodNative 关键代码在这，应该是替换了 art_method 的 trampoline 跳板地址来实现函数的替换 hook 四 测评结果由于 FakeLocation 自签名验证较为复杂，现在还不具备对 APP 做重打包的能力，故采取其他办法。 经过验证，通过使用 magisk、Lsposed 的相关模块就能屏蔽掉美团 APP 的应用列表获取功能，将 FakeLocation 的命中标签从 3 减至 1，命中的逻辑应该是检测了 FakeLocation 运行时的 so 相关 1 之前在 12.11 版本的美团上开启 FakeLocation，命中 3 个标签： fake_location_risk_apps_detect android_app_location_riskapps android_execution_inject_mock_localtion_so 前两个猜测是通过包名检测的，最后一个经过询问应该是检测了 so 2 现在在同样版本的美团上启用 magisk 的 Zygisk-LSPosed 模块，开启 LSPosed。 然后在 LSPosed 上启用隐藏列表模块以及隐秘空间模块(只开启一个也行)，并重启。 隐藏列表模块在黑名单模板管理里添加 FakeLocation 应用，然后在应用管理里勾选对美团 APP 生效。https://github.com/Xposed-Modules-Repo/com.tsng.hidemyapplist 隐秘空间模块将 FakeLocation 隐藏，并在致盲选项里勾选美团 APP。https://github.com/GeekTR/PrivacySpace 启用后，再开启 FakeLocation，美团后台只命中了 android_execution_inject_mock_localtion_so 这一个标签。 并且，magsik 开启最新版(0.7.3)的 Shamiko 模块，关闭遵守排除列表，在配置排除列表内勾选美团，就能隐藏 magisk 的命中。 验证了低版本 12.8、12.5 版本的美团 APP，均命中 android_execution_inject_mock_localtion_so，其他两个标签未命中。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"Ollvm 介绍","slug":"Study/逆向知识/OLLVM","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/OLLVM/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/OLLVM/","excerpt":"","text":"LLVM(Obfuscator-LLVM)是瑞士西北应用科技大学安全实验室于 2010 年 6 月份发起的一个项目,该项目旨在提供一套开源的针对 LLVM 的代码混淆工具,以增加对逆向工程的难度，只不过仅更新到 llvm 的 4.0，2017 年开始就没在更新。 源代码（c&#x2F;c++）经过 clang–&gt; 中间代码(经过一系列的优化，优化用的是 Pass)–&gt; 机器码 ollvm 的分类 1. 指令替换（Sub）指令替换，将一条运算指令，替换为多条等价的运算指令。例如：y&#x3D;x+1 变为 y&#x3D;x+1+1-1 2. 虚假控制流（bcf）虚假控制流混淆主要通过加入包含不透明谓词(相邻数字相乘恒为偶数)的条件跳转和不可达的基本块，来干扰 IDA 的控制流分析和 F5 反汇编 不透明谓词是指一个表达式，他的值在执行到某处时，对程序员而言必然是已知的，但是由于某种原因，编译器或者说静态分析器无法推断出这个值，只能在运行时确定。 常见特征：不透明谓词–&gt;例如 y &gt; 10 || x * (x + 1) % 2 &#x3D;&#x3D; 0 在 OLLVM 中，使用了 y &gt; 10 || x * (x + 1) % 2 &#x3D;&#x3D; 0 这个不透明谓词，学过数学的都知道，x * (x + 1) % 2 &#x3D;&#x3D; 0 是个永真式。也就是说，混淆器已经知道了 y &gt; 10 || x * (x + 1) % 2 &#x3D;&#x3D; 0 这个式子的值，所以可以将其放在条件语句中，控制代码的走向；而编译器和反编译器都认为这个表达式需要进行运行后才能求值，会保留这段代码，进而干扰到反编译器。 虚假控制流去除的思路一般为除去不可达块和不透明谓词。但是难点在于不透明谓词 针对简单的控制流混淆，去不透明谓词的思想主要是： 不直接处理不透明谓词，通过让不透明谓词的变量地址可读，则 IDA 便可以优化 直接将不透明谓词赋值为 0 或者将不透明谓词中变量 x，y 赋值为 0 编译器优化去干掉不透明谓词 不可达块： 不可达块是指控制流永远无法到达的基本块，一般我们可以使用符号执行或模拟执行来除去不可达基本块 3. 控制流平坦化（Fla）控制流平坦化，主要通过一个主分发器来控制程序基本块的执行流程。该方法将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系。 一般通用的反控制流平坦化思路： 先保存所有的基本块 控制流平坦化本质逻辑是把原始的基本块都碎片化，再通过 switch-case 语句，对函数的执行流进行重建。那么反混淆的时候，可以尝试根据主分发器将这些执行链给一条条的拆解出来 区分真实块和分发器（虚假块） 一般通过规则匹配来做，但是并无法使用所有情况 （难点） 主分发器的确定：直接遍历目标函数下的所有基本块，并计算每一个 Block 的引用次数，数量最多的那个就是主分发器 通过特征匹配来找真实块 真实块的入口跳转地址必须为绝对的比较指令，如 beq、bne，首次匹配到这种绝对的跳转指令，就能定位对应流程链中的真实入口地址，然后识别 凡是有内存操作的以及有 bl&#x2F;blx 函数调用的都是真实块，其中有一些指向主分发器的虚拟块也会包含内存操作 连接真实块的顺序 一般静态可以通过 IDA trace 然后编写 IDApython 脚本，动态可以通过符号执行、模拟执行 编写 patch 对目标函数进行修复、恢复原始逻辑 打 patch，即通过 jump 指令或者一些条件跳转指令试图将它们重新连接起来 3. 字符串加密符串加密的原理很简单，编写一个 pass 将其中的字符串信息使用一些加密算法进行加密，然后特定的时间进行还原。一般含有字符串混淆、函数名混淆、不在 init_array 解密等 常见的特征：datadiv_decoded 字符串加密的的常规解决方式： 特征搜索 一般在 so 中可以直接搜索 datadiv_decode，一般很多编写解密函数进行操作是这个函数，针对这种情况，一般可以通过 frida hook 就可以拿到解密后的值，然后进行 patch init_array 中解密 字符串解密操作在 init_arrray 中进行，一般可以通过模拟执行 init_array，然后将解密后的字符串全部保存下来 Jni_onload 解密 在 jni_onload 函数中进行解密操作，这时候就要进行 inlinehook 拿到解密后寄存器的值，也可以进行 hook，也可以使用 unicorn 进行操作 对抗例子AndroidNativeEmu 和 unidbg 都是对 unicorn 进行了一定程度封装的开源项目，让我们可以很方便的调用 jni 函数，以及对没有实现的函数进行 hook 实现处理，并且让我们可以实现 so 里面模拟调用 java 函数。 下面首先使用 AndroidNativeEmu 来对抗 ollvm 的字符串混淆，对 so 进行修复，让我们可以更加便捷的进行静态分析。 AndroidNativeEmu 的介绍如：https://www.52pojie.cn/thread-1031123-1-1.html 注意，在本机上使用时 python 环境为 3.7，3.9 会报错，安不上 keystore 在实现之前，先总结下原理。 ollvm 的字符串混淆，我们使用 IDA 的时候，看到的结果如下： 这里相当于是一个解密函数，通过这个函数将会还原成正常的字符串。然后我们看看在哪里调用到了这个解密函数。 可以看到是在.init_array 中使用解密函数对字符串进行还原。也就是说，当我们执行完.init_array 后，就会将正常的字符串写入内存中，这时我们就得到了真正的字符串了。所以根据这个情况： 第一步，我们需要监控内存的读写，然后运行.init_array。这样发生的内存写入时，基本可以确定是字符串还原函数在写入恢复的字符串。 写之前我们先看看 unicorn 的内存写入的相关注释： 12345678/* Callback function for hooking memory (READ, WRITE &amp; FETCH) @type: this memory is being READ, or WRITE @address: address where the code is being executed @size: size of data being read or written @value: value of data being written to memory, or irrelevant if type = READ. @user_data: user data passed to tracing APIs*/ 这里就知道了，size 是写入或读取数据的长度，value 是写入或读取的数据。那么开始写我们第一步的代码： 1234567891011121314151617181920212223242526import loggingimport sysfrom unicorn import UC_HOOK_MEM_WRITEimport structfrom androidemu.emulator import Emulator# Configure logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot;)logger = logging.getLogger(__name__)def hook_mem_write(uc,type,address,size,value,userdata): curdata=struct.pack(&quot;I&quot;,value)[:size] print(curdata)emulator = Emulator(vfp_inst_set=True)emulator.load_library(&quot;example_binaries/libc.so&quot;, do_init=False)#设置内存的写入监控emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)#后面的do_init为true就会调用.init_arraylib_module = emulator.load_library(&quot;example_binaries/obf.so&quot;, do_init=True) 输出的结果如下： 这里能看到，真实的字符串已经能在回调监控中打印出来了。接下来的第二步，我们需要把所有真实字符串以及写入真实字符串的位置给保存下来。 12345dstr_datas=&#123;&#125;def hook_mem_write(uc,type,address,size,value,userdata): curdata=struct.pack(&quot;I&quot;,value)[:size] dstr_datas[address]=curdata print(curdata) 那么写回到哪里呢？我们监控内存写入时，当时是给什么地址写入数据，我们就写入到哪里，这样我们写入的 so 就能直接在 IDA 中打开就看到真实字符串了。 在写入时需要注意的是，我们保存的 address 是有一个基址的。也就是说，我们写入时需要减掉基址，才是真正应该写入的位置。 12345678910#获取到基址base_addr=lib_module.basesofile=open(&quot;example_binaries/obf.so&quot;,&quot;rb&quot;)#我们要将真实的字符串回填到sodata中。然后再保存sodata=sofile.read()for address,v in dstr_datas.items(): #仅仅将so范围内的保存原字符串进行写回 if address &gt; base_addr and address &lt; base_addr+lib_module.size: offset=address-base_addr print(&quot;address:0x%x data:%s offset:0x%x&quot; % (address, v,offset)) 然后我贴上几行打印的内容： 12345address:0xcbc6a004 data:b&#x27;j&#x27; offset:0x4004address:0xcbc6a005 data:b&#x27;n&#x27; offset:0x4005address:0xcbc6a006 data:b&#x27;i&#x27; offset:0x4006address:0xcbc6a007 data:b&#x27;\\x00&#x27; offset:0x4007address:0xcbc6a008 data:b&#x27;g&#x27; offset:0x4008s 第一个 offset 的偏移是 0x4004，那么我们打开 IDA 检查一下是否对的上: 能看到 IDA 里面显示的确实是对的上的。但是这里要留意最左下角的 00003004，实际这个才是文件中的真实位置。所以我们这里直接写回 so 要再将 offset-0x1000。 这里最左下角是 “current offset” 指文件中的实际偏移量，而 右边的”current location” 是 IDA 为了提供更多上下文信息而显示的位置标识，对于特殊结构或功能的位置，IDA 可能会将 “current location” 设定为更有意义的值，以提供更好的可读性和理解性。所以此处两者会有不同 下面我们开始将 so 的数据修改，并且保存成一个新的文件。最后贴上完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import loggingimport sysfrom unicorn import UC_HOOK_MEM_WRITEimport structfrom androidemu.emulator import Emulator# Configure logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot;)logger = logging.getLogger(__name__)dstr_datas=&#123;&#125;def hook_mem_write(uc,type,address,size,value,userdata): curdata=struct.pack(&quot;I&quot;,value)[:size] dstr_datas[address]=curdata # print(curdata)emulator = Emulator(vfp_inst_set=True)emulator.load_library(&quot;example_binaries/libc.so&quot;, do_init=False)#设置内存的写入监控emulator.mu.hook_add(UC_HOOK_MEM_WRITE, hook_mem_write)#后面的do_init为true就会调用.init_arraymodulePath=&quot;example_binaries/obf.so&quot;lib_module = emulator.load_library(modulePath, do_init=True)#获取到基址base_addr=lib_module.basesofile=open(&quot;example_binaries/obf.so&quot;,&quot;rb&quot;)#我们要将真实的字符串回填到sodata中。然后再保存sodata=sofile.read()sofile.close()for address,v in dstr_datas.items(): #仅仅将so范围内的保存原字符串进行写回 if address &gt; base_addr and address &lt; base_addr+lib_module.size: offset=address-base_addr-0x1000 print(&quot;address:0x%x data:%s offset:0x%x&quot; % (address, v,offset)) sodata=sodata[:offset]+v+sodata[offset+len(v):]#保存成一个新的sosavepath=modulePath+&quot;.new&quot;nfile=open(savepath,&quot;wb&quot;)nfile.write(sodata)nfile.close() ollvm 对抗1.简单 ollvm 可以通过交叉引用分析2.angr 去除不透明谓词3.Unicorn&#x2F;Unidbg&#x2F;AndroidNativeEmu 模拟执行4.IDA Trace5.binary ninja 6.后端编译优化7.frida 辅助分析","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"bilibili 反调试","slug":"Study/逆向知识/bilibili 反调试","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/bilibili 反调试/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/bilibili%20%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"Android 加载 so hookandroid 中 so 库的加载，代码如下： 1234// 参数为so库名称，位于 apk 压缩文件中的 libs 目录，最后复制到 apk 安装目录下；System.loadLibrary(String libName);// 参数为 so 库在磁盘中完整的路径，可以加载自定义外部 so 库文件；System.load(String pathName); 我们来看 native 层下它的执行流程吧： 先调用 dlopen 在进程加载 so 库(dlopen 函数只是简单的调用了 dlopen_ext)； find_library 在 soinfo 结构(进程加载的 so 链)中查找当前 so 是否已载入，否则去执行 so 载入流程。 so 载入后，find_library 会返回 soinfo，去执行 so 的 CallConstructors 函数: 如果 so 包含 init、init_array 段，则此函数会先执行这 init 和 init_array。 dlopen 函数执行完毕表示系统对 so 操作告一段落，接着通过 dlsym 获取 so 库中名称为“JNI_OnLoad”的函数的地址，然后执行 JNI_LOAD. 如果要 hook dlopen 函数，frida 代码如下： 123456789101112131415161718192021var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);console.log(android_dlopen_ext);if (android_dlopen_ext != null) &#123; Interceptor.attach(android_dlopen_ext, &#123; onEnter: function (args) &#123; var soName = args[0].readCString(); console.log(soName); if (soName.indexOf(&quot;libc.so&quot;) != -1) &#123; this.hook = true; &#125; &#125;, onLeave: function (retval) &#123; if (this.hook) &#123; dlopentodo(); &#125; &#125;, &#125;);&#125;function dlopentodo() &#123; //todo ...&#125; Module.findExportByName(module | null, exp): 返回模块 module 内的导出项的绝对地址，如果模块名不确定，第一个参数传入 null，这种情况下会增大查找开销，尽量不要使用。 Interceptor.attach(target, callbacks): 在 target 指定的位置进行函数调用拦截，target 是一个 NativePointer 参数，用来指定你想要拦截的函数的地址，有一点需要注意，在 32 位 ARM 机型上，ARM 函数地址末位一定是 0（2 字节对齐），Thumb 函数地址末位一定 1（单字节对齐），如果使用的函数地址是用 Frida API 获取的话， 那么 API 内部会自动处理这个细节（比如：Module.findExportByName()）。其中 callbacks 参数是一个对象，大致结构如下： onEnter: function(args): 被拦截函数调用之前回调，其中原始函数的参数使用 args 数组（NativePointer 对象数组）来表示，可以在这里修改函数的调用参数。 onLeave: function(retval): 被拦截函数调用之后回调，其中 retval 表示原始函数的返回值，retval 是从 NativePointer 继承来的，是对原始返回值的一个封装，你可以使用 retval.replace()调用来修改返回值的内容。 很多的加固厂商在进行 Android 逆向的对抗的时，都会在 Android 的 so 文件中进行动态的对抗，对抗的点一般在 so 文件的.init 段和 JNI_OnLoad 处。因此，我们在逆向分析各种厂商的加固 so 时，需要在 so 文件的.init 段和 JNI_OnLoad 处下断点进行分析，过掉这些加固的 so 对抗。 执行顺序依次是 init&gt;init_array&gt;JNI_OnLoad bilibili 反调试以看雪破解 b 站反调试为例： 要想 hook jni_load 函数，先在 IDA 里找到待调试的 so 里面的 jni_onload 函数静态地址，一般搜索 jni_onload 字符串就行。 123456789101112131415161718192021222324252627282930function hook_dlopen(soName = &quot;&quot;) &#123; Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) &gt;= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; hook_JNI_OnLoad(); &#125; &#125;, &#125;);&#125;function hook_JNI_OnLoad() &#123; let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;); Interceptor.attach(module.base.add(0xc6dc + 1), &#123; // ida找的jni_onload地址,加一是因为 ARM 函数地址末位一定是 0（2 字节对齐） onEnter(args) &#123; console.log(&quot;call JNI_OnLoad&quot;); &#125;, &#125;);&#125;setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;); 运行脚本后并没有输出日志，那么说明检测的位置在 JNI_OnLoad 函数之前，所以需要 hook .init_xxx 的函数，但这里有一个问题，dlopen 函数调用完成之后.init_xxx 函数已经执行完成了，这个时候不容易使用 frida 进行 hook。 作者的方法很取巧，首先在.init_proc 函数中找一个调用了外部函数的位置，时机越早越好，这个函数里面有一个_system_property_get 函数。 所以选择了_system_property_get 函数，接下来使用 frida hook dlopen 函数，当加载 libmsaoaidsec.so 时，在 onEnter 回调方法中 hook_system_property_get 函数，以”ro.build.version.sdk”字符串作为过滤器。如果_system_property_get 函数被调用了，那么这个时候也就是.init_proc 函数刚刚调用的时候，在这个时机点可以注入想要的代码。 123456789101112131415161718192021222324252627282930313233function hook_dlopen(soName = &quot;&quot;) &#123; Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) &gt;= 0) &#123; locate_init(); &#125; &#125; &#125;, &#125;);&#125;function locate_init() &#123; let secmodule = null; Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;), &#123; // _system_property_get(&quot;ro.build.version.sdk&quot;, v1); onEnter: function (args) &#123; secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;); var name = args[0]; if (name !== undefined &amp;&amp; name != null) &#123; name = ptr(name).readCString(); if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123; // 这是.init_proc刚开始执行的地方，是一个比较早的时机点 // do something &#125; &#125; &#125;, &#125;);&#125;setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;); 在获取了一个非常早的注入时机之后，就可以定位具体的 frida 检测点了。网上对 frida 的检测通常会使用 openat、open、strstr、pthread_create、snprintf、sprintf、readlinkat 等一系列函数，从这里下手是一个不错的选择。 在.init_proc 刚开始执行时对 pthread_create 函数进行 hook，打印一下新线程要执行的函数地址。 123456789101112// hook pthread_createfunction hook_pthread_create() &#123; console.log( &quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base ); Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;), &#123; onEnter(args) &#123; let func_addr = args[2]; console.log(&quot;The thread function address is &quot; + func_addr); &#125;, &#125;);&#125; libmsaoaidsec 的地址为 0xae80f000, 这里面有两个线程是 libmsaoaidsec.so 创建的，对应的函数偏移分别是 0x11129 和 0x10975 在 ida 里查找地址，作者说这两个函数都检测了 frida，但自己没看出来，只找到了 pthread_create 操作 绕过的方法很简单，直接 nop 掉 pthread_create。根据交叉引用，找到检测 frida 的函数的调用处，其中 0x11129 对应的函数被 0x113F8 处的 pthread_create 函数调用，也就是说 0x11129 和 0x10975 是线程需要执行的函数的地址，也就是 pthead_create 函数的第三个参数，0x113F8 和 0x10AE4 是 pthread_create 函数被调用的地址。 1234567891011121314function nop(addr) &#123; Memory.patchCode(ptr(addr), 4, (code) =&gt; &#123; const cw = new ThumbWriter(code, &#123; pc: ptr(addr) &#125;); cw.putNop(); cw.putNop(); cw.flush(); &#125;);&#125;function bypass() &#123; let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;); nop(module.base.add(0x10ae4)); nop(module.base.add(0x113f8));&#125; 至此，b 站 hook 上了。 完整脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 初始排查的时候 hook dlopen// function hook_dlopen() &#123;// Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;// onEnter: function (args) &#123;// var pathptr = args[0];// if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;// var path = ptr(pathptr).readCString();// console.log(&quot;load &quot; + path);// &#125;// &#125;,// &#125;);// &#125;// setImmediate(hook_dlopen);// 进一步排查 hook 某so里面的jni_load// function hook_dlopen(soName = &quot;&quot;) &#123;// Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;// onEnter: function (args) &#123;// var pathptr = args[0];// if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;// var path = ptr(pathptr).readCString();// if (path.indexOf(soName) &gt;= 0) &#123;// this.is_can_hook = true;// &#125;// &#125;// &#125;,// onLeave: function (retval) &#123;// if (this.is_can_hook) &#123;// hook_JNI_OnLoad();// &#125;// &#125;,// &#125;);// &#125;// function hook_JNI_OnLoad() &#123;// let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;);// Interceptor.attach(module.base.add(0xc6dc + 1), &#123;// onEnter(args) &#123;// console.log(&quot;call JNI_OnLoad&quot;);// &#125;,// &#125;);// &#125;// setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;);function hook_dlopen(soName = &quot;&quot;) &#123; Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) &gt;= 0) &#123; locate_init(); &#125; &#125; &#125;, &#125;);&#125;function locate_init() &#123; let secmodule = null; Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;), &#123; // _system_property_get(&quot;ro.build.version.sdk&quot;, v1); onEnter: function (args) &#123; secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;); var name = args[0]; if (name !== undefined &amp;&amp; name != null) &#123; name = ptr(name).readCString(); if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123; // 这是.init_proc刚开始执行的地方，是一个比较早的时机点 // do something // hook_pthread_create(); // bypass(); &#125; &#125; &#125;, &#125;);&#125;// hook pthread_createfunction hook_pthread_create() &#123; console.log( &quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base ); Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;), &#123; onEnter(args) &#123; let func_addr = args[2]; console.log(&quot;The thread function address is &quot; + func_addr); &#125;, &#125;);&#125;function nop(addr) &#123; Memory.patchCode(ptr(addr), 4, (code) =&gt; &#123; const cw = new ThumbWriter(code, &#123; pc: ptr(addr) &#125;); cw.putNop(); cw.putNop(); cw.flush(); &#125;);&#125;function bypass() &#123; let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;); nop(module.base.add(0x10ae4)); nop(module.base.add(0x113f8));&#125;setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;); 本来想利用类似的方法尝试 hook 丰巢 app，但是没找到合适的 hook 点，丰巢使用的是 libxloader.so，但没有像上面那样在 init_proc 开头就有__system_property_get，进 while 循环有，但打印出来的地址显示结果不太正常，找不到对应函数体","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"ptrace 反调试","slug":"Study/逆向知识/ptrace反调试分析","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/ptrace反调试分析/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/ptrace%E5%8F%8D%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/","excerpt":"","text":"ptrace 系统调用提供了一种方法，这个方法可以让一个进程监视、控制另一个进程的执行，并且可以查看和更改被追踪进程的内存和寄存器。通常用来下断点和调试。 其基本原理是: 当使用了 ptrace 跟踪后，所有发送给被跟踪的子进程的信号(除了 SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为 TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。 反调试首先，从 ptrace 函数出发，其主要用法如下： 12#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); ptrace 有四个参数: enum __ptrace_request request：指示了 ptrace 要执行的命令。 pid_t pid: 指示 ptrace 要跟踪的进程。 void *addr: 指示要监控的内存地址。 void *data: 存放读取出的或者要写入的数据。 对于 enum __ptrace_request request 来说，有三种命令: PTRACE_TRACEME ：表示本进程将被其父进程跟踪，此时剩下的 pid、addr、data 参数都没有实际意义可以全部为 0, 这个选项只能用在被调试的进程中，也是被调试的进程唯一能用的 request 选项，其他的都只能用父进程调试器使用 PTRACE_ATTACH：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作 PTRACE_CONT：继续运行之前停止的子进程，也可以向子进程发送指定的信号 手段 1 进程自己 ptrace 自己每个进程同时刻只能被 1 个调试进程 ptrace, 所以主动自己 ptrace 本进程可以使得其他调试器无法调试。实例： 1234567891011121314void ptraceCheck()&#123; // 调试操作失败，返回-1；成功则返回0，成功时，tracerPid为父进程的Pid int ck=ptrace(PTRACE_TRACEME, 0, 0, 0); if(ck == -1) &#123; LOGA(&quot;进程正在被调试\\n&quot;); return; &#125;else &#123; LOGB(&quot;ptrace的返回值为:%d\\n&quot;,ck); return; &#125;&#125; 对抗手段：hook ptrace 返回 0 手段 2 检测 TracerPid读取进程的&#x2F;proc&#x2F;{pid}&#x2F;status 文件(进程私有的可以读取，当然不能读取其他进程的文件) ，status 文件的字段信息解释如下： Name：进程名 | State：表示进程的状态 | Tgid：线程组 ID，一般指进程名 Pid：线程 ID，他的值和 gettid 函数的返回值相等 | PPid：父进程的进程 id TracerPid：实现调试功能的进程 ID，值为 0 表示当前进程未被 ptrace，如果不为 0，表示正在被调试, TracerPid 的值是调试程序的进程 id 反调试可以循环读取&#x2F;proc&#x2F;self&#x2F;status 中 tracerPid 的值, 或者获取 PPid，与当前应用进程号做对比，判断是否为应用主进程的子进程进行了 ptrace 操作 对抗手段：一般检测 TracerPid 都会读取 &#x2F;proc&#x2F;进程号&#x2F;status 这个文件，所以可以直接搜索 &#x2F;status 这种字符串，这里也会用到 getpid, fgets 这种 API,所以也可以通过这两个 api 定位。 其他手段： 遍历&#x2F;proc&#x2F;self&#x2F;task&#x2F;xx&#x2F;stat 文件，读取当前线程状态是否为 tracing 检测&#x2F;proc&#x2F;self&#x2F;fd&#x2F;%s 特征字符串 injector。 fd 是一个目录，里面包含着当前进程打开的每一个文件的描述符（file descriptor）差不多就是路径啦，这些文件描述符是指向实际文件的一个符号连接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过 fd 目录的文件获取进程，从而打开每个文件的路径以及文件内容 检测&#x2F;proc&#x2F;self&#x2F;maps 特征字符串 检测&#x2F;data&#x2F;local&#x2F;tmp 及对应文件的权限 ‘x’ ‘r’ 检测 libart.so 的 inline hook 特征 解析 libart.so 中的_ZN3art9ArtMethod12PrettyMethodEb，是否存在 inlinehook 特征 在上述检测逻辑后，部分使用的是直接的函数调用 exit(0)，另外一部分是使用 svc 调用 exit_group，所以仅 hook libc 的 exit 函数是无法做到绕过检测的。 手段 3 子线程附加父线程反调试1234567891011121314151617181920212223242526272829void anti_ptrace(void)&#123; pid_t child; // 创建子进程 // fork 返回值表示当前进程的执行情况，&gt; 0 表示当前进程是父进程，并且返回新创建子进程的进程id // 返回值等于0， 表示当前进程是子进程；返回值 &lt; 0 表示创建子进程失败，返回值为错误码 child = fork(); if (child) &#123; // 等待子进程结束 wait(NULL); &#125; else if(child == 0 )&#123; // 获取父进程的pid pid_t parent = getppid(); // ptrace附加父进程 if (ptrace(PTRACE_ATTACH, parent, 0, 0) &lt; 0)&#123; // 如果已有线程被调试，那么就进入死循环 while(1)&#123; sleep(1); &#125; &#125; // 释放附加的进程 ptrace(PTRACE_DETACH, parent, 0, 0); // 结束当前进程 exit(0); &#125;&#125; 手段 4 双进程守护基于手段 3，子进程附加父进程，但是这里有个问题：子进程是可以被调试的，也就是可以在子进程中绕过调试或者直接杀死子进程。 所以升级一下，在子进程中使用 ptrace，将请求类型设为 PTRACE_TRACEME，表示让父进程跟踪自己，而进程在同一时间，只能被一个调试器调试或者跟踪，所以这里就是一个父进程，一个子进程，子进程通过读取父进程的&#x2F;proc&#x2F;{PID}&#x2F;status 文件保护父进程不被调试，同时让父进程跟踪自己，保护自己不被调试，如果 ptrace 失败，说明有调试器已经在调试自己，直接退出 12345678910111213141516171819202122232425262728293031323334void readStatus() &#123; FILE *fd; char filename[128]; char line[128]; pid_t pid = syscall(__NR_getpid); LOGI(&quot;PID : %d&quot;, pid); sprintf(filename, &quot;/proc/%d/status&quot;, pid);//读取/proc/pid/status中的TracerPid if (fork() == 0) &#123; int pt = ptrace(PTRACE_TRACEME, 0, 0, 0); //子进程反调试 if (pt == -1) exit(0); while (1) &#123; fd = fopen(filename, &quot;r&quot;); while (fgets(line, 128, fd)) &#123; if (strncmp(line, &quot;TracerPid&quot;, 9) == 0) &#123; int status = atoi(&amp;line[10]); LOGI(&quot;########## status = %d, %s&quot;, status, line); fclose(fd); syscall(__NR_close, fd); if (status != 0) &#123; LOGI(&quot;########## FBI WARNING ##########&quot;); LOGI(&quot;######### FIND DEBUGGER #########&quot;); kill(pid, SIGKILL); return; &#125; break; &#125; &#125; sleep(CHECK_TIME); &#125; &#125; else &#123; LOGE(&quot;fork error&quot;); &#125;&#125; 作为开发而言，大概率不会在主线程进行检测，否则有可能会使程序阻塞卡顿。所以，创建一个线程，进行检测会比较好，一般是使用 pthread_create 函数：创建一个线程，可以指定新线程的运行函数地址，以及传递参数。 1234567891011int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);（1）tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。（2）restrict_attr：用于定制各种不同的线程属性，通常直接设为NULL。（3）start_rtn：新创建线程从此函数开始运行。无参数是arg设为NULL即可。（4）arg：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。（以下举例）（5）返回值：成功返回0，否则返回错误码 对抗方法： patch pthread_create 函数 或者 patch 所有调用 pthread_create 函数的 caller，当然也可以 nop 掉 12345678910111213141516171819202122let pthread_create = Module.findExportByName(null, &quot;pthread_create&quot;);let org_pthread_create = new NativeFunction(pthread_create, &quot;int&quot;, [ &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;,]);let my_pthread_create = new NativeCallback( function (a, b, c, d) &#123; let m = Process.getModuleByName(&quot;libDexHelper.so&quot;); let base = m.base; console.log(Process.getModuleByAddress(c).name); if (Process.getModuleByAddress(c).name == m.name) &#123; console.log(&quot;pthread_create&quot;); return 0; &#125; return org_pthread_create(a, b, c, d); &#125;, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]);Interceptor.replace(pthread_create, my_pthread_create);","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"so 加载流程","slug":"Study/逆向知识/so加载流程","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/so加载流程/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/so%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Java 层代码：loadLibrary(&quot;nanosleep&quot;); 先调用 dlopen 来载入 so 文件；find_library 在 soinfo 结构(进程加载的 so 链)中查找当前 so 是否已载入，否则去执行 so 载入流程。 dlopen 用来打开一个动态链接库，并将其装入内存。它的定义在 Android 源码中的路径为&#x2F;bionic&#x2F;linker&#x2F;dlfcn.cpp,其核心代码在 do_dlopen 中实现，根据传入的路径或文件名去查找一个动态库，并执行该动态链接库的初始化代码。 so 载入后，find_library 会返回 soinfo，去执行 so 的 CallConstructors 函数； 如果 so 包含 init、init_array 段，则此函数会先执行这 init 和 init_array。 dlopen 函数执行完毕表示系统对 so 操作告一段落，接着通过 dlsym 获取地址去执行 JNI_LOAD。 上面说到通过 find_library 函数来判断 so 是否已加载，而在该函数中实质是调用 find_library_internal 函数去实现全部功能的。来看下 find_library_internal 的执行流程 在 find_loaded_library 中通过 soinfo 结构提取出 so 的 name 比较来进行判别 so 是否已加载。load_library 函数分三步执行： 打开 so 文件得到文件描述符； ElfReader 结构体去加载(mmap)elfheader、elf_phdr、elf_segment; 将 ElfReader 解析到的 elf 信息填充到 soinfo 结构体中。 这里我们先看下 load 函数 123456789bool ElfReader::Load(const Android_dlextinfo* extinfo) &#123; return ReadElfHeader() &amp;amp;&amp;amp; // 读取 elf header VerifyElfHeader() &amp;amp;&amp;amp; // 验证 elf header ReadProgramHeader() &amp;amp;&amp;amp; // 读取 program header ReserveAddressSpace(extinfo) &amp;amp;&amp;amp;// 分配空间 LoadSegments() &amp;amp;&amp;amp;// 按照 program header 指示装载 segments FindPhdr(); // 找到装载后的 phdr 地址&#125; 当然这里 soinfo_link_image 是重头戏： 链接过程由 soinfo_link_image 函数完成，主要可以分为四个主要步骤: 定位 dynamic section 由函数 phdr_table_get_dynamic_section 完成，该函数会遍历 program header，找到为类型为 PT_DYNAMIC 的 header, 从中获取的是 dynamic section 的信息，主要就是虚拟地址和项数。 解析 dynamic section 本质上是类型为 Elf32_Dyn 的数组","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"ArtMethod Hook","slug":"Study/逆向知识/ArtMethod Hook","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/ArtMethod Hook/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/ArtMethod%20Hook/","excerpt":"","text":"1. ArtMethod 结构先给出 ArtMethod 结构主要的字段。英文是源码，中文是个人注释。版本：android-9.0.0_r30： 123456789101112131415161718192021222324252627282930313233343536373839404142class ArtMethod &#123; …………protect: // The class we are a part of. GcRoot&lt;mirror::Class&gt; declaring_class_; //可以理解为该函数的标志位，如函数为public,private,static,native等。 std::atomic&lt;std::uint32_t&gt; access_flags_; //加固代码替换点。 //里面指向code_item指针,code_item存储的实际是dex当中的字节码.其用处本来是适配dalvik解释器，即无法编译成机器码的，用解释器来执行。 // uint32_t dex_code_item_offset_; // Index into method_ids of the dex file associated with this method. //主要作为寻址替换用 uint32_t dex_method_index_; // The hotness we measure for this method. Not atomic, as we allow // missing increments: if the method is hot, we will see it eventually. //方法被记录的频率热度，用在Android N+混合编译部分，根据该值来判断是否使用JIT编译。 uint16_t hotness_count_; struct PtrSizedFields &#123; // Depending on the method type, the data is // - native method: pointer to the JNI function registered to this method // or a function to resolve the JNI function, // - conflict method: ImtConflictTable, // - abstract/interface method: the single-implementation if any, // - proxy method: the original interface method or constructor, // - other methods: the profiling data. void* data_; //这个字段顾名思义，根据方法类型，会充当不同作用，是不是可以理解为以前几个指针的复合…… // Method dispatch from quick compiled code invokes this pointer which may cause bridging into the interpreter. void* entry_point_from_quick_compiled_code_; &#125; ptr_sized_fields_; ………… ｝ 2. ArtMethod::Invoke在我们使用 Android-Studio 编译应用时，实际上是通过 Java 编译器先将 .java 代码编译为对应的 Java 字节码，即 .class 类文件；然后用 dx(在新版本中是 d8) 将 Java 字节码转换为 Dalvik 字节码，并将所有生成的类打包到统一的 DEX 文件中，最终和资源文件一起 zip 压缩为 .apk 文件。 在安装用户的 APK 时，Android 系统主要通过 PackageManager 对应用进行解包和安装。其中在处理 DEX 文件时候，会通过 installd 进程调用对应的二进制程序对字节码进行优化，这对于 Dalvik 虚拟机而言使用的是 dexopt 程序，而 ART 中使用的是 dex2oat 程序。 dexopt 将 dex 文件优化为 odex 文件，即 optimized-dex 的缩写，其中包含的是优化后的 Dalvik 字节码，称为 quickend dex； dex2oat 基于 LLVM，优化后生成的是对应平台的二进制代码，以 oat 格式保存，oat 的全称为 Ahead-Of-Time。oat 文件实际上是以 ELF 格式进行存储的，并在其中 oatdata 段(section) 包含了原始的 DEX 内容。 ART 对于 Java 方法实现了两种执行模式，一种是像 Dalvik 虚拟机一样解释执行字节码，姑且称为解释模式；另一种是快速模式，即直接调用通过 OAT 编译后的本地代码。 当 ART 运行时尚未启动或者指定强制使用解释执行时，虚拟机执行函数使用的是解释模式，ART 可以在启动时指定 -Xint 参数强制使用解释执行，但即便指定了使用解释执行模式，还是有一些情况无法使用解释执行，比如: 当所执行的方法是 Native 方法时，这时只有二进制代码，不存在字节码，自然无法解释执行； 当所执行的方法无法调用，比如 access_flag 判定无法访问或者当前方法是抽象方法时； 当所执行的方式是代理方法时，ART 对于代理方法有单独的本地调用方式； Android 中的 Java 方法在 ART 中执行都会通过 ArtMethod::Invoke 进行调用，在其内部(判断目标 Java 方法属性)要么通过解释器直接解释执行(配合 JIT)；要么通过 GetEntryPointFromQuickCompiledCode 获取 native 代码进行执行，当然后者在某些场景下依然会回退到解释器，但入口都是固定的，即 entry_point_from_quick_compiled_code 所指向的 quick 代码。如果当前解释执行遇到 native 方法时，这种情况一般是遇到了 JNI 函数，这时则通过 method-&gt;GetEntryPointFromJni() 获取对应地址进行跳转，所跳转的地址为 entry_point_from_quick_compiled_code Invoke 的核心逻辑如下: 123456789101112131415161718void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result, const char* shorty) &#123; if (UNLIKELY(!runtime-&gt;IsStarted() || (self-&gt;IsForceInterpreter() &amp;&amp; !IsNative() &amp;&amp; !IsProxyMethod() &amp;&amp; IsInvokable()))) &#123; if (IsStatic()) &#123; art::interpreter::EnterInterpreterFromInvoke( self, this, nullptr, args, result, /*stay_in_interpreter=*/ true); &#125; else &#123; mirror::Object* receiver = reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[0])-&gt;AsMirrorPtr(); art::interpreter::EnterInterpreterFromInvoke(self, this, receiver, args + 1, result, /*stay_in_interpreter=*/ true); &#125; &#125; else &#123; if (!IsStatic()) &#123; (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty); &#125; else &#123; (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty); &#125; &#125;&#125; 因此，不管是解释模式还是其他模式，只要目标方法有 native 代码，那么该方法的代码地址都是会保存在 entrypoint_from_quick_compiled_code 字段，只不过这个字段的含义在不同的场景中略有不同。 所以我们若想要实现 ART Hook，理论上只要找到对应方法在内存中的 ArtMethod 地址，然后替换其 entrypoint 的值即可。 所以想要 hook，可以 修改目标 Java 方法属性，令所有调用都走 quick 分支，即：修改 accessflags 将方法 native 化，然后将 entry_point_from_quick_compiled_code 修改为指向我们自己的实现，从而实现劫持； Android 7.0 之前的 hook 流程：获取函数的入口，得到函数结构体，替换 accessflags 将方法 native 化，保存原函数信息在 entry_point_from_jni(Android 8.0 后消失)，替换 entry_point_from_quick_compiled_code。调用被 hook 的方法时，首先会跳转替换的方法，然后跳转到 entry_point_fromjni 所指向的原方法 类似于上述方法，不过不修改指针的值，而是修改 stub code； 但对于系统类方法的调用，ART 会直接优化成汇编跳转而绕过 ArtMethod 方法的查找过程，比如 TextView.setText(), 这个时候方法 1 只是修改 entry_point_from_quick_compiled_code 就不合理了，因为实际的调用地址被写死了。 frida 实际上是使用了我们上述的第 2 种 Hook 思路，即修改 stub code 为我们的劫持代码，这种方式一般称之为 dynamic callee-side rewriting，优点是即便对于 OAT 极致优化的系统类方法也同样有效。 参考：https://www.ctfiot.com/19168.htmlhttps://bbs.kanxue.com/thread-248898.htm 3. epic hook参考：https://weishu.me/2017/11/23/dexposed-on-art/ 首先以 epic hook 框架为例，简单介绍下 ART 上的方法调用原理（此处不讨论解释模式，所有 entrypoint 均指 compiled_code_entry_point)。 在 ART 中，每一个 Java 方法在虚拟机（注：ART 与虚拟机虽有细微差别，但本文不作区分，两者含义相同，下同）内部都由一个 ArtMethod 对象表示（native 层，实际上是一个 C++对象），这个 native 的 ArtMethod 对象包含了此 Java 方法的所有信息，比如名字，参数类型，方法本身代码的入口地址（entrypoint)等；暂时放下 trampoline 以及 interpreter 和 jit 不谈，一个 Java 方法的执行非常简单： 想办法拿到这个 Java 方法所代表的 ArtMethod 对象 取出其 entrypoint，然后跳转到此处开始执行 3.1 entrypoint replacement从上面讲述的 ART 方法调用原理可以得到一种很自然的 Hook 办法————直接替换 entrypoint。通过把原方法对应的 ArtMethod 对象的 entrypoint 替换为目标方法的 entrypoint，可以使得原方法被调用过程中取 entrypoint 的时候拿到的是目标方法的 entry，进而直接跳转到目标方法的 code 段；从而达到 Hook 的目的。 不过这种方案能够生效有一个前提：方法调用必须是先拿到 ArtMethod，再去取 entrypoint 然后跳转实现调用。 但是很多情况下，第一步是不必要的：当系统知道你要调用的这个方法的 entrypoint 是什么，直接写死在汇编代码里，这样方法调用的时候就不会有取 ArtMethod 这个动作，从而不会去拿被替换的 entrypoint，导致 Hook 失效。这种调用很典型的例子就是系统函数，如 Android 5.0 上 调用 TextView.setText(Charsequence)。如果你调用系统函数，ART 编译器知道系统每一个函数入口的绝对地址，根本没有必要再去查找方法，因此生成的代码中没有任何查找过程。所以，从原理上讲，如果要支持系统方法的 Hook，这种方案在很多情况下是行不通的。 3.2 callee side dynamic rewriting既然替换入口的方式无法达到 Hook 所有类型方法的目的，那么如果不替换入口，而是直接修改入口里面指向的代码呢？（这种方式有个高大上的学名：callee side dynamic rewriting) 通俗地讲，dynamic callee-side rewriting 其实就是修改 entrypoint 所指向的代码。但是有个基本问题：Hook 函数和原函数的代码长度基本上是不一样的，Hook 函数通常比原函数长很多。如果直接把 Hook 函数的代码段 copy 到原函数 entrypoint 所指向的代码段，很可能没地儿放。因此，通常的做法是写一段 trampoline。也就是把原函数 entrypoint 所指向代码的开始几个字节修改为一小段固定的代码，这段代码的唯一作用就是跳转到新的位置开始执行，如果这个「新的位置」就是 Hook 函数，那么基本上就实现了 Hook；这种跳板代码我们一般称之为 trampoline&#x2F;stub，这种形式有点像 inline hook 对于 epic 这种 hook 框架，如果我们要 Hook android.util.Log.i 这个方法，那么首先需要找到这个方法的 entrypoint，可以通过这个方法的 ArtMethod 对象得到，然后进入 entrypoint 指向的代码地址，直接修改内存，把这个代码片段的前 8 个字节修改为一段跳转指令，与 inline hook 类似：如 123dff800f0 ; ldr pc, [pc]7f132450 ; trampoline address 这样，在执行 Log.i 这个函数的时候，会通过这第一段跳板直接跳转到 0x7f132450 这个地址开始执行。这个地址是我们预先分配好的一段内存，也是一段跳转函数，我们姑且称之为二段跳板。在接下来的二段跳板中，我们开始准备 hook 预备逻辑：判断是否需要执行 Hook 的，如果不需要，跳转到原函数的控制流，进而达到调用原函数的目的，否则直接跳转到另外一个 Java 方法的入口开始执行。 4. frida hook4.1 hook 原理frida 实际上又有 ART hook，又有 inline hook frida 针对 ART 运行时的 hook 前面做了一点说明，因为针对的 Android 版本不同，具体代码还是有很多变动。以其中一个版本为例： 首先获取到原始的 ArtMethod 指针，然后修改它的 123456789101112131415161718patchArtMethod( replacementMethodId, &#123; jniCode: impl, accessFlags: ((originalFlags &amp; ~( kAccCriticalNative | kAccFastNative | kAccNterpEntryPointFastPathFlag )) | kAccNative) &gt;&gt;&gt; 0, quickCode: api.artClassLinker.quickGenericJniTrampoline, interpreterCode: api.artInterpreterToCompiledCodeBridge, &#125;, vm); jniCode 替换为用户指定的 js 函数封装而成的 NativeFunction，并将 accessFlags 设置为 kAccNative，即 JNI 方法。 quickCode 和 interpreterCode 分别是 Quick 模式和解释器模式的入口，替换为了前面查找保存的 trampoline，令 Quick 模式跳转到 JNI 入口，解释器模式跳转到 Quick 代码，这样就实现了该方法的拦截，每次执行都会当做 JNI 函数执行到 jniCode 即我们替换的代码中。 如前文所说，对于系统函数而言，其地址已知，因此调用方被优化后很可能直接就调转到了对应的 native 地址，而不会通过 entrypoint 去查找。因此 frida 采用的方法是直接修改目标方法的 quickCode 内容，将其替换为一段跳板代码，然后再间接跳转到我们的劫持实现中。 4.2 检测 fridamaps 检测法在字符串的检测方案中，大部分用的都是这种，但是这种也很容易被感知，它的代码结构如下,主要就是检测 maps 文件中是否有 frida-agent 字符串，当然这种取自 maps 的方式太容易被感知了，随便 hook 一下就知道我们遍历了 maps 12345678910111213void anti()&#123;while (1) &#123; sleep(1); char line[1024]; FILE *fp = fopen(&quot;/proc/self/maps&quot;, &quot;r&quot;); while (fgets(line, sizeof(line), fp)) &#123; if (strstr(line, &quot;frida-agent&quot;)) &#123; __android_log_print(6, &quot;r0ysue&quot;, &quot;i find frida from anti3&quot;); &#125; &#125;&#125;&#125; frida 在注入 App 后会在 maps 中显示 frida 的 frida-agent.so 的内存信息，可以通过搜索特征字符串来检测 frida。目前大佬们的去特征的 frida 一般会使用随机 so 名称，此时也可以通过查找 maps 文件内存信息中是否存在一些满足某些条件的特征路径，如 data&#x2F;local&#x2F;tmp 检查特征文件及网络端口检测检查&#x2F;data&#x2F;local&#x2F;tmp 目录下面有没有 frida 依赖 so 所组成的文件夹，就是说 frida-server 在启动的时候会将依赖的 so 放在&#x2F;data&#x2F;local&#x2F;tmp 这个文件夹下面，所以我们可以扫描有没有这个文件夹下的特征文件，类似于下面这样的代码 123456void anti()&#123; int a= access(&quot;/data/local/tmp/re.frida.server&quot;,0); if(a ==0) __android_log_print(6,&quot;r0ysue&quot;,&quot;i find frida from anti4&quot;);&#125; frida 注入 App 后在 App 的&#x2F;proc&#x2F;self&#x2F;task&#x2F;pid&#x2F;status 文件中会存在一些 frida 的特征信息,如 gmain、pool-frida、gdbus，可以通过这些特征进行检测 fridaserver 是使用 D-Bus 协议通信，我们为每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver，但是此方法需要的时间会比较长 frida 默认端口 27047，通过检测默认端口是否开放来检测 frida 是否开启，只需要启动时指定端口即可绕过 frida-server 启动后&#x2F;proc&#x2F;net&#x2F;tcp 和&#x2F;proc&#x2F;net&#x2F;tcp6 中会有特殊标识:69a2，可以通过搜索 tcp 文件如&#x2F;proc&#x2F;net&#x2F;tcp 中的字符串来检测 frida 是否启动 检查 AccessFlags这里还有一些原理性的检测方法，比如和 xposed 一样检测 ArtMethod 的 AccessFlags 值来判断一个确定为 Java 的函数是否变成了 Native 函数，这个和 java hook 的原理有关,这个是 frida 绕不开的，就是想 hookjava 函数就一定要将 java 函数改成 native 函数，但是这种方式如果不 hook java 函数直接搞 Native 层就无法判断了 但是，同一个 app 的同一个方法在不同机型不同系统上的 AccessFlags 不同，这里要做很多适配 5. xposedxposed 通过替换 &#x2F;system&#x2F;bin&#x2F;app_process 程序控制 zygote 进程，使得 app_process 在启动过程中会加载 XposedBridge.jar 这个 jar 包，从而完成对 Zygote 进程及其创建的 虚拟机的劫持 Android 系统分为四层，分别为 kernel、Native、FrameWork、应用层（APP），loader 也可以单独算一层，是硬件的启动加载预置项。 首先当我们长按开机键（电源按钮）开机，此时会引导芯片开始从固化到 ROM 里的预设代码处执行，然后加载引导程序到 RAM。然后启动加载的引导程序，引导程序主要做一些基本的检查，包括 RAM 的检查，初始化硬件的参数。 到达内核层的流程后，这里初始化一些进程管理、内存管理、加载各种 Driver 等相关操作，如 Camera Driver、Binder Driver 等。下一步就是内核线程，如软中断线程、内核守护线程。下面一层就是 Native 层，这里额外提一点知识，层于层之间是不可以直接通信的，所以需要一种中间状态来通信。Native 层和 Kernel 层之间通信用的是 syscall，Native 层和 Java 层之间的通信是 JNI。 在 Native 层会初始化 init 进程，也就是用户组进程的祖先进程。init 中加载配置文件 init.rc，init.rc 中孵化出 ueventd、logd、healthd、installd、lmkd 等用户守护进程。开机动画启动等操作。核心的一步是孵化出 Zygote 进程，此进程是所有 APP 的父进程，这也是 Xposed 注入的核心，同时也是 Android 的第一个 Java 进程（虚拟机进程）。 进入框架层后，加载 zygote init 类，注册 zygote socket 套接字，通过此套接字来做进程通信，并加载虚拟机、类、系统资源等。zygote 第一个孵化的进程是 system_server 进程，负责启动和管理整个 Java Framework，包含 ActivityManager、PowerManager 等服务。 参考：https://blog.csdn.net/cpcpcp123/article/details/122103556https://www.cnblogs.com/baiqiantao/p/10699552.htmlhttps://bbs.kanxue.com/thread-257844.htm 5.1 Xposed 如何注入到 zygote 进程中的总结：Android 基于 Linux，第一个启动的进程自然是 init 进程，该进程会启动所有 Android 进程的父进程——Zygote(孵化)进程，该进程的启动配置在&#x2F;init.rc 脚本中，而 Zygote 进程对应的执行文件是&#x2F;system&#x2F;bin&#x2F;app_process，该文件完成类库的加载以及一些函数的调用工作。在 Zygote 进程创建后，再 fork 出 SystemServer 进程和其他进程。 而 Xposed Framework 呢，就是用自己实现的 app_process 替换掉了系统原本提供的 app_process，加载一个额外的 jar 包，然后入口从原来的 com.android.internal.osZygoteInit.main()被替换成了 de.robv.android.xposed.XposedBridge.main()，然后创建的 Zygote 进程就变成 Hook 的 Zygote 进程了，而后面 Fork 出来的进程也是被 Hook 过的。这个 Jar 包在&#x2F;data&#x2F;data&#x2F;de.rbov.android.xposed.installer&#x2F;bin&#x2F;XposedBridge.jar 从图中，我们可以总结出一条启动链：init &#x3D;&gt; init.rc &#x3D;&gt; app_process &#x3D;&gt; zygote &#x3D;&gt; ZygoteInit 根据 Android 启动流程图可知，zygote 是由 app_process 初始化产生的。app_process 是一个二进制可执行文件，它的表现形式是一个 bin 文件，它位于&#x2F;system&#x2F;bin&#x2F;app_process。一个应用的启动，核心的步骤是 Framework 层的 zygote 启动，zygote 是所有进程的父进程，也就是说，所有 APP 应用进程都是由 zygote 孵化而来。为什么要从 Native 层开始说明呢？这是因为 Native 层开始就是 Android 源码的运行过程，Xposed 的注入也就是从 Native 层开始的。 init.rc 如下： service zygote：它告诉 init 进程，现在我们要配置一个名为 zygote 的服务。&#x2F;system&#x2F;bin&#x2F;app_process： 声明 zygote 进程对应的文件路径。init 创建服务的处理逻辑很简单，就是启动（fork）一个子进程来运行指定的程序。对 zygote 服务而言这个程序就是&#x2F;system&#x2F;bin&#x2F;app_process。-Xzygote&#x2F;system&#x2F;bin–zygote–start-system-server：传递给 app_process 的启动参数。 app_process 是由 app_main.cpp 编译而来，它的源码路径位于&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp start 函数的目标就是要找到一个名称为 com.android.internal.os.ZygoteInit 的类，以及它的静态成员函数 main，然后就以这个函数为入口，开始运行 ART 虚拟机。 核心在于 forkSystemServer，通过此函数 fork 系统服务进程，代码如下所示： xposed 是如何 Hook zygote，进而实现应用程序的 Hook 呢？这也是根据上述流程来的，核心是替换 app_process,app_process.cpp 对应的文件是 app_main.cpp xposed 重写了一份 app_main.cpp，并将 XposedBridge.jar 加载到 ClassPath 中，初始化完成后进入魔改的 runtimeStart，在新的虚拟机里面会将 XposedBridge.jar 进行注入，这么一来，所有被 Xposed fork 的进程都具备了 XposedBridge.jar 的代码 。调用 xposedBridge 类的 main 方法，它会在此加载 Xposed 的资源文件，以此完成后续的 Hook 操作。 至于 hook 原理，xposed 通过修改 ART&#x2F;Davilk 虚拟机，将要 Hook 的函数注册为 Native 函数，虚拟机在调用同名函数时，会优先选择 Native 方法执行，从而达到 Hook 指定函数的目的。 5.2 检测 xposed通过自造异常检测堆栈信息，读取异常堆栈中是否包含 Xposed 字符串在正常的 Android 系统启动过程中，init 进程会去解析 init.rc 文件启动一系列的服务，其中就有 app_process 进程，在 app_process 执行过程中，会设置自身进程名为 Zygote，启动 com.android.internal.os.ZygoteInit.Main 方法。而 Xposed 修改了 app_process 进程，会先启动 de.robv.android.xposed.XposedBridge.Main 方法，再由它去启动 com.android.internal.os.ZygoteInit.Main 方法，因此堆栈信息中会多出一些内容。简单说就是 Xposed 先于了 Zygote 进程，因此在系统堆栈信息中会多出 Xposed 相关的内容。 绕过：通过 Hook 堆栈类 StackTraceElement，当发现 Xposed 和 Zygote 有错误输出时，修改输出信息，例如将输出置空来绕过错误信息检测。 通过 ClassLoader 的 loadClass 加载列表检测绕过：通过 Hook loadClass 加载类来修改加载的类名，例如修改 de.robv.android.xposed 成另一个普通的包名 检测方法是否变成了 nativeXposed 把 Method 的 nativefunc 修改为它自己的处理函数，再这个函数中会回调 Java 层的 handleHookMethod，但是只有 native 函数，虚拟机才会走 nativefunc，所以 Xposed 会把 java 函数的修饰符修改为 native，所以可以通过反射调用 Modifier.isNative(method.getModifiers())方法可以校验方法是不是 native 方法 绕过：因为检测方必须要通过 Modifier.isNative 这个方式来做检测，所以方法就是通过 Hook isNative 的方法，将检测结果置为 0 就行了 检测 Xposed 相关文件通过读取 proc&#x2F;self&#x2F;maps 文件，在 linux 内核中，这个文件存储了进程映射了的内存区域和访问权限，因此遍历自身加载的库，就可以拿到当前上下文的 so 和 jar 列表，通过查找 Xposed 相关文件来做检测 绕过：因为读取的时候会调用 BufferedReader 进行读取命令的内容，我们只需要 Hook BufferedReader 过滤掉 XposedBridge.jar 等相关内容就可以完成绕过。 通过反射 XposedHelper 类和 XposedBridge 类检测Xposed 中有几个比较常用的方法，findAndHookMethod 等。通过反射找到要 Hook 的函数后会保存到 XposedHelper 类中的 fieldCache、methodCache、constructorCache 字段中。因此，可以通过反射遍历 XposedHelper 类中的 fieldCache、methodCache、constructorCache 变量，读取 HashMap 缓存字段是否有被 Hook App 的关键函数信息就行 绕过：检测方通过反射调用 XposedHelper 的成员 fieldCache 中是否含有相关的关键字，解决方案就是修改类名，让检测方找不到相关类就行 6. Lsposedxposed 适用的最高版本为 android 8.0，针对高版本的 ART HOOK 框架可以使用比较有名的 lsposed。它使用了 lsplant ART HOOK 框架（早期使用 YAHFA）并提供了和 xposed 一样的接口 API 与其进行了兼容，同时 lsposed 本身是一个基于 magisk 的 riru&#x2F;zygisk 插件，所以在分析 lsposed 运行流程之前先分析一下 riru 和 zygisk 的运行流程。(riru 不再更新， zygisk 更普遍) 6.1 riruriru 的目的就是为了能够将插件 so 在 zygote 刚开始启动的时候注入到此进程中，首先 riru 自己需要先注入到 zygote 进程中。不同版本的 riru 使用了不同的方法将自己注入到 zygote 进程中。 早期：通过替换系统 so 库：libmemtrack.so 来实现劫持注入。 中期：使用 public.libraries.txt，在 zygote 启动时会加载此文件中的所有 so 库。 现在：修改系统属性 ro.dalvik.vm.native.bridge 进行注入，zygote 会加载此系统属性值对应的 so 库。 目前最新的 riru 版本（V26）通过修改系统属性 ro.dalvik.vm.native.bridge 将 libriruloader.so 注入到 zygote 进程中，查看此 so 的.initarray，其会先调用 dlopen 将 libriru.so 加载，最后调用 libriru.so 的 init 函数。 libriru.so 的 init 函数分别调用了 PrepareMapsHideLibrary，InstallHooks 和 Load。 PrepareMapsHideLibraryPrepareMapsHideLibrary 加载 libriruhide.so 并获取其导出函数 riru_hide InstallHooksXHOOK_REGISTER 是一个宏，其通过 GOT 表 hook libandroid_runtime.so 的 jniRegisterNativeMethods. 因为 libandroid_runtime.so 的 jni 函数都是通过 jniRegisterNativeMethods 注册的，所以 hook 后可以主动调用原 jniRegisterNativeMethods 为 libandroid_runtime.so 来注册回调函数并将 nativeForkAndSpecialize ,nativeSpecializeAppProcess, nativeForkSystemServer 这三个函数指针修改。这三个 jni 函数会在 Zygote 进程 java 层 fork 应用进程和系统进程时被调用，通过修改这三个函数的指针就可以在 zygote fork 新进程的时候得到执行时机。 Load 调用 LoadModule 函数，通过 dlopen 加载所有的 riru 模块 so 并调用其 init 函数。 调用 HideFromMaps 函数通过之前获取的 libriruhide.so 的导出函数 riru_hide 隐藏所有加载的 riru 模块 so 和 libriru.so 本身。 libriruhide.so 的导出函数 riru_hide，此函数会调用 do_hide 隐藏指定内存块，通过备份后再重新 map 回原地址的方法欺骗 map 表。 调用所有加载的 riru 模块 so 的 onModuleLoaded 函数。 6.2 zygiskzygisk 目的和 riru 一样都是为了在 zygote 进程中运行自己的模块，其通过修改 app_process 程序的入口，通过设置环境变量 LD_PRELOAD 后运行原来的 app_process 程序从而注入 zigisk 自己的 so。 zygisk 自己的 so 注入到 zygote 进程中后和 riru 一样也会加载所有的模块 so，同时也会利用相同的方式隐藏这些 so 模块。整体流程大致和 riru 相似。 6.3 Lsposed由 riru 运行流程分析可知，riru 在加载 lsposed 的模块 so 之后会先后进行如下几步操作（模块 so 就是 liblspd.so）： 加载完模块 so 后调用 so 中的 init 函数 隐藏模块 so 调用模块 so 的 onModuleLoaded 函数 当 zygote fork 生成新 apk 时会调用模块 so 中设置的回调函数，在 zygote fork 的 apk 运行前进行一些初始化。 LoadDex先调用 PreloadedDex 将 lspd.dex 文件从磁盘 map 到内存中。LoadDex 实例化一个 InMemoryClassLoader 并设置 parent 为系统类加载器 systemClassLoader，同时加载了 lspd.dex。 InitArtHooker and InitHooksInitHooks 内部会获取前面实例化的 InMemoryClassLoader 类加载器中加载的所有 dex 文件（实际就是 lspd.dex）的 DexFile 对象，然后调用 DexFile_setTrusted 使此 dex 文件中的类能够绕过 android 9.0 开始的对私有系统 frameword API 的限制访问，但是查看 DexFile_setTrusted 源码发现，此函数只有在 apk 处于调试状态下才能生效。 SetupEntryClass相当于找到 lspd.dex 的入口类 org.lsposed.lspd.core.Main，这就相当于进入加载 xposed 模块了 forkCommonforkCommon 会调用 initXposed 和 bootstrapXposed initXposed 进行一些初始化，通过前面加载的 lspd.dex 中提供的 xposed API 进行一些 hook 操作。 bootstrapXposed 调用 lspd.dex 的 loadModules。loadModules 调用 getModulesList 加载并所有的 xposed 模块，调用重载的 loadModule（内部调用 InitModule）初始化 xposed 模块中需要 hook 的函数。 6.4 检测 Lsposed检查栈回溯可以通过主动抛出一个异常并检查栈回溯信息看是否存在一些特殊方法调用，例如：de.robv.android.xposed 内存漫游获取 classloadergetInstancesOfClasses 可以获取某个类的所有实例，可以通过调用此函数获取所有的 ClassLoader 实例并进一步查看此 ClassLoader 加载的所有类信息，看是否存在特殊的类名称。但是此函数是 hide api，调用的话需要先绕过 hide api 限制。 检查&#x2F;proc&#x2F;pid&#x2F;maps无论 lsposed 是基于 riru 还是 zigisk，其 so 模块都会被隐藏。虽然隐藏后虽然内存块是匿名的，但是内存块还是包含可执行属性，正常情况下是很少出现匿名的可执行内存的。可以通过检测 map 表是否存在匿名的并且具有可执行属性的内存判断是否存在 lsposed 模块。 检查 riruriru 会将 libriruloader.so 放在&#x2F;system&#x2F;lib64 目录下并注入到 zygote 进程中，通过 fopen(“&#x2F;system&#x2F;lib64&#x2F;libriruloader.so”, “r”);判断是否存在此文件。 检查 zygiskzygisk 通过修改 zygote 进程的环境变量 LD_PRELOAD 注入 zygisk 的 so 文件，在应用程序中可以检测环境变量。不过 shamiko 项目可以对这些变化进行抹去 参考：https://www.cnblogs.com/revercc/p/17034028.html#zygisk%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Native Hook","slug":"Study/逆向知识/Native hook","date":"2023-08-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/08/10/Study/逆向知识/Native hook/","link":"","permalink":"https://beichen.link/2023/08/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Native%20hook/","excerpt":"","text":"Native 流派可以分为三大类： GOT&#x2F;PLT HookGOT&#x2F;PLT Hook 主要是用于替换某个 SO 的外部调用，通过将外部函数调用跳转成我们的目标函数。GOT&#x2F;PLT Hook 可以说是一个非常经典的 Hook 方法，它非常稳定，可以达到部署到生产环境的标准。 Trap HookTrap Hook 也可以称为断点 Hook，其原理类似于调试器，可以 Hook 函数内部的调用。兼容性非常好，但是效率比较低，不适合 Hook 调用非常频繁的函数。 Inline HookInline Hook 也可以 Hook 函数内部的调用，它直接将函数开始（Prologue）处的指令更替为跳转指令，使得原函数直接跳转到 Hook 的目标函数函数，并保留原函数的调用接口以完成后续再调用回来的目的。 与 GOT&#x2F;PLT Hook 相比，Inline Hook 可以不受 GOT&#x2F;PLT 表的限制，几乎可以 Hook 任何函数。不过其实现十分复杂。 1.elf 文件ELF 全称 “Executable and Linkable Format”，即可执行可链接文件格式，目前常见的 Linux、 Android 可执行文件、共享库（.so）、目标文件（ .o）以及 Coredump 文件均为此格式。 目标文件：是指程序源代码经过汇编编译器编译的但未进行链接的二进制文件，一般以 .o 为结尾标识，链接器对 .o 文件进行链接处理，最终生成可执行文件(executable file)或者共享库(shared object file). 当程序运行过程中异常终止或者崩溃，操作系统会将程序当时的状态记录下来，保持在一个文件里，这就是 core dump. 可重定位目标文件：包含二进制代码和数据，其形式可以和其他目标文件进行合并，创建一个可执行目标文件。比如 linux 下的.o 文件 预处理阶段：预处理器（cpp）根据以字符#开头的命令修改原始的 C 程序，结果得到另一个 C 程序，通常以.i 作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。 命令行：gcc -E hello.c hello.i 编译阶段：将文本文件 hello.i 翻译成 hello.s，包含相应的汇编语言程序 汇编阶段：将.S 文件翻译成机器指令，然后把这些指令打包成一种可重定位目标程序的格式，并把结果保存在目标文件.o 中（汇编——&gt;机器）。 命令行：gcc -c hello.c hello.o 链接阶段：hello 程序调用了 printf 函数，链接器就把 printf.o 文件并入 hello.o 文件中，得到 hello 可执行文件，然后加载到存储器中由系统执行。 1.1 elf 文件结构常见的 ELF 文件大致结构如下：分两种视角，链接视角和执行视角 ELF 文件参与程序的连接 (建立一个程序) 和程序的执行(运行一个程序)，所以可以从不同的角度来看待 elf 格式的文件： 如果用于编译和链接（可重定位文件），则编译器和链接器将把 elf 文件看作是节头表描述的节的集合, 程序头表可选。 如果用于加载执行（可执行文件），则加载器则将把 elf 文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。 ELF 文件中的内容至少有编译后的机器指令代码、数据。除了这些内容以外，ELF 文件中还包括了其他的信息，比如符号表、调试信息、字符串等。 一般 ELF 文件将这些信息按不同的属性，以 Section 的形式存储，根据其内容在内存中是否可读写等，在 ELF 中把权限相同、又连在一起的 section 叫做 segment，操作系统正是按照“segment”来映射可执行文件的。 典型的 section 如下： .text 已编译程序的二进制代码 .rodata 只读数据段，比如常量 .data 已初始化的全局变量和静态变量 .bss 未初始化的全局变量和静态变量，所有被初始化为 0 的全局变量和静态变量 1.2 elf 头部 用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等。 文件的最开始几个字节给出如何解释文件的提示信息。这些信息独立于处理器，也独立于文件中的其余内容。ELF Header 部分可以用以下的数据结构表示: 12345678910111213141516typedef struct &#123; unsigned char e_ident[EI_NIDENT]; /* magic number and other info */ Elf64_Quarter e_type; /* file type */ Elf64_Quarter e_machine; /* machine type */ Elf64_Half e_version; /* version number */ Elf64_Addr e_entry; /* entry point virtual address */ Elf64_Off e_phoff; /* Program head table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Half e_flags; /* Processor flags */ Elf64_Quarter e_ehsize; /* sizeof elf header */ Elf64_Quarter e_phentsize; /* Program header entry size */ Elf64_Quarter e_phnum; /* Number of program headers */ Elf64_Quarter e_shentsize; /* Section header entry size */ Elf64_Quarter e_shnum; /* Number of section headers */ Elf64_Quarter e_shstrndx; /* Section header string table index */&#125; Elf64_Ehdr; 1.3 program header table描述 segment 的结构叫做 program header table，在可执行文件或者共享目标文件里它描述了各个 segment 在 elf 文件里的位置，以及在程序执行过程中系统需要准备的其他信息，用来告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。 1.4 section header table包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。 2.GOT 和 PLT HOOKGOT&#x2F;PLT HOOK 是 ELF 文件函数 hook 的一种实现机制，GOT&#x2F;PLT Hook 主要用于实现替换某个 SO 的外部调用，它的优点是非常稳定，因此在生产环境通常使用这种实现方案。 示例：使用了 PLT Hook 将 libart.so 中的外部函数 pthread_create 替换成自己的方法 GOT&#x2F;PLT Hook 的方案命名 主要是因为该方案主要是通过修改 ELF 文件结构中的 GOT (The Global Offset Table) 和 PLT(The Procedure Linkage Table) 段的地址来实现的 The Global Offset Table (GOT): 是一个存储外部库函数的表。简单来说就是在数据段的地址表，作用是用来记录代码中引用到的外部符号的地址映射。这里的符号包括，变量、函数等。假定我们有一些代码段的指令引用一些地址变量，编译器会引用 GOT 表来替代直接引用绝对地址，因为绝对地址在编译期是无法知道的，只有重定位后才会得到，GOT 自己本身将会包含函数引用的绝对地址。 The Procedure Linkage Table (PLT)：由代码片段组成的，每个代码片段都跳转到 GOT 表中的一个具体的函数调用。PLT 不同于 GOT，它位于代码段，动态库的每一个外部函数都会在 PLT 中有一条记录，每一条 PLT 记录都是一小段可执行代码。 一般来说，外部代码都是在调用 PLT 表里的记录，然后 PLT 的相应记录会跳转到 GOT 表中的一个具体的函数调用。我们一般把这种设定叫作“蹦床”（Trampoline）。 外部函数调用在在编译期是无法知道的，编译器会引用 GOT 表来替代直接引用绝对地址。只有重定位后才会得到，GOT 自己本身将会包含函数引用的绝对地址。 外部函数 func 在编译时会转为 func@plt，并在 PLT 表中插入一条记录。PLT 表中都是一段段可执行代码，这里面会跳到 GOT 表中进行解析，解析完毕后动态链接器会将这个实际地址填入 GOT 中。 当第一次调用发生后，之后再调用函数 func 就高效简单很多。程序仍然会先调用 PLT，然后 PLT 也会跳到 GOT 中。GOT 此时由于已经存储了实际地址，可以直接指向 func，这样就高效的完成了函数调用。 PLT 和 GOT 记录是一一对应的，并且 GOT 表第一次解析后会包含调用函数的实际地址。既然这样，那 PLT 的意义究竟是什么呢？PLT 从某种意义上赋予我们一种懒加载的能力。很多函数可能在程序执行完时都不会被用到，比如错误处理函数或一些用户很少用到的功能模块等，那么一开始把所有函数都链接好实际就是一种浪费。为了提升动态链接的性能，我们可以使用 PLT 来实现延迟绑定的功能。当动态库首次被加载时，所有的函数地址并没有被解析。此时 plt 跳到 got 表，但是 got 表也是空的，所以 GOT 表中初始对应的指令又会跳回到源函数对应 PLT 表位置中的第二条指令，去跳转到 GOT 表中保存了 dl_runtime_resolve 地址的位置. 当执行 dl_runtime_resolve 解析出动态库函数的地址后,会将真实的地址写回到 GOT 表中,这样第二次调用该函数时就需要经过动态库解析了. 业界通常会根据修改 PLT 记录或者 GOT 记录区分为 GOT Hook 和 PLT Hook，但其本质原理十分接近。GOT&#x2F;PLT Hook 主要是通过解析 SO 文件，将待 hook 函数在 got 表的地址替换为自己函数的入口地址，这样目标进程每次调用待 hook 函数时，实际上是执行了我们自己的函数。但是他们只能 Hook 动态库之间的调用的函数，并且无法 Hook 未导出的私有函数 注：导出表指将当前动态库的一些函数符号保留，供外部调用，导入表中的函数实际是在该动态库中调用外部的导出函数 例如导入表存放的是一些其他 so 的函数，例如 libc 的 open，而导出表存放的是一些共其他 so 调用的函数，比如自己 so 中编写的函数，而无论导入表还是导出表基本都是针对导出函数，针对非导出函用 inlinehook 更常用一些 PLT 具体实现参见 xHook 的实现 https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md 微信 Matrix 开源库的 ELF Hook，它使用的是 GOT Hook，主要使用它来做性能监控。（微信 Matrix 里面的 hook 已经换成了爱奇艺的 xHook 了） 爱奇艺开源的的 xHook，它使用的也是 PLT Hook。https://github.com/iqiyi/xHook 以上参考文章： https://blog.yorek.xyz/android/3rd-library/xhook/#4-elf-xhook https://blog.yorek.xyz/android/paid/master/native_hook/#_1 https://www.jianshu.com/p/0ac63c3744dd 这种 Hook 方法也不是万能的，因为它只能替换导入函数的方式。有时候我们不一定可以找到这样的外部调用函数。如果想 Hook 函数的内部调用，这个时候就需要用到 Inline Hook 了。 3.Inline hookInline hook 是终极 hook 手段，通过直接修改运行时内存的方式替换指令，完全手工的完成 hook 及跳回操作，理论上可以实现任意位置的 hook，不过手写指令时需要考虑 abi 兼容等众多因素，实现难度较高 指令级别的 hook 跟高级语言层面的实现方式在感官上有很大区别，高级语言中不管借助什么手段，只需将 hook 代码织入到目标代码之中即可，但这种方式在指令级别是行不通的，见下图： 操作系统将程序指令成段装载到内存里，我们手动把若干指令插入到某个位置就是改动了程序装载后的内存结构，这意味着程序需要重新做地址重定位才能正常运行，这本该由链接器完成的工作换成人工来计算几乎是不可能的，所以这肯定不是实现 hook 的正确方式。 为了保持内存结构不变，正确的方法是使用指令替换而不是指令插入的方式来实现 hook，见下图： 假设目标方法内有 ins0, ins1, ins2 三条指令，首先将起始指令（两条指令）替换为等长的跳转指令 jump_ins（一条 LDR,一条要跳转的地址），jump_ins 负责跳转到 hook 方法执行。 而 hook 操作后，往往还需要保留调用原方法的能力以保证功能可用性，所以 hook 方法内还有一个跳转指令来调回原方法继续执行（jump ins1），调回前需要先补充执行目标方法已被替换的原始指令（图中 ins0），保证原方法完整性。 综上，inline hook 需要完成的工作就是图中绿色的部分，即跳转指令的替换、补充执行原指令、跳回原方法继续执行这三步。 3.1 跳转指令先简单熟悉下 ARM 的常用指令集 以 B 开头的指令是专门的跳转指令，不过在这里不适用 inline hook 的场景，因为它们只用来完成 32MB 以内的相对地址的跳转，而我们无法保证 hook 方法在这个范围内。 如何实现绝对地址的跳转呢？回忆下，还记得 PC 这个特殊地位的寄存器吗？它存储着程序当前执行的指令地址，换句话说，CPU 执行的指令是从 PC 指向的地址取出来的，那么我们将一个目标地址写入 PC 就实现了绝对地址的跳转，对应的是写入寄存器的指令：LDR。查询文档，LDR 指令格式如下： 大括号内的可选参数暂时不管，指令格式可归纳为 LDR Rd, ，其中 Rd 为目标寄存器，中括号内为得出一个绝对地址的表达式，表达式内部可能用到 Rn 和 Rm 两个寄存器作为操作数，也可能是一个立即数。 假设想要跳转的地址是 0x11111111，那么将该地址写入 PC 的指令就是 LDR PC, 0x11111111，可随即遇到一个问题，ARM 下每条指令的长度是 32 位，而地址长度也是 32 位，将一个绝对地址写入一个指令里显然是不可能的，像 LDR PC, 0x11111111 这样的指令是无法写入内存的。那么该如何在一条指令的空间里写入一个绝对地址的表达式呢？ 3.2 寄存器间接寻址注意到一个寄存器的容量也是 32 位，刚好能装下一个绝对地址，所以可以把目标地址先存到某个寄存器（Rm）中，然后执行 LDR PC, Rm 就实现了绝对地址的跳转，这种以某个寄存器作为基准的寻址方式叫做寄存器间接寻址。 再进一步，在实际开发中我们发现 PC 寄存器就是一个天然的铆点，并且想要跳转的目标地址往往离程序当前执行到的地址不远，所以索性用 PC 加上一个偏移量来表达一个绝对地址，格式为：LDR PC, [PC, offset]，这种寻址方式又叫 PC 相对寻址。使用 PC 相对寻址，我们可以用 8 个字节（即 2 条指令的长度）来完成一个绝对地址的跳转操作： 0x00006000 位置的指令含义为当 CPU 执行到此时，将该地址加 4 字节-即 0x00006004 地址内的内容写入到 PC 中，而内容就是我们事先写入的目标地址。 到此跳转指令似乎完成了，可实际上还需要做一个调整，由于 ARM 下 CPU 遵循三级流水的执行流程，PC 并不指向当前指令，见下图： 三级流水可以近似理解为三线程并行。三级流水将 CPU 运行拆解为三个步骤：取指、转译、执行。 取指单元在取出一条指令后，会交给下游-转译单元进行翻译，转而继续取下一条指令，无需等待该指令后续的步骤。 三个单元有各自的流水线，这样造成的结果就是 PC（即取指单元）总是指向正在执行的指令往后两条指令的地址位置，如图当 CPU 执行 ADD 指令时，Fetch 已取到了 CMP 指令，领先了 ADD 两条指令的距离。依据此，需要对上面的跳转指令做如下调整： 可以看到，从 PC+4 变成了 PC-4，PC-4 其实是[PC-8]+4。即当 CPU 执行到 0x00006000 时 PC 已经指向了 0x00006000+2*4 的位置，需要先减去 8 字节才得到当前执行位置，再加 4 字节便得到 0x00006004。 将指令写入内存时需要翻译为机器码，根据文档，LDR 命令的机器码格式为： 根据文档将指令 LDR PC, [PC, -4]翻译为 32 位的二进制机器码： 其中 28-31 位表示执行条件，1110 代表总是执行，26-27 位 01 表示 LDR，后面到 20 位是 6 个独立标志位，其中第 23 位 U 为 0 表示做减法，Rn 表示基准寄存器编号，1111 即为 15，表示 r15，也就是 PC，Rd 表示目标寄存器，也是 PC，0-11 位用来存储立即数，100 就是 4，这就是 LDR PC, [PC, -4]的机器码，转换成 16 进制是 0xe51ff004。最终得到跳转 hook 方法地址的程序内容如下： 跳回指令和跳转指令格式一样，只是将目标地址从 hook 方法的起始地址改为原函数继续执行的地址，其中 return address &#x3D; 目标方法起始地址 + 替换指令长度 &#x3D; 目标方法起始地址 + 8 字节 3.3 指令修复完成了跳转和跳回指令，剩下的操作就只有补充执行原函数中被替换的原始指令了。这步是 inline hook 最复杂的一步，也是 inline hook 的难度所在。 以上流程看似一切正常，cpu 的现场都被保存和恢复了, 但是如果说被替换的两条指令，在恢复执行的时候，有用到 pc 寄存器的值，这两条指令的执行位置是在 stub 跳板函数中，并不是原函数，所以 pc 的值并不是预期的值，这种情况就要进行执行指令修复。 回忆下前面提到的 PC 相对寻址，实际上这种寻址方式应用相当广泛，带来的结果就是指令往往与当前的 PC 值强绑定。当我们手动修改程序流程，跳到 hook 方法再回头执行原始指令时，PC 已不再是原始指令预期的值，毫无疑问会执行异常。所以执行原始指令前要进行指令修复，修复方法就是将指令中 PC 的值修改为预期的值（注意并不是修改 PC，只是修改指令中的表示 PC 值的那几位数据）。 指令修复需要涵盖 PC 相关的所有指令类型，这里只用 ADD 指令来举例说明： ADD Rd, [PC, Rm] 对上面指令进行修复，可以预见指令的机器码中第一个操作数那几位肯定是 1111（即 r15&#x3D;PC），我们需要将其改为一个其他寄存器 Rx，而 Rx 中存入该指令预期的 PC 值，即指令被替换前的 PC 值。这样就完成了加法指令的修复，其他类型指令的修复方式大同小异，基本思想都是 PC 值替换 参考：https://www.jianshu.com/p/2684e251124dhttps://blog.csdn.net/spinchao/article/details/108300557#31__433 3.4 Inline hook 检测Inline Hook 根据使用场景不同，其跳转方式主要有以下 5 种： 故 InlineHook 的检测思路为：对函数的指定偏移处指令进行检测，若满足上述机器码特征，则可断定存在 InlineHook。 以对 timeGetTime 的检测为例： 这是网上找的 x86 上的检测方案，但是应该可行性不高，因为这种指令太多了，根本不能判断是不是 inline hook 的操作。 arm32 上由于这种跳转指令有固定的格式，如 LDR PC, [PC, #-4] 然后紧接着 destination address，这样紧连着的两条指令反而特征更特别一点。 当然还有其他检测方案，比如说对比内存中的.text 段和文件中的.text 的 crc 是否相等，大致流程： 解析&#x2F;proc&#x2F;self&#x2F;maps 匹配到你需要检测的 so 文件，获取其的加载基地址和文件路径 通过 mmap 将文件映射到内存，然后把内容传给 ELF 解析工具，获取其.text 段的偏移和大小 通过偏移+加载基地址 和 偏移+mmap 返回值 以及.text 段大小来计算 crc，并比对 3.5 SandHook简单的来说就是 inline hook。 将目标方法的前 (arm32-2&#x2F;arm64-4) 行代码拷贝出来，换上跳转代码跳到一个汇编写的二级跳板，二级跳板再确定当前方法需要 Hook 之后，跳转到 Hook 方法。 除此之外，考虑到 N 以上方法有可能是解释执行，手动调用 JIT 有可能编译失败 (很少见)，也保留了 ArtMethod 入口替换的逻辑 (类似 YAHFA)。 使用场景：本进程的 Hook 不是我们想要的。我们想要将 Hook 作用于其他进程则必须将 Hook 逻辑注入到目标进程。 Root 注入 非 Root 注入，沙箱环境 代码植入 3.5.1 Root 注入 全局注入，一般选择注入 Zygote 进程 原版 Xposed 修改了 app_process 的源码，在其中加入加载 Xposed 框架的逻辑 Edxposed 依赖 “Riru”，Riru 伪造了 libmemtrack.so，在其中加入了加载 “模块” 逻辑，libmemtrack 是 Zygote 的必备库，这个库比较简单，所以成为了目标 使用 Zygote 的注入，所有 android 进程都将附带 Xposed 的 lib，所以为 “全局注入” 单进程注入，ptrace 使用 ptrace，核心在于找到 mmap&#x2F;dlopen&#x2F;dlsym 等函数在目标进程的地址 问题在于无法绕过目标进程的反调试保护，另外容易错过 Hook 时机，也可以注入 Zygote 3.5.2 非 Root 注入一般基于沙箱 app，如 VirtualAPP 实现 在不使用 xposed 的情况下，核心在于利用同 UID 免 Root 使用 ptrace，步骤和上面 Root 注入相同 如果沙箱在加载内部 app 进程时主动加载 Xposed 插件，这样就不会错过 Hook 时机，也不存在反调试问题，然而稳定性取决于沙箱本身的稳定性 类似 VirtualXposed https://github.com/asLody/SandVXposed 3.5.3 代码植入解包目标 apk，植入 Xposed 代码，重打包 需要 Hook 处理 apk 完整性检查，签名验证，处理加壳 类似太极","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"NDK开发学习","slug":"Study/语言学习/NDK开发","date":"2023-08-05T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/05/Study/语言学习/NDK开发/","link":"","permalink":"https://beichen.link/2023/08/05/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/NDK%E5%BC%80%E5%8F%91/","excerpt":"","text":"NDK 即 Native Development Kit，是 Android 上用来开发 c&#x2F;c++的开发工具包 JNI 是 Java Native Interface 的缩写，即 Java 的本地接口。 目的是使得 Java 与本地其他语言（如 C&#x2F;C++）进行交互，更方便和快速开发 C&#x2F;C++ 的动态库，并自动将动态库与应用一起打包到 apk。NDK 是属于 Android 的，与 Java 无直接关系。 JNI 是属于 Java 的，与 Android 无直接关系。 一 CmakeNDK 支持的编译方式有两种： CMake：NDK 的默认构建工具，可在 CMakeLists.txt 构建脚本中配置编译选项 ndk-build：可在 Android.mk 和 Application.mk 文件中配置编译选项 CMakeLists.txt 是 CMake 的构建脚本，在 CMakeLists.txt 中可以使用 cmake 的一些命令来自定义构建过程. 123456789101112131415161718192021222324252627282930313233cmake_minimum_required(VERSION 3.4.1)# set:给变量赋值set(libs &quot;$&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs&quot;)set(SOURCES src/main/cpp/native-lib.cpp src/main/cpp/native-lib2.cpp)# if-endif:cmake的逻辑控制if(IS_ANDROID) message(&quot;Building for Android&quot;) add_definitions(-DIS_ANDROID)else() message(&quot;Building for others&quot;)endif(IS_ANDROID)add_library( hello-jni # so 库的名称 libhello-jni.so SHARED # 设置为分享库,动态库用SHARED 静态库用STATIC # 指定C源文件的路径，指向公共cpp-src目录 ../../../../cpp-src/hello-jni.c src/main/cpp/native-lib.cpp)find_library( log-lib # 设置路径变量名称 log # 指定CMake需要加载的NDK库)# 链接hello-jni库依赖的库，注意下面变量名的配置,首个参数是target,后面的参数是item；target必须先用add_library()创建过target_link_libraries(hello-jni $&#123;log-lib&#125;) 在 build.gradle 中配置 cmake，即可将二者关联起来，关联后在 gralde 构建的过程中就会构建 native 代码： 1234567891011121314151617181920212223242526272829android &#123; defaultConfig &#123; ndk &#123; // 指定编译的abi架构 abiFilters &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot; &#125; externalNativeBuild &#123; // cmake配置 cmake &#123; //Sets optional flags for the C++ compiler. cppFlags &quot;-std=c++11 -frtti -fexceptions&quot; // Passes optional arguments to CMake toolchain. arguments &quot;-DANDROID_STL=c++_shared&quot; arguments &quot;-DANDROID_TOOLCHAIN=gcc&quot; &#125; &#125; &#125; // Use this block to link Gradle to your CMake or ndk-build script // 将gralde关联到cmake构建脚本 externalNativeBuild &#123; cmake &#123; // 构建脚本路径 path &quot;src/main/cpp/CMakeLists.txt&quot; version &quot;3.10.2&quot; &#125; &#125;&#125; 二 JNI 基础JNI 即 java native interface，是 java 和 native 代码进行交互的接口； 2.1 数据类型 在 JVM 虚拟机中，存储数据类型的名称时，是使用指定的描述符来存储，而不是我们习惯的 int，float 等。 2.2 JavaVM 和 JNIEnvJNI 定义了两个关键数据结构“JavaVM”和“JNIEnv”，两者本质上都是指向函数表的二级指针。（在 C++版本中，它们被定义为类，该类包含一个指向函数表的指针，以及一系列可以通过这个函数表间接地访问对应的 JNI 函数的成员函数） JavaVM 是虚拟机在 JNI 层的代表. Android 中每个进程只允许有一个 JavaVM, JNIEnv 作用域为单个线程,所有的线程共用一个 JavaVM。 可通过 JavaVM 的 getEnv 来获得当前线程的 JNIEnv，JNIEnv 可通过 GetJavaVM 来获得 JavaVM。 JNIEnv 表示 Java 调用 native 语言的环境，是一个封装了几乎全部 JNI 方法的指针。使用者定义的所有 Native 函数都会接收 JNIEnv 作为第一个参数。JNIEnv 只在创建它的线程生效，不能跨线程传递，不同线程的 JNIEnv 彼此独立。 JNIEnv 是用作线程局部存储。因此，使用者不能在线程间共享一个 JNIEnv 变量。如果在一段代码中没有其它办法获得它的 JNIEnv，使用者可以共享 JavaVM 对象，使用 GetEnv 来取得该线程下的 JNIEnv native 环境中创建的线程，如果需要访问 JNI，必须要调用 AttachCurrentThread 关联，并使用 DetachCurrentThread 解除链接。 2.3 JNI 静态注册和动态注册当执行一个 Java 的 native 方法时，虚拟机是怎么知道该调用 so 中的哪个方法呢？这就需要用到注册的概念了，通过注册，将指定的 native 方法和 so 中对应的方法绑定起来（函数映射表），这样就能够找到相应的方法了。 注册分为 静态注册 和 动态注册 两种。默认的实现方式即静态注册。 静态注册的方式是系统的默认方式，系统在编译时自动调用，使用简单，但是灵活性比较差，如果修改了 Java 中的 Native 函数所在类的包名或类名，则需要同时修改 C&#x2F;C++函数名称（头文件、源文件等）。 相比静态注册，动态注册的灵活性更高，如果修改了 java native 函数所在类的包名或类名，仅调整 Java native 函数的签名信息即可。 1 静态注册通过 JNIEXPORT 和 JNICALL 两个宏定义声明，在虚拟机加载 so 时发现上面两个宏定义的函数时就会链接到对应的 native 方法。 命名规则：Java + 包名 + 类名 + 方法名 其中使用下划线将每部分隔开，包名也使用下划线隔开，如果名称中本来就包含下划线，将使用下划线加数字替换。 在 cpp 目录下，新建 native_lib.cpp，添加对应的 native 实现： 12345678910111213#include &lt;jni.h&gt;#include &lt;string&gt;// JNIEXPORT JNICALL、参数里的前两个参数 JNIEnv* env,jobject obj 等是固定格式；固定参数中的 jobject obj 表示 thisextern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_bc_sample_NativeDemo_stringFromJNI(JNIEnv* env,jobject obj) &#123;std::string hello = &quot;Hello from C++&quot;;return env-&gt;NewStringUTF(hello.c_str());&#125; 必须遵循注册规则，名字过长，运行时去找效率不高 2 动态注册通过 RegisterNatives 方法手动完成 native 方法和 so 中的方法的绑定，这样虚拟机就可以通过这个函数映射表直接找到相应的方法了。 在 cpp 目录下，新建 native_lib.cpp，在 JNI_OnLoad 时调用 env-&gt;RegisterNatives 进行注册（JNI_OnLoad 是在动态库被加载时由系统进行调用）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 需要注册jni方法所在的类#include &lt;jni.h&gt;#include &lt;string&gt;#include &quot;log.hpp&quot;extern &quot;C&quot; &#123;static const char *jniClassName = &quot;com/bc/sample/NativeDemo&quot;;// native实现，第一个参数 JNIEnv 是指向可用JNI 函数表的接口指针；，第二个参数jobject 是 该实例的java对象的引用jstring stringFromJNI(JNIEnv *env, jobject instance) &#123; std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());&#125;jint add(JNIEnv *env, jclass clazz, jint a, jint b) &#123; return a + b;&#125;jint RegisterNatives(JNIEnv *env) &#123; jclass clazz = env-&gt;FindClass(&quot;com/afei/jnidemo/MainActivity&quot;); if (clazz == NULL) &#123; LOGE(&quot;con&#x27;t find class: com/afei/jnidemo/MainActivity&quot;); return JNI_ERR; &#125; // 需要注册的jni方法，分别表示java方法名、方法签名、native函数指针 // 方法签名可以用javap命令查看： // javap -s /Users/bc/Demo/app/build/intermediates/javac/debug/classes/com/bc/sample/NativeDemo.class JNINativeMethod methods_MainActivity[] = &#123; &#123;&quot;stringFromJNI&quot;, &quot;()Ljava/lang/String;&quot;, (void *) stringFromJNI&#125;, &#123;&quot;add&quot;, &quot;(II)I&quot;, (void *) add&#125; &#125;; // int len = sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]); //第一个参数是Java对应的类，第二个参数是JNINativeMethod数组，第三个参数是JNINativeMethod数组的长度，也就是需要注册的方法的个数。 return env-&gt;RegisterNatives(clazz, methods_MainActivity, sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]));&#125;jint JNI_OnLoad(JavaVM *vm, void *reserved) &#123; JNIEnv *env = NULL; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; return JNI_ERR; &#125; jint result = RegisterNatives(env); LOGD(&quot;RegisterNatives result: %d&quot;, result); return JNI_VERSION_1_6;&#125;&#125; 2.4 jclass, jmethodID, jfieldID如果使用者想在 Native 代码中访问一个对象的字段（field）,可以做如下操作： 对于类，使用 FindClass 获得类对象的引用 对于字段，使用 GetFieldId 获得字段 ID 使用对应的方法（例如 GetIntField）获取字段下面的值 类似地，要调用一个方法，使用者首先得获得一个类对象的引用，然后是 GetMethodID 获得方法 ID（method ID）。 2.5 JNI 中全局引用和局部引用的区别和使用全局引用通过 NewGlobalRef 和 DeleteGlobalRef 方法创建和释放一个全局引用。 全局引用能在多个线程中被使用，且不会被 GC 回收，只能手动释放。 局部引用通过 NewLocalRef 和 DeleteLocalRef 方法创建和释放一个局部引用。 局部引用只在创建它的 native 方法中有效，包括其调用的其它函数中有效。因此我们不能寄望于将一个局部引用直接保存在全局变量中下次使用（请使用全局引用实现该需求）。 我们可以不用删除局部引用，它们会在 native 方法返回时全部自动释放，但是建议对于不再使用的局部引用手动释放，避免内存过度使用。 扩展：弱全局引用通过 NewWeakGlobalRef 和 DeleteWeakGlobalRef 创建和释放一个弱全局引用。 弱全局引用类似于全局引用，唯一的区别是它不会阻止被 GC 回收。 2.6 定位 NDK 中的问题和错误一般在开发阶段的话，我们可以通过 log 来定位和分析问题。 如果是上线状态（即关闭了基本的 log），我们可以借助 NDK 提供的 addr2line 工具和 ndk-stack 工具来定位错误。 Addr2line 工具是一个可以将指令的地址和可执行映像转换成文件名、函数名和源代码行数的工具，ndk-stack 类似 objdump 是 gcc 工具，用来查看编译后目标文件的组成，汇编","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Android 漏洞介绍","slug":"Study/Android漏洞/漏洞学习","date":"2023-08-03T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/08/03/Study/Android漏洞/漏洞学习/","link":"","permalink":"https://beichen.link/2023/08/03/Study/Android%E6%BC%8F%E6%B4%9E/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"activity 生命周期 Activity 第一次启动，回调如下：onCreate -&gt; onStart -&gt; onResume 打开新 Activity 或按 Home 键：onPause-&gt;onStop 如果新的 Activity 的 Theme 为 Dialog 或者 Translucent（透明）时不会调用 onStop 方法 再次回到 Activity：onRestart-&gt;onStart-&gt;onResume 按 Back 键退出 Activity：onPause-&gt;onStop-&gt;onDestroy Activity 的生命周期是一一对应的，比如： onCreate - onDestroy 创建与销毁，只可能为一次调用 onStart - onStop 可见与不可见，可能为多次调用 onResume - onPause 在前台与不在前台，可能为多次调用 通常开发者只需要实现 onCreate 方法，但是对于一些复杂的业务场景，正确理解其生命周期也是很必要的。以笔者在内测中遇到的某应用为例，其中某个 Activity 中执行了一些敏感的操作，比如开启摄像头推流，或者开启了录音，但只在 onDestroy 中进行了推流&#x2F;录音的关闭。这样会导致在 APP 进入后台时候，这些操作依然在后台运行，攻击者可以构造任务栈使得受害者在面对恶意应用的钓鱼界面时候仍然执行目标应用的后台功能，从而形成特殊的钓鱼场景。正确的做法应该是在 onPaused 回调中对敏感操作进行关闭。 攻击者实际可以通过连续发送不同的 Intent 去精确控制目标 Activity 生命周期回调函数的触发时机，如果开发时没有注意也会造成应用功能的状态机异常甚至是安全问题。 Intent 启动 Activity我们要启动 Activity，完成各个 Activity 之间的交互，我们需要使用 Android 中一个重要的组件 Intent Intent 是各个组件之间交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，而且还能在各组件之间传递数据。Intent 一般可用于启动 Activity、启动 Service、发送广播等场景。 Intent 有多个构造函数的重载 123Intent（Context packageContext,Class&lt;?&gt; cls）//参数 1：启动活动的上下文 参数 2：想要启动的目标活动Intent(String action)Intent(String action, Uri uri) 我们构建好一个 Intent 对象后，只需要使用 startActivity(Intent)来启动就可以了 Intent 一般分为显式 Intent 和隐私 IntentIntent 的主要形式有两种，分别是显式 Intent 和隐式 Intent；二者的差别主要在于前者显式指定了 Component，后者没有指定 Component，但是会通过足够的信息去帮助系统去理解意图，比如 ACTION、CATAGORY 等。 显式 Intent 打开 Activity 如下：12345Intent intent = new Intent(MainActivity.this, SecondActivity.class); //实例化Intent对象//使用putExtra传递参数，参数1：键名 参数2：键对应的值 我们可以使用intent.getStringExtra(&quot;et1&quot;)获取传递的参数intent.putExtra(&quot;et1&quot;,et1Str);//启动Intent，完成从MainActivity类跳转到SecondActivity类startActivity(intent); 当然，也可以使用 setComponent 或者 setClassName 方法来显式构造 intent，如 123456789ComponentName componentName = new ComponentName(getPackageName(),&quot;com.xx.xx.SecondActivity&quot; );Intent intent = new Intent();intent.setComponent(componentName);startActivity(intent);intent.setClassName(getPackageName(),&quot;com.xx.xx.SecondActivity&quot;);startActivity(intent); 隐式 Intent 打开 Activity:123456&lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.test.ACTION_START&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; IntentFilter 是 manifest 文件中组件内部的一个标签，该标签描述了组件具备什么特性，如果您未配置 intent-filters，那个该组件只能被显式启动。我们在 mainfest 中设置的 intent-filters 如果可以匹配某个隐式 Intent 那么该组件就可以被启动。IntentFilter 在做匹配时主要是根据 action, type, category 这三个属性且匹配优先级是：action&gt;data&gt;category 隐式 Intent 并不指明启动哪个 Activity 而是指定一系列的 action 和 category，然后由系统去分析找到合适的 Activity 并打开，action 和 category 一般在 AndroidManifest 中指定 只有&lt;action&gt;和&lt;category&gt;中的内容能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应 Intent, 这里只有 action 和 category，其实 data 字段也可以做 intent filter 12Intent intent = Intent(&quot;com.example.test.ACTION_START&quot;)；startActivity(intent)； 我们这里只传入了 ACTION_START，这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用 startActivity()时会自动将这个 category 添加到 Intent 中 Activity 漏洞导出组件导致越权绕过activity 中支持许多属性。其中一个重要的属性就是 android:exported，表示当前 Activity 是否可以被其他 APP 应用的组件启动。该属性有几个特点： 属性可以缺省，缺省值默认为 false； 如果 Activity 没有显式设置该属性，且该 Activity 中定义了 ，那么缺省值就默认为 true； 也就是说，开发者可能没有显式指定 Activity 导出，但由于指定了 intent-filter，因此实际上也是导出的，即可以被其他应用唤起对应的 Activity。这种情况在早期很常见，比如 APP 设计了一组更换密码的界面，需要先输入旧密码然后再跳转到输入新密码的界面，如果后者是导出的，攻击者就可以直接唤起输入新密码的界面，从而绕过了旧密码的校验逻辑。 Google 已经深刻意识到了这个问题，因此规定在 Android 12 之后，如果应用的 Activity 中包含 intent-filter，就必须要显式指定 android:exported 为 true 或者 false，不允许缺省。在 Android 12 中未显式指定 exported 属性且带有 intent-filter 的 Activity 的应用在安装时候会直接被 PackageManager 拒绝。 Intent 重定向那么如果三方 APP 要想访问非导出的 Activity 是不是就没有办法了呢？ 当然不是! 其中一种常见的方式即：将 Intent 类的对象作为 Intent 的 Extras 通过一个导出组件传递给非导出的组件, 以此来实现访问非导出的 Activity。 原理在于，Android 组件之间传输的 Intent 类是实现了 Parcelable 的。 1public class Intent implements Parcelable, Cloneable &#123;&#125; 因此可以将属于 Intent 类的对象作为 Intent 的 extra 数据对象传递到另一个组件中，相当于在 Intent 中嵌入 Intent。 这时，如果 App 从不可信 Intent 的 Extras 字段中提取出嵌入的 Intent，然后对这个嵌入 Intent 调用 startActivity（或类似的 startService 和 sendBroadcast），这样做是很危险的； 因为攻击者原本是无法访问非导出的组件的，但是通过 intent 重定向，即以导出的组件作为桥即可以访问非 exported 的组件，达到 launch anywhere 或者 broadcast anywhere 的目的。 1234protected void onCreate (Bundle savedInstanceState) &#123; Intent target = (Intent) getIntent().getParcelableExtra(&quot;target&quot;); startActivity(target);&#125; 上述代码将用户传入的 target Parcelable 直接转换成了 Intent 对象，并将这个对象作为 startActivity 的参数进行调用。就这个例子而言，可能造成的危害就是攻击者可以用任意构造的 Intent 数据去启动目标 APP 中的任意应用，哪怕是未导出的私有应用。而目标未导出的应用中可能进一步解析了攻击者提供的 Intent 中的参数，去造成进一步的危害，比如在内置 Webview 中执行任意 Javascript 代码，或者下载保存文件等。 Intent 重定向可能导致以下安全问题： 启动非导出组件，通过精心构造的可控的 Intent 参数来执行敏感操作，如果可以重写或者替换 native 库，甚至还会导致任意代码执行； 可以获取非导出的 content provider 组件的 content：&#x2F;&#x2F; URI 的访问权限来窃取敏感文件. 实际上 Intent Redirection 除了可能用来启动私有 Activity 组件，还可以用于其他的的接口，包括： • startActivity[15] • startService[16] • sendBroadcast[17] • setResult[18] 注：每种方法可能还有若干衍生方法，比如 startActivityForResult 前面三个可能比较好理解，分别是启动界面、启动服务和发送广播。最后一个 setResult 可能会在排查的时候忽略，这主要用来给当前 Activity 的调用者返回额外数据，主要用于 startActivityForResult 的场景，这同样也可能将用户的不可信数据污染到调用者处。 startActivityForResult 和 setResult 这对 API 各应用使用非常普遍，比如权限动态申请、拍照预览、媒体分享、文件访问、联系人选择等等，这也是跨进程通信的一种特殊方式。这里再简单介绍一下。 startActivityForResult(Intent, int) 启动某 activity 并通过 onActivityResult(int, int, Intent) 方法接收数据。当一个活动退出时，它可以调用 setResult(int) 将数据返回给它的父级 activity，它还可以选择返回一个 Intent，其中包含通信的任何附加数据。 假设现在有一个 Activity A，从 Activity A 通过 startActivityForResult 方法启动了 Activity B，在 Activity B 销毁前，Activity B 若将一些数据回传给 Activity A，可以调用 setResult 方法，这样在 Activity B 销毁后，Activity A 重新展示时，在 Activity A 的 onActivityResult 方法就能够获取 Activity B 回传过来的数据。 从防御的角度上来说，建议不要直接把外部传入的 Intent 作为参数发送到上述四个接口中，如果一定要这么做的话，需要事先进行充分的过滤和安全校验，比如： 将组件本身的 android:exported 设置为 false，但这只是防止了用户主动发送的数据，无法拦截通过 setResult 返回的数据； 确保获取到的 Intent 来自于可信的应用，比如在组件上下文中调用 getCallingActivity().getPackageName().equals(“trust.app”)，但是需要注意的是，检查 getCallingActivity() 是否返回非 null 值或检查包名是否匹配仅在 startActivityForResult 中生效，且并不足以防范此漏洞，恶意应用可以为该函数提供 null 值，或者伪造满足条件的包名绕过校验。故此处建议在 setResult 或 onActivityResult 时对应用的身份同时进行校验，保证收到的 intent 来源于可信方。 确保待转发的 Intent 没有有害行为，比如 component 不指向自身的非导出组件，不带有 FLAG_GRANT_READ_URI_PERMISSION 等（详见后文 ContentProvider 漏洞）；应用可以使用 getFlags 等方法来检查 Intent 是否会授予 URI 权限，应用还可以使用 removeFlags 撤消 URI 权限的授予。除了上述两种方法，还可以在 setResult 前重新创建 Intent，确保不安全的 Intent 不会被传递。 ContentProvider 漏洞ContentProvider 学习FileProvider 是 Android 7.0 出现的新特性，它是 ContentProvider 的子类，可以通过创建一个 Content URI 并赋予临时的文件访问权限来代替 File URI 实现文件共享,帮助我们将访问受限的 file:&#x2F;&#x2F;URI 转化为可以授权共享的 content:&#x2F;&#x2F;URI。Intent 重定向漏洞能够使得攻击者借助受害者 APP 的身份发送一个恶意 Intent，从而达到恶意攻击的目的，比如获得原本无权访问的 FileProvider 的访问权限。 Android 7.0 之前，文件的 Uri 以 file:&#x2F;&#x2F;&#x2F; 形式提供给其他 app 访问，Android 7.0 之后，分享文件的 Uri 发生了变化。为了提高私有目录的安全性，防止应用信息的泄漏，从 Android 7.0 开始，私有目录的访问权限被限制。开发人员不再能够简单地通过 file:&#x2F;&#x2F;URI 访问其他应用的私有目录文件或者让其他应用访问自己的私有目录文件。 官方提供了替代方案——FileProvider，FileProvider 生成的 Uri 会以 content:&#x2F;&#x2F; 的形式分享给其他 app 使用。content 形式的 Uri 可以让其他 app 临时获得读取 (Read) 和写入 (Write) 权限，只要我们在创建 Intent 时，使用 Intent.setFlags() 添加权限，那么只要接收 Uri 的 app 在接收的 Activity 任务栈中处于活动状态，添加的权限就会一直有效，直到 app 被任务栈移除。 在 Android 7.0 以前，为了访问 file:&#x2F;&#x2F;&#x2F; 形式的 Uri，我们必须修改文件的权限。修改后的权限对所有 app 都是有效的，这样的行为是不安全的。 而使用了 FilePrrovider 后 content:&#x2F;&#x2F; 形式的 Uri 让 Android 的文件系统更安全，对于分享的文件，接收方 app 只拥有临时的权限，减少了我们 app 内部的文件被其他 app 恶意操作的行为。 FileProvider 的完整使用步骤： Mainfest.xml 中注册 FileProvider； 配置、指定共享目录范围 ； 使用 FileProvider 生成 Content URI； 给 Uri 授予临时权限并分享这个 URI 给另一个 App。 在 manifest 文件中添加 pvodier 标签 设置共享目录 使用 FileProvider 生成 Content URI 此处需要继续将原先所采用的 file:&#x2F;&#x2F; 替换成 FileProvoider 需要用到的 content:&#x2F;&#x2F;，这就需要用到 FileProvider.getUriForFile() 方法了 给 Uri 授予临时权限并分享这个 URI 给另一个 App 当我们生成一个 content:&#x2F;&#x2F; 的 Uri 对象之后，第三方应用其实还无法对其直接使用，还需要对这个 Uri 接收的 App 赋予对应的权限才可以。 授权方式有两种，上面的方法属于第一种.使用 intent 对象提供的 setClipData() 方法可以一次性传递多个 URI 对象，然后使用 setFlags() 或者 addFlags() 方法设置读写权限，可选常量值选择 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION。这种形式的授权方式，权限有效期截止至其它应用所处的堆栈销毁，并且一旦授权给某一个组件后，该应用的其它组件拥有相同的访问权限。 另外一种授权的方法是通过 Context 的 grantUriPermission() 方法授权. 拥有授予权限的 Content URI 后，便可以通过 startActivity() 方法启动其他应用并传递授权过的 Content URI 数据。 最终将访问到 URI 格式如下的文件：content://com.demo.fileprovider/shared_files/xxx.txt ContentProvider 越权访问除了可以访问任意组件之外，攻击者还可以访问满足以下条件的 APP 的 Content Provider 的组件： 该组件必须是非导出的（否则可以直接攻击，无需使用我们在本文中讨论的模型）； 组件还设置了 android:grantUriPermissions 为 true 同时，攻击者在实现攻击时，必须将自己设置为嵌入 Intent 的接收者，并设置以下标志： 比如在 App 中有一个非导出的 file provider，该 provider 在其私有目录的 database 路径下保存了 secret.db 文件，该文件中保存了用户的登录账号信息。 我们无法直接访问 FileProvider， 但是可以通过 Intent 重定向来窃取 secret.db 文件，Payload 如下： 123456789101112131415Intent next= new Intent();// 设置为攻击者自己的组件next.setClassName(getPackageName(), &quot;com.Attacker.AttackerActivity&quot;);//设置想要访问的私有文件的URInext.setData(Uri.parse(&quot;content://com.victim.localfile/secret.db&quot;));// 添加所有可以访问content provider的读写flagnext.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);Intent intent = new Intent();intent.setClassName(&quot;com.victim.localfile&quot;, &quot;com.victim.localfile.LoginActivity&quot;);intent.putExtra(&quot;com.victim.extra.NEXT_INTENT&quot;, next);//这样，攻击者就能从受害者activity跳到攻击者activity，并且携带了FileProvider权限startActivity(intent); Activity 点击劫持Activity 既然作为 UI 的主要载体，那么与用户的交互也是其中关键的一项功能。在传统 Web 安全中就已经有过点击劫持的方法，即将目标网站想要让受害者点击的案件放在指定位置（如 iframe），并在宿主中使用相关组件对目标进行覆盖和引导，令受害者在不知不觉中执行了敏感操作，比如点赞投币收藏一键离职等。 Android 中也出现过类似的攻击手段，比如在系统的敏感弹窗前面覆盖攻击者自定义的 TextView，引导受害者确认某些有害操作。当然这需要攻击者的应用拥有浮窗权限（SYSTEM_ALERT_WINDOW），在较新的 Android 系统中，该权限的申请需要用户多次的确认。 近两年中在 AOSP 中也出现过一些点击劫持漏洞，包括但不限于： • CVE-2020-0306：蓝牙发现请求确认框覆盖 • CVE-2020-0394：蓝牙配对对话框覆盖 • CVE-2020-0015：证书安装对话框覆盖 • CVE-2021-0314：卸载确认对话框覆盖 • CVE-2021-0487：日历调试对话框覆盖 • … 对于系统应用而言，防御点击劫持的方法一般是通过使用 android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS 权限并在布局参数中指定 SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS 来防止 UI 被覆盖 而对于普通应用，没法申请 HIDE_NON_SYSTEM_OVERLAY_WINDOWS 权限，防御措施一般有两种，一是通过将布局的 filterTouchesWhenObscured 设置为 true 来禁止窗体被覆盖后的输入事件；二是重载 View.onFilterTouchEventForSecurity 方法，并在其中检测其他应用的覆盖情况。在 Android 12 中系统已经默认开启了 filterTouchesWhenObscured 属性，这也是 security by default 的一种经典实现。 对于 CVE-2021-0314：卸载确认对话框覆盖，即恶意 APP 能够主动控制劫持的时机，可以主动请求敏感操作，在显示用户确认对话框的同时，直接在上悬浮一个虚假的对话框。 漏洞位于框架代码frameworks/base/packages/PackageInstaller/src/com/android/packageinstaller/UninstallerActivity.java， UninstallerActivity 可以接受外部 Intent 传入，并给用户提供一个卸载确认的确认框。例如，使用下列代码 123456Intent intent = new Intent();intent.setComponent(new ComponentName(&quot;com.google.android.packageinstaller&quot;, &quot;&quot; + &quot;com.android.packageinstaller.UninstallerActivity&quot;));intent.setData(Uri.parse(&quot;package:android&quot;)); // put arbitrary unstallable package name herestartActivity(intent); 将请求卸载包名 android，并展现如下对话框 若恶意 APP 已被授予 SYSTEM_ALERT_WINDOW 权限，那么可以在请求卸载用户手机上一个已经安装的 app 的同时，展现一个虚假的对话框覆盖在正常的对话框之上。 12345678Intent intent = new Intent();intent.setComponent(new ComponentName(&quot;com.google.android.packageinstaller&quot;, &quot;&quot; + &quot;com.android.packageinstaller.UninstallerActivity&quot;));intent.setData(Uri.parse(&quot;package:android&quot;)); // put arbitrary unstallable package name herestartActivity(intent);Intent intent2 = new Intent(MainActivity.this, FloatingButtonService.class);startService(intent2); 注意虚假对话框其实只覆盖了正常对话框中除按钮以外的其他部分，下面的按钮还是属于 PackageInstaller 应用的，当用户点击 OK 时，其实已经卸载了恶意 APP 请求卸载的 package，而此时恶意 APP 也已经监听到了 ACTION_OUTSIDE 事件，于是主动退出。在整个欺骗过程中，用户难以察觉自己其实已经确认了一次卸载操作。 除了”主动请求、主动劫持”这种恶意 APP 可以主动控制劫持时机的情况，恶意 APP 还可以监听用户确认对话框出现的其他时机，例如有特定的广播事件、特定的通知，在时机出现的时候进行劫持。例如，在重要对话框出现时，将出现一个通知，恶意 APP 可以监听通知该通知的出现，通过实现一个 NotificationListenerService，捕捉特定的通知，并启动服务，在原有对话框之上悬浮一个欺骗的对话框 对于系统应用而言，防御点击劫持的方法一般是通过使用 android.permission.HIDE_NON_SYSTEM_OVERLAY_WINDOWS 权限并在布局参数中指定 SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS 来防止 UI 被覆盖。 而对于普通应用，没法申请 HIDE_NON_SYSTEM_OVERLAY_WINDOWS 权限，防御措施一般有两种，一是通过将布局的 filterTouchesWhenObscured 设置为 true 来禁止窗体被覆盖后的输入事件；二是重载 View.onFilterTouchEventForSecurity 方法，并在其中检测其他应用的覆盖情况。在 Android 12 中系统已经默认开启了 filterTouchesWhenObscured 属性，这也是 security by default 的一种经典实现 Webview 漏洞Android WebView 在 Android 主要用来显示和渲染 Web 页面、直接使用 html 文件（网络上或本地 assets 中）作布局、可和 JavaScript 交互调用 webview 的基本使用WebView 的最简单的使用方式即是直接显示网页内容，有以下两个步骤： 在布局文件中添加 WebView 控件； 在代码中让 WebView 控件加载显示网页。 Webview 加载 URL 有三种方式：1234567891011121314151617181920212223242526272829Webview webview = (WebView) findViewById(R.id.webView1);//方式1. 加载一个网页：webView.loadUrl(&quot;http://www.google.com/&quot;);//方式2：加载apk包中的html页面，如果html文件存于assets：则加前缀：file:///android_asset/webView.loadUrl(&quot;file:///android_asset/test.html&quot;);//方式3：加载手机本地的html页面，如果html文件存于sdcard：则加前缀：content://com.android.htmlfileprovider/sdcard/webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;); // 方式4： 加载 HTML 页面的一小段内容 // 参数说明：// 参数1：需要截取展示的内容// 内容里不能出现 ’#’, ‘%’, ‘\\’ , ‘?’ 这四个字符，若出现了需用 %23, %25, %27, %3f 对应来替代，否则会出现异常// 参数2：展示内容的类型// 参数3：字节编码WebView.loadData(String data, String mimeType, String encoding)//复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;); WebViewClientWebViewClient 是帮助 WebView 处理各种通知、请求事件、记录页面加载过程的。其中就包括 URL 地址，我们可以通过它来监控到地址的调用过程 shouldOverrideUrlLoading 方法可选择是否拦截加载 URL 如果返回值为 true，拦截 WebView 加载 url，进行自定义逻辑，false 允许 WebView 正常加载 url 可以在这个方法里做什么呢，比如点击到已经定义好的 url 协议 电话号码 tel:&#x2F;&#x2F; 时，那么可以在这里做拦截，跳转到系统拨号界面。 123456789@Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (url.startsWith(&quot;tel:&quot;)) &#123; Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url)); startActivity(intent); return true; &#125; super.shouldOverrideUrlLoading(view, url);&#125; Android 和 JS 的交互允许 WebView 与 Js 交互，先设置权限 settings.setJavaScriptEnabled(true); //使 WebView 支持 JS js 调用 AndroidAndroid 使用如下方法和 Js 建立联系 addJavascriptInterface(Object obj, String interfaceName); 第一个参数为 java 类的对象，第二是 js 里自定义别名，Js 通过这个别名来调用 Java 的方法 Android 调用 js在 html 有如下 javascript 方法 123function jsFunc() &#123; alert(&quot;调用 JS 方法&quot;);&#125; Android 主动调用 JavaScript 的函数，使用如下方法 mWebView.loadUrl(&quot;javascript:jsFunc()&quot;); 加参也一样，比如调用下面方法 123function jsFunc(msg) &#123; alert(msg);&#125; WebView 操作：mWebView.loadUrl(&quot;javascript:jsFunc(\\&#39;jsFunc:Tina\\&#39;)&quot;); 注意字符串要加引号 也可以使用 WebView.evaluateJavascript()方法，效率更高，不会使页面刷新 1234567//使用evaluateJavascript来加载mWebView.evaluateJavascript(&quot;javascript:callJS()&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125;&#125;); WebView 任意代码执行漏洞 (RCE)漏洞原因是 addJavascriptInterface 接口引起远程代码执行漏洞 1234webView.addJavascriptInterface(new JSObject(), &quot;myObj&quot;);// 参数1：Android的本地对象// 参数2：JS的对象// 通过对象映射将Android中的本地对象和JS中的对象进行关联，从而实现JS调用Android的对象和方法 当 JS 拿到 Android 这个对象后，就可以通过反射调用这个 Android 对象中所有的方法，包括使用 forName 方法获取系统类（java.lang.Runtime 类），从而进行任意代码执行。 反射知识：Class 类封装一个对象和接口运行时的状态，当装载类时，Class 类型的对象自动创建。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个 Class 对象。 虚拟机为每种类型管理一个独一无二的 Class 对象。也就是说，每个类都有一个 Class 对象。运行程序时，Java 虚拟机(JVM)首先检查所要加载的类对应的 Class 对象是否已经加载。如果没有加载，JVM 就会根据类名查找.class 文件，并将其 Class 对象载入。 Java 反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是 JVM 得到 class 对象之后，再通过 class 对象进行反编译，从而获取对象的各种信息。存在着⼏个在反射⾥极为重要的⽅法，几乎涵盖了 Java 安全中各种和反射有关的 payload： 获取类的⽅法： Class.forName(“类名的 string”) &#x2F;&#x2F;Class 类静态方法，返回一个给定类或者接口的一个 Class 对象 实际上 x.getClass();或者 x.class 也能拿到 x 自己的 Class 对象 实例化类对象的⽅法： newInstance 获取函数的⽅法： getMethod 执⾏函数的⽅法： invoke 1234567891011121314151617181920function execute(cmdArgs) &#123; // 步骤1：遍历 window 对象,window是全局对象，保存了这个页面的所有信息 // 目的是为了找到包含 getClass方法的对象 // 因为Android映射的JS对象也在window中，所以肯定会遍历到 for (var obj in window) &#123; if (&quot;getClass&quot; in window[obj]) &#123; // 步骤2：利用反射调用forName（）得到Runtime类对象 // 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令 return window[obj] .getClass() .forName(&quot;java.lang.Runtime&quot;) .getMethod(&quot;getRuntime&quot;, null) .invoke(null, null) .exec(cmdArgs); // 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。 // 如执行完访问文件的命令之后，就可以得到文件名的信息了。 &#125; &#125;&#125; 漏洞防护：Google 在 Android4.2 以后对调用的函数以@JavascriptInterface 进行注解从而避免漏洞攻击，也就是说我们 js 调用 Android 的方法，必须要在 JavascriptInterface 中进行声明，这样才能调用 除此之外，如果一定要使用 addJavascriptInterface 接口： 如果使用 HTTPS 协议加载 URL，应进行证书校验防止访问的页面被篡改挂马 如果使用 HTTP 协议加载 URL，应进行白名单过滤、完整性校验等防止访问的页面被篡改 如果加载本地 Html，应将 html 文件内置在 APK 中，以及进行对 html 页面完整性的校验 WebView 明文存储漏洞WebView 默认开启密码保存功能 ：mWebView.setSavePassword(true) 开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码； 如果选择”是”，密码会被明文保存到 &#x2F;data&#x2F;data&#x2F;com.package.name&#x2F;databases&#x2F;webview.db 中，这样就有被盗取密码的危险 防护措施：通过 WebSettings.setSavePassword(false) 关闭密码保存提醒功能，防止明文密码存在本地被盗用。 WebView 域控制不严格漏洞针对 WebView 的跨域问题，主要是三个重要的 API，如下所示： 初级：任意文件窃取 (应用克隆漏洞)漏洞原理：setAllowFileAccess(true) + setAllowFileAccessFromFileURLs(true) / setAllowUniversalAccessFromFileURLs(true) 这样使得 WebView 可以使用 File 协议来加载本地或者远程 http 源上的 js 脚本，这样会导致攻击者操作用户点击后无感知下载恶意的 HTML&#x2F;JS，并窃取相关的私有文件信息 以上是原理层的讲解，实际上这个漏洞要想被最终利用，还离不开一个重要的前提：WebView 可以直接被外部调用 也就是说 App 内部的 WebView 会被不信任的第三方调用：内置 WebView 的 Activity 是否被导出、必须导出的 Activity 是否会通过参数传递调起内置的 WebView 等； 防护措施： 避免 App 内部的 WebView 被不信任的第三方调用，排查内置 WebView 的 Activity 是否被导出、必须导出的 Activity 是否会通过参数传递调起内置的 WebView 等； file 域访问为非功能需求时，手动配置 setAllowFileAccessFromFileURLs 或 setAllowUniversalAccessFromFileURLs 两个 API 为 false（Android 4.1 版本之前这两个 API 默认是 true，需要显式设置为 false）； 若需要开启 file 域访问，则设置 file 路径的白名单，严格控制 file 域的访问范围，具体如下： 固定不变的 HTML 文件可以放在 assets 或 res 目录下，file:&#x2F;&#x2F;&#x2F;android_asset 和 file:&#x2F;&#x2F;&#x2F;android_res 在不开启 API 的情况下也可以访问； 对 file 域请求做白名单限制时，需要对“…&#x2F;…&#x2F;”特殊情况进行处理，避免白名单被绕过。(使用 shouldOverrideUrlLoading) 进一步对 APP 目录下的敏感数据进行保护 升级：同源检查绕过：符号链接和延时加载初级版的文件窃取是利用了setAllowFileAccess(true) + setAllowFileAccessFromFileURLs(true) / setAllowUniversalAccessFromFileURLs(true) 为了防护，一般会对 setAllowFileAccessFromFileURLs API 默认置 false，但仅仅设置 setAllowFileAccess(true)也能达到类似的漏洞利用效果 通过绕过 file 协议的同源检查：符号链接和延时加载来产生此漏洞 设置 WebView 允许使用 JS 代码：WebView.getSettings().setJavaScriptEnabled(true) 设置 WebView 允许访问本地 html 文件：WebView.setAllowFileAccess(true) setAllowFileAccessFromFileURLs 方法和 setAllowUniversalAccessFromFileURLs 在这种情况下设置为 false。其实无论怎么限制 file 协议的同源检查，通过 file 协议访问当前 js 脚本文件总是可以的 所以，通过 javascript 的延时执行和将当前文件替换成指向其它文件的软链接就可以读取到被符号链接所指的文件。 其攻击过程首先是操纵 WebView 去访问一个攻击 APP 自己公开出来的网页，然后这个网页执行的内容其实就是延时去读取自身。在延时读取自身的时间窗口内，这个文件悄悄被进行了替换，替换成了软链接，指向受害 APP 的一个私有文件，最终读取窃取其内容。 安全防护： 设置 setAllowFileAccess 方法为 false,设置 setAllowFileAccessFromFileURLs 和 setAllowUniversalAccessFromFileURLs 为 false。 禁止 File 域协议调用 JavaScript 当 WebView 所在 Activity 存在组件暴露时，若不是必要的组件暴露，应该禁止组件暴露","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android漏洞","slug":"Android漏洞","permalink":"https://beichen.link/tags/Android%E6%BC%8F%E6%B4%9E/"}]},{"title":"linux 面试","slug":"Study/语言学习/linux命令","date":"2023-07-30T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/07/30/Study/语言学习/linux命令/","link":"","permalink":"https://beichen.link/2023/07/30/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"chownchown system:system /data/fakeloc/是修改文件和文件夹的用户和用户组属性 (更改所有者权限)，读写文件的前提是该文件具有读写权限，复制文件和设置文件访问权限则需要 app 具有 src 和 dst 目录的拥有者权限，一般的，app 默认是具有所在包名的权限为 u0_a*:u0_a*，若目录的拥有者权限为 root:root，则 app 是无法在该目录完成复制文件操作的，但可以通过 chown (change owner) 命令重新设置目录权限。例如：将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup : chown runoob:runoobgroup file1.txt chmod +x 相当于 chmod a+x awkAWK 是一种处理文本文件的语言，是一个强大的文本分析工具。 语法: awk [选项参数] ‘script’ var&#x3D;value file(s)或awk [选项参数] -f scriptfile var&#x3D;value file(s) 相当于同时以逗号和空格划分","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Java 面试","slug":"Study/语言学习/Java知识","date":"2023-07-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/07/15/Study/语言学习/Java知识/","link":"","permalink":"https://beichen.link/2023/07/15/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Java%E7%9F%A5%E8%AF%86/","excerpt":"","text":"面向对象的特征封装，继承和多态。 封装：面向对象最基础的一个特性，封装性，是指隐藏对象的属性和现实细节，仅对外提供公共访问方式。封装的原则：将不需要对外提供的内容都隐藏（设置访问修饰符为“private”）起来。把属性都隐藏，仅提供公共方法对其访问，可以在访问方式中加入逻辑判断等语句。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。 多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。 多态性分为编译时的多态性（方法重载）和运行时的多态性。 运行时的多态是面向对象最精髓的东西，要实现多态需要做三件事： 继承 方法重写（子类继承父类并重写父类中已有的或抽象的方法） 对象向上转型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 父类类型 变量名 &#x3D; new 子类对象；变量名.方法名(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 多态的转型分为向上转型与向下转型两种： 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 int 和 Integer 有什么区别？Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 静态变量和实例变量的区别静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存。 实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。 深拷贝和浅拷贝的区别是什么？浅拷贝：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用(也就是内存地址)，当引用指向的值改变时也会跟着变化。浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 如何实现浅拷贝呢？也很简单，就是在需要拷贝的类上实现 Cloneable 接口并重写其 clone () 方法。 深拷贝：深拷贝复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 如果使用重写 clone () 方法实现深拷贝，那么要将类中所有自定义引用变量的类也去实现 Cloneable 接口实现 clone () 方法。对于字符类可以创建一个新的字符串实现拷贝。 Java 中的 final 关键字有哪些用法？ 修饰类：表示该类不能被继承； 修饰方法：表示方法不能被重写； 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。 &#x3D;&#x3D; 和 equals() 的区别&#x3D;&#x3D; 对于基本类型和引用类型的作用效果是不同的： 对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于 Object 类中，而 Object 类是所有类的直接或间接父类，因此所有的类都有 equals()方法。 equals() 方法存在两种使用情况： 类没有重写 equals()方法：通过 equals()比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 Object 类 equals()方法。 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。 String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 为什么重写 equals() 时必须重写 hashCode() 方法？hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 HashSet 的过程）！我们在前面也提到了添加元素进 HashSet 的过程，如果 HashSet 在对比的时候，同样的 hashCode 有多个对象，它会继续使用 equals() 来判断是否真的相同。也就是说 hashCode 帮助我们大大缩小了查找成本。 那为什么不只提供 hashCode() 方法呢？ 这是因为两个对象的 hashCode 值相等并不代表两个对象就相等。即哈希碰撞 所以回到问题，因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。 总结： equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。 String、StringBuffer、StringBuilder 的区别？可变性String 是不可变的 线程安全性String 中的对象是不可变的，也就可以理解为常量，线程安全。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。 相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer String 为什么是不可变的?String 类中使用 final 关键字修饰字符数组来保存字符串 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; private final char value[]; //...&#125; 被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象 String 真正不可变有下面几点原因： 保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供&#x2F;暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 字符串常量池的作用了解吗？字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 123456// 在堆中创建字符串对象”ab“// 将字符串对象”ab“的引用保存在字符串常量池中String aa = &quot;ab&quot;;// 直接返回字符串常量池中字符串对象”ab“的引用String bb = &quot;ab&quot;;System.out.println(aa==bb);// true String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？会创建 1 或 2 个字符串对象。 1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"小程序安全","slug":"Study/实习/小程序安全","date":"2023-07-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/07/15/Study/实习/小程序安全/","link":"","permalink":"https://beichen.link/2023/07/15/Study/%E5%AE%9E%E4%B9%A0/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8/","excerpt":"","text":"一、论文学习：Cross Miniapp Request Forgery: Root Causes, Attacks, and Vulnerability Detection （CCS’22）与使用网络域(即 IP 地址)在不同的 web 应用程序之间导航的 web 应用程序不同，迷你应用程序使用由超级应用程序分配的唯一全局 appId 在小应用程序之间导航。 不幸的是，在接收方的小应用程序中，任何缺少发送方的 appId 检查都可能导致一种新的攻击类型，我们称之为跨小应用程序请求伪造(CMRF)。 与传统的 web 应用或原生应用类似，小应用通常也需要协同工作来完成复杂的任务。例如，购物小应用程序可能需要与支付小应用程序通信，并提供诸如订单 ID 和价格信息等附加信息，以完成购买交易。 当一个 miniapp 向另一个 miniapp 发起重定向请求时，它可以通过设置一个特殊的类似于 native-app intent 的 JSON 对象 extraData 来设置要传输给其他应用的特定数据 1.请求创建和发送 使用 wx.navigateToMiniProgram API，需要 3 个参数：appId、path UR 以及 request extraData(JSON 对象，包含请求的名称和请求的值) 2.渠道建立 当微信收到这个请求时，它会将发送者推入一个运行时堆栈（称为 AppBrandRuntimeContainer），该堆栈维护一些迄今为止已经启动的小型应用程序。 特别是，当运行时堆栈中的小型应用程序在其运行资源未释放的情况下进入非活动状态时（微信不允许小型应用程序后台运行），如果小型应用程序处于非活动状态超过 5 分钟，微信将释放位于堆栈底部的小型应用的资源。随后，微信根据发送者指定的 appId 启动接收者小应用程序 3.请求接收 当接收器小型应用程序启动时，它首先调用一个回调函数来获取请求，回调函数可以是 onShow 或 onLaunch，每次 UI 启动时都会执行。 由于发送方使用不同的名称（例如“Price”和“orderID”）配置参数，接收方则使用这些名称来获取感兴趣的参数。接收器还可以通过将 appId 与其预期的 appId 进行比较来检查请求的来源，以确保请求来自预期的小型应用程序 请注意，与发送者可以向接收者发送请求类似，接收者也可以使用交叉迷你应用程序通信 API wx.navigateBackMiniProgram 将请求发送回发送者。 主要问题: 购物小程序和支付小程序相互通信不验证 appid 漏洞 1：免费购物攻击购物小程序需要付款完成后从支付小程序那获取付款状态，但购物小程序缺乏对支付小程序的 appid 验证，导致可伪造支付小程序的支付成功请求发送给购物小程序，实现免费购物攻击； 攻击者在他或她自己的智能手机上运行购物小应用程序。攻击者首先选择产品并按下购买按钮。然后，购物小应用程序将调用支付小应用程序并等待支付完成。到目前为止一切都很好。 然而，攻击者没有完成正常的支付过程，而是终止支付小应用程序，并在自己的开发环境中运行一个假的支付小应用程序，然后使用假的小应用程序创建一个伪造的请求(其中包含 paymentState“Success”)，并通过 navigateToMiniprogram(步骤)将其发送给受害者接收者。这可以通过等待超过 5 分钟来实现，这样购物小应用就会被杀死。然后，攻击者可以使用 navigateToMiniprogram 调用带有伪造请求的购物小应用程序。 另一方面，购物小应用程序将始终使用回调函数 onLaunch 来接收来自其他小应用程序的请求，无论它是否通过 navigateBackMiniprogram 或 navigateToMiniprogram 调用。因此，主机应用程序将根据攻击者指定的 appId 启动接收方小应用程序。由于购物小应用程序不检查 appId 是否来自预期的小应用程序，恶意小应用程序发送的请求将被正常处理，因此攻击者可以实现“免费购物”攻击。 漏洞 2：优惠券滥用攻击由于支付小程序缺乏对购物小程序的 appid 验证，那么优惠券等信息就会泄漏给攻击者。（没看明白，不清楚为什么和不验证 appid 有关系） 检测方法： step1: 检测是否有 cross miniapp communication，匹配 the string of referrerInfo.extraData.*. It will wrap the information from a sender miniapp in an object called referrerInfo, containing appId and extra data of the sender. All of the cross-miniapp messages will involve the members of referrerInfo.extraData._, where the _ represents a specific member of extraData, e.g., paymentStatus. step2: 检测是否对 appid 做了 check 主要就是识别二进制表达式，判断表达式左右两侧是否存在 appid 二、调研怎么发现美团 app 的 miniapp 问题环境配置：pc 版微信，unveilr 解包和反编译小程序 分析美团小程序 2.1 API：wx.navigateToMiniProgram(Object object) 打开另一个小程序示例代码: 1234567891011wx.navigateToMiniProgram(&#123; appId: &quot;&quot;, path: &quot;page/index/index?id=123&quot;, extraData: &#123; foo: &quot;bar&quot;, &#125;, envVersion: &quot;develop&quot;, success(res) &#123; // 打开成功 &#125;,&#125;); 2.2 找到的美团小程序里的跨小程序通信a. 美团跳游戏小程序，携带 token 值，游戏会验证美团，游戏小程序跳回美团携带时长参数，但是美团没有验证 appid，但是也利用不了，跟业务无关，猜测有埋点啥的 b. &#x2F;mobike&#x2F;app.js&#x2F;onshow 为实现免密支付会跳转到微信官方签约小程序，但代码的确验证了 appid 要防御的话 小程序的启动初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境。大概是这么个过程： 创建线程（渲染层和逻辑层），启动小程序。 载入基础库（WebView 基础库和 AppService 基础库）。 载入小程序业务代码（下载或者从本地缓存中拿到）。 使用 App()注册程序实例。 为了让小程序业务代码能够调用 API 以及组件，就需要在启动小程序后先载入基础库，接着再载入业务代码。由于所有小程序都需要注入相同的基础库，所以小程序的基础库会被提前内置在微信客户端。而基础库是热更新的，故一般等微信客户端携带上一个稳定版的基础库正式发布后，再进行新版本基础库的灰度和推送。 宿主环境提供了 App()构造器用来注册一个程序 App。App 实例是单例对象，在其他 JS 脚本中可以使用宿主环境提供的 getApp()来获取程序实例。App()函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。但 App() 必须在 app.js 中调用，必须调用且只能调用一次。小程序实例的生命周期如下： onLaunch 小程序初始化完成时（全局只触发一次）触发 onLaunch 回调。 onShow 小程序启动，或从后台进入前台显示时触发 onShow 回调。通常我们用来处理数据和状态的更新。小程序进入后台状态：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁。而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 在微信客户端中打开小程序有很多途径，对不同途径的打开方式，小程序有时需要做不同的业务处理。所以微信客户端会把打开方式带给 onLaunch 和 onShow 的调用参数 options，我们可以根据参数来判断一些进入方式，以及做对应的逻辑处理。例如，我需要拿到从另外一个小程序跳转过来携带的信息，此时场景值应该是 1037（参考场景值）： 123456789App(&#123; // ... onShow: function (e) &#123; if (e.scene === 1037) &#123; const data = e.referrerInfo &amp;&amp; e.referrerInfo.extraData; // 拿到对应的数据 const refAppid = e.referrerInfo &amp;&amp; e.referrerInfo.appId; // 拿到对应的小程序appid &#125; &#125;,&#125;); onHide小程序从前台进入后台时触发 onHide 回调。 小程序进入前台状态：当再次进入微信或再次打开小程序，又会从后台进入前台。 支付时的跨小程序通信github 上一个 demo 代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 本代码为演示碎片代码// 需与文档中小程序章节结合使用 https://help.payjs.cn// 跳转// 为小程序的支付按钮绑定事件bindPay: function() &#123; // 待传入的 wx.request(&#123; url: &#x27;商户侧后端请求支付参数的网址&#x27;, success: response =&gt; &#123; let extraData = &#123; &#x27;mchid&#x27;: response[&#x27;mchid&#x27;], // 商户号 &#x27;total_fee&#x27;: response[&#x27;total_fee&#x27;], &#x27;out_trade_no&#x27;: response[&#x27;out_trade_no&#x27;], &#x27;body&#x27;: response[&#x27;body&#x27;], &#x27;notify_url&#x27;: response[&#x27;notify_url&#x27;], &#x27;attach&#x27;: response[&#x27;attach&#x27;], &#x27;nonce&#x27;: response[&#x27;nonce&#x27;], &#x27;sign&#x27;: response[&#x27;sign&#x27;] &#125; wx.navigateToMiniProgram(&#123; appId: &#x27;wx959c8c1fb2d877b5&#x27;, path: &#x27;pages/pay&#x27;, extraData: extraData, success: () =&gt; &#123; console.log(&#x27;等待返回支付结果&#x27;) // 做已经点击过支付的标记 this.setData(&#123; paying: true &#125;) &#125;, fail: () =&gt; &#123; // 小程序跳转失败 // 做好错误处理 &#125; &#125;) &#125; &#125;) &#125;,// 支付动作判断// 在全局的 onShow 内，针对场景值为 1038、来源 appid 为 wx959c8c1fb2d877b5、跳转到的页面 id 为发起支付的页面，则标记为支付成功、记录支付的 payjs_order_id// app.jsApp(&#123; onShow: function (options) &#123; if (options.scene === 1038 &amp;&amp; options.referrerInfo &amp;&amp; options.referrerInfo.appId === &#x27;wx959c8c1fb2d877b5&#x27;) &#123; // 还应判断请求路径 let extraData = options.referrerInfo.extraData this.globalData.paySuccess = extraData.success this.globalData.resultCode = extraData.resultCode this.globalData.msg = extraData.msg this.globalData.payjsOrderId = extraData.payjsOrderId &#125; &#125;, globalData: &#123; resultCode: &#x27;WAITING&#x27;, msg: &#x27;等待支付&#x27;, paySuccess: false, &#125;&#125;)// 在本页面的 onShow 内，如果已经点击过支付，则开始判断小程序是否返回成功，继而判断是否支付成功onShow: function (options) &#123; console.log(options) if (this.data.paying) &#123; // 标记：已经点击过支付 // 注意轮询判断或延时判断支付 // 从跳转后状态取值 let payjsOrderId = app.globalData.payjsOrderId // 注意请求后端判断是否支付成功而非通过前端判断 wx.request(&#123; method: &#x27;POST&#x27;, url: &#x27;后端检测是否支付成功的 url&#x27;, data: &#123; payjsOrderId &#125;, success: response =&gt; &#123; if (response.data.paySuccess) &#123; // 后端返回支付成功 // 执行成功后逻辑 &#125; else &#123; // 后端返回尚未支付 // 提醒用户重新支付或点击「我已支付」发起重检查 &#125; &#125; &#125;) &#125; &#125;,// 注意事项// 页面内 onShow 检查小程序 app.js onShow 时建议使用轮询或延时，因为 app.js 的 onShow 和小程序页面的 onShow 均为异步，所以存在执行页面 onShow 时 app.js 的 onShow 还未执行的可能// 请勿以小程序跳转结果作为判断订单状态的依据，须后端查询订单状态 以上是支付时购物小程序到支付小程序的跨小程序通信。但微信官方提供的微信支付接口并不需要与其他小程序通信。微信支付流程如下： 异步回调一般是用来防止由于网络异常或者系统的波动，可能会导致用户支付成功，但是商户侧未能成功接收到支付结果通知，进而显示订单未支付的情况。商户侧的订单状态更新不及时，容易造成用户投诉，甚至是重复支付的情况发生。 举个例子：某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？ step1 打开电商小程序，搜索浏览到某肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单 step2 wx.login 获取用户临时登录凭证 code，发送到后端服务器换取 openId step3 在下单时，小程序需要将小明购买的商品 Id，商品数量，以及小明这个用户的 openId 传送到服务器 step4 服务器在接收到商品 Id、商品数量、openId 后，生成服务器订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息 step5 小程序端在获取对应的参数后，调用 wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付 123456789101112131415161718192021222324// http对象为wx.request()的二次封装import http from &quot;../utils&quot;;// 向后端发请请求const res = await http.post(&quot;/payment/order&quot;, &#123; body: &quot;腾讯QQ-购买会员&quot;, // 商品描述 total_fee: 998, // 总金额，单位为分&#125;);if (res.status === 200) &#123; try &#123; // 得到接口返回的数据，向微信发起支付 const result = await wx.requestPayment(&#123; ...res.data, &#125;); wx.showToast(&#123; title: &quot;支付成功&quot;, &#125;); console.log(&quot;支付结果：&quot;, result); &#125; catch (err) &#123; wx.showToast(&#123; title: &quot;支付失败&quot;, &#125;); &#125;&#125; 为什么不直接通过 wx.requestPayment()在小程序端发起请求而要先请求商户自己的服务器呢？原因很简单，安全性问题，wx.requestPayment()需要 2 个重要参数 paySign 和 package，需要 appid,secret,openid,mch_key 等私密数据，这些私密的数据不应该在前端暴露出来，而是放在自己的服务器中更安全，所以需要向自己的服务器发起这个请求拿到这些参数，下一步才能真正发起支付。 js 开发知识 js 中有几种数据类型？ number：数字类型 string：字符串类型 boolean：布尔值类型 undefined：未定义类型 null：空值类型 object：对象类型 symbol：symbol 类型 bigint：大数字类型 &#x3D;&#x3D; 与 &#x3D;&#x3D;&#x3D; 的区别？ &#x3D;&#x3D;：在比较过程中会存在隐式转换 &#x3D;&#x3D;&#x3D;：需要类型相同，值相同，才能为 true JavaScript 之（||、&amp;&amp;）操作符 链接：https://www.jianshu.com/p/07a1cabe6484 逻辑操作符又叫布尔操作符。在 java 中 逻辑操作符(&amp;&amp;、||、！) 只能操作 boolean 类型，也只能返回 boolean 类型；但在 JavaScript 中却可以操作 js 中的任何值，同时也不强制返回 boolean 类型，这为 JavaScript 开发提供了很大的便利。 逻辑或（||）总结：只要第一个值的布尔值为 false，那么永远返回第二个值。 逻辑或属于短路操作，第一个值为 true 时，不再操作第二个值，且返回第一个值。 逻辑与（&amp;&amp;）总结：只要第一个值的布尔值为 true，那么永远返回第二个值。 逻辑与属于短路操作，第一个值为 false 时，不再操作第二个值，且返回第一个值。 JavaScript 之逗号运算符 运算符对他的每个操作数从左到右求值，并返回最后一个操作数的值","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"}]},{"title":"ARM32 汇编学习","slug":"Study/语言学习/汇编学习","date":"2023-07-03T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/07/03/Study/语言学习/汇编学习/","link":"","permalink":"https://beichen.link/2023/07/03/Study/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.1 处理器架构Android 处理器架构有 7 种： armeabi 第 5 代 ARM v5TE，使用软件浮点运算，兼容所有 ARM 设备，通用性强，速度慢（只支持 armeabi） armeabi-v7a 第 7 代 ARM v7，使用硬件浮点运算，具有高级扩展功能（支持 armeabi 和 armeabi-v7a，大部分手机都是这个架构） arm64-v8a 第 8 代，64 位，包含 AArch32、AArch64 两个执行状态对应 32、64bit（支持 armeabi-v7a、armeabi 和 arm64-v8a） x86 intel 32 位，一般用于平板（支持 armeabi(性能有所损耗) 和 x86） x86_64 intel 64 位，一般用于平板（支持 x86 和 x86_64） mips 基本没见过 mips64 基本没见过（支持 mips 和 mips_64） 绝大多数手机都是 ARM 架构，分 32 位和 64 位，下面都以 32 位 ARM 处理器为基础。 1.2 ARM 处理器 指令集ARM 处理器支持 ARM、Thumb、Thumb-2 三种指令集 ARM 指令集：传统 ARM 处理器支持的指令集，长度为 32 位，运行速度也是最快 Thumb 指令集：以看作是 ARM 指令压缩形式的子集, 是针对代码密度的问题而提出的, 它具有 16 位的代码密度，不如 ARM 指令的效率高 Thumb2 指令集：在前面两者之间取了一个平衡， 兼有二者的优势，指令长度有 16 位、32 位两种，保证效率又节约空间 1.3 ARM 架构流水线在 ARM7 中有 3 级流水线，“取指–&gt; 译码–&gt; 执行” 在 ARM9 中有 5 级流水线，“取指–&gt;译码–&gt;执行–&gt;访存 (LS1)–&gt; 回写(LS2)” 不管三级还是五级流水线，第一级流水线执行的时候，第三级流水线在取指。 而 PC 指向的是要取的指令的地址。在 ARM 状态下，一条指令为 32 位，所以 PC &#x3D; 当前正在运行地址 + 8 1.4 ARM 常用寄存器共有 37 个寄存器，31 个通用+6 个状态寄存器, 可访问的有： R0-R15 16 个 通用寄存器 + 一个状态 寄存器 共 17 个 调用约定：函数调用约定指定函数的前四个参数存储在寄存器 R0-R3 中，当参数个数多于 4 个时，将多余的参数通过数据栈进行传递，入栈顺序与参数顺序正好相反，子程序返回前无需恢复 R0~R3 的值。 在子程序中，使用 R4 ～ R11 保存局部变量，若使用需要入栈保存，子程序返回前需要恢复这些寄存器；R12 是临时寄存器，使用不需要保存。 子程序返回 32 位的整数，使用 R0 返回；返回 64 位整数时，使用 R0 返回低位，R1 返回高位。 ARM 架构使用满减堆栈，也就是说堆栈从高地址向低地址增长.这意味着当你向堆栈添加数据时，堆栈指针会向下移动，而当你从堆栈中取出数据时，堆栈指针会向上移动 1.5 寻址方式 1.6 相关汇编指令1.6.1 存储器访问指令1.6.1.1 STR (从左到右)寄存器 -&gt; 内存： STR R0，[R1] 即 R0 数据放入 R1 的地址内存中STR R8,[R9,#4] 即 R8 数据放入 R9+4 的地址内存中 1.6.1.2 LDR (从右到左)内存 -&gt; 寄存器： LDR R0，[R1] 即 获取 R1 地址内存数据装入 R0LDR R3, [R0,#0x4C] 即将 R0+0x4 指向的内存单元内容读取到 R3 寄存器中 stp 指令是 str 的变种指令，p 可以理解成 pair 的意思，可以同时操作两个寄存器。 stp q6, q7, [sp, #-32]! 相当于 stp q6，q7, [sp,#-32]sub sp,sp,#32 1.6.1.3 LDM 和 STM批量加载&#x2F;存储指令用于在一组寄存器和一块连续的内存单元之间的数据传输。主要作用为现场保护、数据传送。其中，后缀！表示最后 LDM：将存储器的数据加载到一个寄存器列表 (内存 -&gt; 寄存器) LDM R0!, {R1-R3} 即将 R0 指向的存储单元的数据依次加载到 R1,R2,R3 寄存器 STM：将一个寄存器列表的数据存储到指定的存储器 (寄存器 -&gt; 内存) STM R0!, {R1-R3} 即将 R1-R3 的数据存储到 R0 指向的地址上 1.6.2 数据传送指令1.6.2.1 MOVMOV 为数据传送指令，用于传输数据 MOV R0, R1 即将 R1 中的数值传送至 R0 寄存器 1.6.3 逻辑运算指令1.6.3.1 ADD 和 SUBADD、SUB 等的逻辑运算指令用于寄存器中值的运算，举一反三即可 ADD R1, R2, R3 SUB R1, R2, R3 将 R2 和 R3 的值相加存至 R1 中 1.6.3.2 AND 和 ORRND R1, R2, R3 ORR R1, R2, R3 将 R2 和 R3 进行按位与&#x2F;或操作，结果保存至 R1 中 1.6.4 比较指令1.6.4.1 CMPCMP 为比较指令，通过减法操作，再根据结果修改标志位，一般修改 CF、OF、SF、ZF，尤其是 Z 标志位。 CMP R1, R2 即 R1 的值减去 R2 的值，得到相应标志位的改变 CMP R7, #6BNE loc_1A28 即将 R7 中的值和 6 进行比较，当 R7 不等于 6 时进行跳转，即 ZF 值为 0 时跳转。 1.6.5 移位指令1.6.5.1 逻辑移位 LSL、LSRLSL 是逻辑左移，低位补 0 LSR 是逻辑右移，高位补 0 1.6.5.2 算术移位 ASL、ASRASL 算术左移和 LSL 类似，主要是 ASR 有点细微区别 ASR 算术右移中保持符号位不变，正数的话最高位补 0，负数最高位补 1 1.6.6 跳转指令1.6.6.1 BB（Branch）为直接跳转指令 1.6.6.2 BL带链接的跳转，即跳转前会将下一条指令的地址拷贝到 LR 寄存器中，保存好后才会执行跳转，便于找到返回地址。 1.6.6.3 BX带状态切换的跳转，若跳转地址的位[0]为 1，将标志 T 置为 1，目标代码解释为 Thumb 代码；若跳转地址的位[0]为 0，将标志位置为 0，目标代码解释为 ARM 代码。 1.6.6.4 BLX带链接和状态切换的跳转。切换 ARM 和 thumb 指令 1.7 汇编机器码格式 1.7.1 31–28 条件位 1.7.2 27–26为保留位，恒为 00 1.7.3 25 位标志 0-11 位存放的是立即数还是寄存器。若为寄存器则置 0，若为立即数则置 1。 1.7.4 24–21为 opcode，标明指令的类型 1.7.5 19–16 位第一个源操作数寄存器 1.7.6 15–12位目的寄存器 1.7.7 11-0操作数 参考：https://blog.csdn.net/spinchao/article/details/108300557#31__433 1.8 入栈出栈参见：https://blog.51cto.com/u_87851/6359554 1.9 大小端模式大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。 小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 小端模式优点： 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把 int 的 4 字节强制转换成 short 的 2 字节时，就直接把 int 数据存储的前两个字节给 short 就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）； CPU 做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效 大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持，因此在多字节存储顺序上始终没有一个统一的标准 大小端转换：","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"抓包奇技淫巧","slug":"Study/逆向知识/抓包奇技淫巧","date":"2023-07-01T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/07/01/Study/逆向知识/抓包奇技淫巧/","link":"","permalink":"https://beichen.link/2023/07/01/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%8A%93%E5%8C%85%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/","excerpt":"","text":"移动长连接一开始爬 美团外卖 App 我是直接 Charles 上手就干的，但我抓了一天都没抓到有用的数据 查资料得知美团使用了一种叫 “移动长连接“ 的技术导致我抓不到包； 根据美团技术团队发表的一篇文章：移动网络优化实践(https://tech.meituan.com/2017/03/17/shark-sdk.html)，用我所理解的话来说就是： 打开 APP 的时候移动端和服务器建立起 tcp 连接后，这个连接就不断开了，后续的请求和接收都走该通道，这个 tcp 长连接一般都是会使用自定义的协议，而非 http，所有普通的抓包软件都无法抓到这类请求 美团在 HTTP 短连请求中进行了一些优化尝试方案，即域名合并方案和 短连方案一、域名合并方案随着开发规模逐渐扩大，各业务团队出于独立性和稳定性的考虑，纷纷申请了自己的三级域名。App 中的 API 域名越来越多。如下所示： search.api.dianping.com ad.api.dianping.com tuangou.api.dianping.com waimai.api.dianping.com movie.api.dianping.com … App 中域名多了之后，将面临下面几个问题： HTTP 请求需要跟不同服务器建立连接。增加了网络的并发连接数量。 每条域名都需要经过 DNS 服务来解析服务器 IP。 如果想将所有的三级域名都合并为一个域名，又会面临巨大的项目推进难题。因为不同业务团队当初正是出于独立性和稳定性的考虑才把域名进行拆分，现在再想把域名合并起来，势必会遭遇巨大的阻力。 所以我们面临的是：既要将域名合并，提升网络连接效率，又不能改造后端业务服务器。经过讨论，我们想到了一个折中的方案。 该方案的核心思想在于：保持客户端业务层代码编写的网络请求与后端业务服务器收到的请求保持一致，请求发出前，在客户端网络层对域名收编，请求送入后端，在 SLB(Server Load Balancing)中对域名进行还原。 网络请求发出前，在客户端的网络底层将 URL 中的域名做简单的替换，我们称之为“域名收编”。 例如：URL “http://ad.api.dianping.com/command?param1=123&quot; 在网络底层被修改为 “http://api.dianping.com/ad/command?param1=123&quot; 。 这里，将域名”ad.api.dianping.com”替换成了”api.dianping.com”，而紧跟在域名后的其后的”ad”表示了这是一条与广告业务有关的域名请求。 依此类推，所有 URL 的域名都被合并为”api.dianping.com”。子级域名信息被隐藏在了域名后的 path 中。 被改造的请求被送到网络后端，在 SLB 中，拥有与客户端网络层相反的一套域名反收编逻辑，称为“域名还原”。 例如：”http://api.dianping.com/ad/command?param1=123&quot; 在 SLB 中被还原为 “http://ad.api.dianping.com/command?param1=123&quot; 。 SLB 的作用是将请求分发到不同的业务服务器，在经过域名还原之后，请求已经与客户端业务代码中原始请求一致了。 该方案具有如下优势： 域名得到了收编，减少了 DNS 调用次数，降低了 DNS 劫持风险。 针对同一域名，可以利用 Keep-Alive 来复用 Http 的连接。 客户端业务层不需要修改代码，后端业务服务也不需要进行任何修改。 短连方案二、IP 直连方案经过域名合并方案，我们已经将所有的域名都统一成了”api.dianping.com”。针对这唯一的域名，我们可以在客户端架设自己的 DNS 服务。 方案很简单：程序启动的时候拉取”api.dianping.com”对应的所有的 IP 列表；对所有 IP 进行跑马测试，找到速度最快的 IP。后续所有的 HTTPS 请求都将域名更换为跑马最快的 IP 即可。 举个例子，假如：经过跑马测试发现域名”api.dianping.com”对应最快的 IP 是”1.23.456.789”。 URL “http://api.dianping.com/ad/command?param1=123&quot; 将被替换为 “http://1.23.456.789/ad/command?param1=123&quot; IP 直连方案有下面几大优势： 摒弃了系统 DNS，减少外界干扰，摆脱 DNS 劫持困扰。 自建 DNS 更新时机可以控制。 IP 列表更换方便 接下来要想进一步提升端到端成功率，就要开始进行长连通道建设了。 提到长连通道建设，首先让人想到的应该是 HTTP&#x2F;2 技术。它具有异步连接多路复用、头部压缩、请求响应管线化等众多优点。 如果查看 HTTP&#x2F;2 的拓扑结构，其实非常简单： HTTP&#x2F;2 在客户端与服务器之间建立长连通道，将同一域名的请求都放在长连通道上进行。这种拓扑结构有如下一些缺点： 请求基于 DNS，仍将面临 DNS 劫持风险。 不同域名的请求需要建立多条连接。 网络通道难以优化。客户端与服务器之间是公网链路。如果在多地部署服务器，成本消耗又会很大 与 HTTP&#x2F;2 相区别，我们这里推荐另一种代理长连的模式。这种模式的拓扑图如下： 基本思路为：在客户端与业务服务器之间架设代理长连服务器，客户端与代理服务器建立 TCP 长连通道，客户端的 HTTP 请求被转换为了 TCP 通道上的二进制数据包。代理服务器负责与业务服务器进行 HTTP 请求，请求的结果通过长连通道送回客户端。 与 HTTP&#x2F;2 模式对比，代理长连模式具有下面一些优势： 对 DNS 无依赖。客户端与代理服务器之间的长连通道是通过 IP 建立的，与 DNS 没有关系。客户端的 HTTP 请求被转换为二进制数据流送到代理服务器，也不需要进行 DNS 解析。代理服务器转发请求到业务服务器时，都处于同一内网，因此可以自己搭建 DNS 服务，减少对公网 DNS 服务的依赖。从这个层面上说，代理长连模式天生具有防 DNS 劫持的能力。 不同域名的请求可以复用同一条长连通道。 通道易优化。与部署业务服务器相比，部署代理长连服务器的代价就小了很多，可以在全国甚至全世界多地部署代理长连服务器。客户端在选择代理长连服务器时，可以通过跑马找到最快的服务器 IP 进行连接。另一方面，代理服务器与业务服务器之间的网络通道也可以进行优化，通过架设专线或者租用腾讯云等方式可以大大提升通道服务质量。 对业务完全透明。客户端的业务代码只要接入网络层的 SDK 即可，完全不用关心网络请求使用的是长连通道还是短连通道。代理服务器将客户端的请求还原为 HTTP 短连方式送到业务服务器，业务服务器不需要进行任何改造。 完整的网络通道拓扑图如下所示： 图中网络通道 SDK 包含了三大通信通道： CIP 通道：CIP 通道就是上文中提到的自建代理长连通道。CIP 是 China Internet Plus 的缩写，为美团点评集团的注册英文名称。App 中绝大部分的请求通过 CIP 通道中的 TCP 子通道与长连服务器（CIP Connection Server）通信，长连服务器将收到的请求代理转发到业务服务器（API Server）。由于 TCP 子通道在一些极端情况下可能会无法工作，我们在 CIP 通道中额外部署了 UDP 子通道和 HTTP 子通道，其中 HTTP 子通道通过公网绕过长连服务器与业务服务器进行直接请求。CIP 通道的平均端到端成功率目前已达 99.7%，耗时平均在 350 毫秒左右。 WNS 通道：出于灾备的需要，腾讯的 WNS 目前仍被包含在网络通道 SDK 中。当极端情况发生，CIP 通道不可用时，WNS 通道还可以作为备用的长连替代方案。 HTTP 通道：此处的 HTTP 通道是在公网直接请求 API Server 的网络通道。出于长连通道重要性的考虑，上传和下载大数据包的请求如果放在长连上进行都有可能导致长连通道的拥堵，因此我们将 CDN 访问、文件上传和频繁的日志上报等放在公网利用 HTTP 短连进行请求，同时也减轻代理长连服务器的负担。 通信降级抓包文章里有这么一段：由于客户端的请求都放在 TCP 通道上进行，当代理长连服务器需要升级或者由于极端情况发生了故障时，将会造成客户端的整体网络服务不可用。为了解决这个问题，我们准备了 Failover 降级方案。当 TCP 通道无法建立或者发生故障时，可以使用 UDP 面向无连接的特性提供另一条请求通道，或者绕过代理长连服务器之间向业务服务器发起 HTTP 公网请求。 也就是说，美团为了以防万一提供了降级方案，正是因为这个方案给了我们机会，既然 tcp 通道发生故障会切换到 http 请求，那么只要让这个条件成立就好了。这个可以通过屏蔽 ip 实现，随即有了一个新问题，怎么找到这个 ip。 首先移动端长连接与服务器的通信肯定是 TCP 协议；然后由于是长连接，那么移动端肯定不会轻易的去断开这个连接，也就是不会发送 fin 包，有了这两个特征就可以开始筛选 ip 了。 pc 端的话用 wireshark，找比较大的返回的数据包，而且是加密过的，然后屏蔽这个 ip，Linux 直接用 iptables 就行：iptable -A INPUT -s ***.**.***.181 -j DROP #屏蔽 ,接着就可以直接用 Charles 抓包了. 手机上用小黄鸟抓包查看最大的数据包然后屏蔽相应的 ip 也可以","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"magisk root原理","slug":"Study/逆向知识/magisk root原理","date":"2023-04-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/04/10/Study/逆向知识/magisk root原理/","link":"","permalink":"https://beichen.link/2023/04/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/magisk%20root%E5%8E%9F%E7%90%86/","excerpt":"","text":"在 Android 系统中，我们如何获取 root 权限呢？ 实现 root 的方式整体上可以分为两种： 解锁 Bootloader，通过修改 Android 系统的某一部分实现 root。 通过某些系统漏洞提取，进而获取 root 权限。 解锁 Bootloader 实际上就允许我们刷入第三方或者被修改过的操作系统；未解锁的BootLoader，不允许刷入非官方签名过的img镜像（包括Recovery.img，Boot.img等） 如果我们可以解锁 Bootloader，那么理论上讲我们就可以任意修改其操作系统，而 root 权限只不过是操作系统的某种机制，因此获取 root 权限自然不在话下。而这种修改方式常见的如下： 通过直接刷入第三方系统实现；在这个第三方系统中，系统自带 root 权限。 通过修改原系统的 init 实现；因为 init 进程是 Linux 系统的第一个进程，因此它实际上就以 root 身份执行的；通过修改 init 也可以实现 root 访问；Magisk 就是通过代理 init 实现的 root 权限。 Magisk的原理，从底层看，主要就是把&#x2F;init替换成了它自己的magiskinit。 Magisk通过对boot.img的patch，在boot启动阶段创建钩子，把&#x2F;data&#x2F;magisk.img挂载到&#x2F;magisk，构建出一个在 system 基础上能够自定义替换，增加以及删除的文件系统。 所有操作都在启动时完成，实际上并不修改&#x2F;system(即所谓systemless方案，以不触动 &#x2F;system 的方式修改 &#x2F;system)。&#x2F;magisk相当于android系统的另一个独立分区。 当boot启动时，magiskinit首先从&#x2F;.backup恢复原始的init文件。然后从magiskinit中释放出来magisk.bin和Manager的APK等后续建立root需要的文件。接着它会以init权限patch sepolicy，增加一个名为magisk的上下文环境，最后启动magiskd等待su的连接。 当su命令执行时，背后实际上是向magiskd请求root，magisk则会向Magisk Manager发起问询，等待用户确认后才赋予放行，最后magiskd启动一个shell，并把它重定向到su通过unix socket发送过来的输入输出句柄上。 通过自定义内核实现；因为 root 权限实际上是内核操控的，因此自定义内核然后刷入自然可以获取 root 权限。 如果我们不能解锁 Bootloader，那么可以通过系统漏洞来提权，进而拥有 root 权限。在远古时代（特别是 Android 6.0 以前），各种一键 root 满天飞，比如 kingroot，360 一键 root，他们本质上都是通过系统漏洞来获取特殊权限；然而，随着 Android 系统的演进，这种通过漏洞提权获取 root 的方式已经很难出现在普通的大众视野里面了太极有一种「少阳」模式，它就是通过这种方式来提权，进而实现不解锁就能对系统进程加载模块的；然而由于这种方式实际上就是利用漏洞，从机制上讲并不长久，因此被永久雪藏。 如果通过系统漏洞提权，那么必须妥善处理好各种限制，如绕过 SELinux，关闭 seccomp，获取所有 capabilities，否则提权之后的 root 基本就是个残废；然而，绕过这所有的机制并无一个稳定可用的方法，再加上 Android 系统的碎片化，导致通过漏洞获取通杀 root 权限的实现成本变得非常之高。 root 的过去和现在上面我们介绍了一些 root 权限的获取方式，那么具体来说，从 Android 诞生到现在，我们实际上所使用的 root 方案，具体是哪种机制呢？ 在 Android 系统的远古时代，root 方案基本上是通过 SUID 实现的。在上文描述 capabilities 和自主访问控制的时候我们提到过这种机制。SUID 是一个特殊的权限位，它的特殊之处在于，如果某个可执行文件设置了这个权限位，某个用户在执行这个文件的之后，启动进程的 uid 会被自动切换为文件所有者的 uid。 打个比方，假设我有个文件名叫 su，它的所有者是 root，其他进程有其可执行权限；如果没有设置 SUID，那么某个进程比如 uid 为 10000，在执行这文件之后，它启动的进程实际 uid 也是 10000，也就是一个普通进程；而如果这个文件有被设置 SUID 位，那么 uid 为 10000 的用户在执行这个文件之后，所启动的进程 uid 会被自动切换为文件所有者，也就是 root 用户，这个进程就是一个特权进程。 用这种方式实现 root 可谓是非常简单，只需要丢一个 SUID 的文件到系统里面就结束了。然而，Android 4.3 系统的安全性改进让这种机制退出了历史舞台。 这种机制其实非常简单，就是通过 capabilities 机制，给 zygote 的子进程限制了 CAP_SETUID；而我们的 Android App 都是 zygote 子进程，因此 App 从此与 SUID root 告别了。然而，我们的 shell 用户还是可以 SUID 的；某些系统中自带的 su 还是这种 SUID 的 root，在这种系统中我们会发现，adb shell 可以获取 root 权限，但是 App 进程死活无法获取 root，这时候可以看一下 su 文件是否有 SUID 位，如果有的话就是这个原因。 在没有 SUID 之后，App 进程是无法 fork 一个 uid 为 0 的子进程的；从此以后，我们常见的 root 实际上是一种「远程 root 进程」。 因为我们的 App fork 出来的进程 uid 不能被改为 0，因此这个进程肯定无法变成 root 进程，怎么办呢？ 我们可以启动一个远程的特权进程，这个进程的 uid 是 0（比如从 init fork 出来），一旦我们的 App 需要使用 root，那就从 App fork 出一个子进程，让这个子进程与那个远程的特权进程关联起来。 我们想要执行 root 命令的时候，还是与以前一样让这个子进程去做，不同的是，这个子进程实际上并不会执行这些命令，而是把命令发给那个远程的特权进程让它去执行，特权进程执行完毕之后把结果再返回给子进程，这样也实现了我们所需要的 root 访问。 你可以简单地把我们 fork 出来的子进程当作那个远程特权进程的代理，所以我把这种方式称之为「远程 root 进程」。现在的Supersu 和 MagiskSU 都是通过这种方式实现的，如果你在 Magisk 下执行一个 root 命令，你会发现除了你自已的 su 进程之外，还会有一个 magiskd 的进程，这两个进程会通过 UDS(Unix Domain Socket) 通信，有很多 Magisk 检测手段就是通过检测 UDS 实现的。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"APP逆向难点","slug":"Study/逆向知识/APP逆向项目难点","date":"2023-04-05T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/04/05/Study/逆向知识/APP逆向项目难点/","link":"","permalink":"https://beichen.link/2023/04/05/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/APP%E9%80%86%E5%90%91%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9/","excerpt":"","text":"一、frida 反调试一般来说，frida检测有如下几个方面： 检测frida-server文件名 检测27042默认端口 双进程保护 检测D-Bus, fridaserver 使用 D-Bus 协议通信，我们为每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver。 检测&#x2F;proc&#x2F;pid&#x2F;maps映射文件 前三种可以通过改文件名、改端口和以spawn模式启动过掉，-f 即spwan，在程序最先启动的时候注入。 ptrace反调试的原理是进程只能被一个进程附加。查看进程 /proc/self/status 目录，会看到 TracerPid 不为0，其值为附加它的父进程 pid ，这里是 zygote进程。 过掉它的方法很多，下面介绍使用 ptrace 怎么过掉 ptrace :1、使用 ptrace 附加 zygote 进程。2、拦截 zygote 的 fork 调用，在 fork 子进程时候获取当前子进程名称，判断是不是我们想要的那个应用，如果是，就保存子进程 pid3、获取到子进程 pid 后，再拦截子进程的系统调用，判断此系统调用是不是 ptrace，并且参数是 PTRACE_TRACEME4、拦截到指定系统调用后，修改调用参数，让 ptrace(PTRACE_TRACEME); 执行失败。 检测D-Bus可以通过hook系统库函数，比如strstr、strcmp等等，最后两种检测可以更改frida-server的特征从而达到隐藏的效果 这里直接使用hluda server，它更改了frida的诸多特征，自己使用时记得把文件名给改了，并且换个端口，不要使用默认端口 然后以spawn模式启动应用，主要是为了过掉双进程保护 正常的frida server附加进应用之后它的&#x2F;proc&#x2F;pid&#x2F;maps的文件的变化 很明显的发现出现了&#x2F;data&#x2F;local&#x2F;tmp&#x2F;re.frida.server&#x2F;***，等等，re.frida.server是什么呢？这是当使用frida server的时候自动创建的，里面存放着frida的功能模块。 那么当使用hluda server会发生什么变化呢？ 可以发现re.frida.server已经没有了，反而变成了一串没有意义的字符串，并且功能模块文件名也被混淆了，那么为什么还是被检测到了呢？会不会是D-Bus检测呢？别急，认真比对正常的与附加后的&#x2F;proc&#x2F;pid&#x2F;maps文件，发现正常的maps里面是没有&#x2F;data&#x2F;local&#x2F;tmp路径下的模块映射的，但附加了frida之后，不管模块名有没有被混淆，&#x2F;data&#x2F;local&#x2F;tmp路径名总会出现的，见下图： 因此应用完全有理由去检测maps文件里是否有&#x2F;data&#x2F;local&#x2F;tmp目录下的模块映射，所以我就尝试着伪造一个&#x2F;proc&#x2F;pid&#x2F;maps文件，去掉所有有关&#x2F;data&#x2F;local&#x2F;tmp的映射，并且hook open函数让其打开我伪造的maps文件，具体代码如下： 123456789101112131415161718192021222324252627function main() &#123; const openPtr = Module.getExportByName(&#x27;libc.so&#x27;, &#x27;open&#x27;); const open = new NativeFunction(openPtr, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]); var readPtr = Module.findExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read = new NativeFunction(readPtr, &#x27;int&#x27;, [&#x27;int&#x27;, &#x27;pointer&#x27;, &quot;int&quot;]); var fakePath = &quot;/data/data/com.xyz.qingtian/maps&quot;; var file = new File(fakePath, &quot;w&quot;); var buffer = Memory.alloc(512); Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname = Memory.readUtf8String(pathnameptr); var realFd = open(pathnameptr, flag); if (pathname.indexOf(&quot;maps&quot;) &gt;= 0) &#123; while (parseInt(read(realFd, buffer, 512)) !== 0) &#123; var oneLine = Memory.readCString(buffer); if (oneLine.indexOf(&quot;tmp&quot;) === -1) &#123; file.write(oneLine); &#125; &#125; var filename = Memory.allocUtf8String(fakePath); return open(filename, flag); &#125; var fd = open(pathnameptr, flag); return fd; &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]));&#125;setImmediate(main) 很惊喜的发现成功过掉了frida检测 二、抓包平时我们碰到的HTTP和HTTPS都在应用层，SOCKS在会话层，TCP和UDP在传输层，IP在网络层。 客户端校验服务端FaceBook&#x2F;Twitter这些大厂是如何做到防止Charles&#x2F;Fiddler等抓包工具中间人攻击的呢？SSL-Pinning！原理是HTTPS建立时与服务端返回的证书比对一致性，进而识别出中间人攻击后直接在客户端侧中止连接。 证书锁定：开发时就将服务端证书一块打包到客户端里，不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性。但是CA签发证书都存在有效期问题，所以缺点是在证书续期后需要将证书重新内置到APP中。 公钥锁定：提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。 不过由于客户端会做两个证书间的一次性校验，那么就通过hook的方式将此次校验的结果返回true或者干脆不让其做校验，或者Xposed安装JustTrustMe插件，该插件将各种已知的HTTP请求库中用于校验证书的API进行hook并不论是否可信证书都返回正常状态。 双向校验SSL pinning实际上是客户端锁定服务器端的证书, 在要与服务器进行交互的时候, 服务器端会将CA证书发送给客户端, 客户端会调用函数对服务器端的证书进行校验, 与本地的服务器端证书(存放在\\\\asset目录或\\res\\raw下)进行比对。 而双向校验是添加了客户端向服务器发送CA证书, 服务器端对客户端的证书进行校验的部分。 通过反编译拿到证书加载的位置，关键词PKCS12,获取密码，导入charles - Proxy- SSL Proxying Settings 添加客户端证书，Charles将对任意服务器发送该客户端证书，意味着用app访问所有的服务器。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"AOSP难点","slug":"Study/逆向知识/AOSP项目难点","date":"2023-04-05T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/04/05/Study/逆向知识/AOSP项目难点/","link":"","permalink":"https://beichen.link/2023/04/05/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/AOSP%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9/","excerpt":"","text":"项目难点在于 root特征 虚拟机特征 改ROM之前要了解Android的启动原理 LOG移植 属性系统的了解 Root特征 基于android 系统属性检测模拟器 模拟器上面的一些系统属性和真机上面的不同。例如，设备厂商、硬件信息，手机品牌等。同时某些属性的值为模拟器特有，可以直接判断是否是模拟器。 android.os.Build类包含设备硬件和版本信息。可以通过提取该类的静态字段来检测模拟器。build.fingerprint build.model build.manufacturer build.hardwarebuild.product build.board build.bootloader build.serialbuild.brand build.device 通过adb的getprop命令显示属性值ro.board.platform gsm.version.baseband ro.bootloader ro.bootmode ro.build.flavorro.kernel.qemu ro.kernel.android.qemud ro.kernel.qemu.glesinit.svc.qemud init.svc.qemu-props qemu.hw.mainkeys qemu.sf.fake_camera qemu.sf.lcd_density 通过java的反射机制使用Systemproperties类读取系统属性值 直接读取 &#x2F;system&#x2F;build.prop等记录了android 属性的文件 基于系统文件特征检测模拟器 通过内核文件系统&#x2F;proc目录检测模拟器读取&#x2F;proc&#x2F;cpuinfo及&#x2F;proc&#x2F;tty&#x2F;drivers文件判断是否含有goldfish 字段，Goldfish是一种虚拟的ARM处理器，在android的仿真环境中使用。 读取&#x2F;proc&#x2F;diskstats 文件获取设备分区状态信息，因为真机都有mmcblk0分区，而模拟器没有 通过qemu文件特征检测模拟器基于qemu的安卓原生模拟器上存在很多特有文件及驱动文件，可通过检测这些文件是否存在来判断是否是模拟器。“&#x2F;dev&#x2F;qemu_pipe”, “&#x2F;dev&#x2F;socket&#x2F;qemud”,“&#x2F;system&#x2F;lib&#x2F;libc_malloc_debug_qemu.so”,“&#x2F;sys&#x2F;qemu_trace”, “&#x2F;system&#x2F;bin&#x2F;qemu-props”, “&#x2F;dev&#x2F;socket&#x2F;genyd”, “&#x2F;dev&#x2F;socket&#x2F;baseband_genyd”, &#x2F;sys&#x2F;module&#x2F;goldfish_audio”, “&#x2F;sys&#x2F;module&#x2F;goldfish_sync, “&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;qemu_trace”“&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;scaling_cur_freq”,“&#x2F;system&#x2F;bin&#x2F;qemuprops”, if (a.a(“cat &#x2F;proc&#x2F;self&#x2F;cgroup”) &#x3D;&#x3D; null)&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;qemu_pipe”; “&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;drivers&#x2F;qemu_trace” 模拟器厂商特殊文件检测目前市面上流行的Android模拟器主要有Genymotion，天天模拟器，夜神模拟器，逍遥模拟器，BlueStacks等。这些模拟器上都存在一些特有的文件，如&#x2F;system&#x2F;bin&#x2F;nox-prop、&#x2F;system&#x2F;lib&#x2F;libdroid4x.so等。可通过检测这些模拟器厂商特殊文件是否存在来判断是否是模拟器。 基于模拟器与真机的功能差异检测模拟器 网络通信状态模拟器上面的设备ID、手机号、IMEI值和IMSI值都不同于真机设备。android.telephony.TelephonyManager类提供了用于获取设备运营商的方法，用于检测手机通信服务的状态。同时真机与模拟器的网络信息有较大差异，通过读取&#x2F;system&#x2F;bin&#x2F;netcfg内信息是否异常，也可以判断是否为模拟器。 检测API Demos、Dev Tools等其他模拟器特有的应用程序或特有的属性，如在模拟器内app使用intent 调用拨号盘会出现crash 电池状态与电量和充电状态通过模拟器的电池温度为0和电量始终为50%等特性，检验电压、电量是否有实时变化，检测是否模拟器。 A检测真机特有的wifi, GPS，蓝牙，传感器，相机闪光等a. 模拟器的vlan0的ip和mac均为null，而且当正常手机接入WIFI的时候，周边往往有复数的WIFI信号，而模拟器由于不具备检索周边WIFI的能力，其WIFI列表通常为空或者只有一个WIFI。b. 模拟器不存在gps设备，通常无法获取到地理位置信息c. 模拟器不存在蓝牙d. 模拟器与真机有温度差异，表现为真机存在thermal_zone文件e. 模拟器不存在传感器或传感器个数很少f. 模拟器不存在摄像头或只有一个摄像头 基于用户层行为和数据检测模拟器 虚拟机特征1. 了解Android的架构Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和 Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++&#x2F;C)，从而连通整个系统。 应用层 系统内置的应用程序以及非系统级的应用程序都是属于应用层。负责与用户进行直接交互，通常都是用Java进行开发的。 应用框架层（Java API Framework) 应用框架层为开发人员提供了可以开发应用程序所需要的 API ，我们平常开发应用程序都是调用的这一层所提供的 API ，当然也包括系统的应用。这一层是由Java代码编写的，可以称为Java Framework，下面来看这一层所提供的主要的组件。 名称 功能描述 Activity Manager 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager 提供地理位置以及定位功能服务 Package Manager 管理所有安装在Android系统中的应用程序 Notification Manager 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager 管理所有的移动设备功能 Window Manager 管理所有开启的窗口程序 Content Providers 使得不同应用程序之间可以共享数据 View System 构建应用程序的基本组件 系统运行库层（Native) C&#x2F;C++程序库（Native C&#x2F;C++ Libraries） C&#x2F;C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务。 Android运行时库 （Android Runtime） 运行时库又分为 core libraries 和 android runtime (ART)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用； ART作为替代Dalvik的Android虚拟机，采用AOT(Ahead-Of-Time)技术，会在应用程序安装时就转换成机器语言，不再在执行时解释，从而优化了应用运行的速度。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。 硬件抽象层（Hardware Abstraction Layer) 硬件抽象层位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 Linux内核层 Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。 2. Android启动流程 图解：Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; Kernel -&gt; Native -&gt; Framework -&gt; App 关于Loader层： Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在 ROM里的预设代码开始执行，然后加载引导程序到 RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 第一步，启动电源按下电源键开机，从预定义的地方（固化在 ROM 中）开始执行，加载引导程序 Boot Loader 到 RAM 中。 ROM（Read-Ony-Memory）：只读存储器，只能读出无法写入，即便是切断电源数据也不会丢失； RAM（Random Access Memory）：随机存取存储器，与 CPU 直接交换数据，随时读写，一旦断电，存储的数据也将丢失； 第二步，加载引导程序Boot Loader 是操作系统内核运行之前运行的一小段程序。通过这一小段程序，可以初始化硬件设备、建立内存空间的映射，从而为操作系统内核准备出比较合适的软硬件运行环境。之后，启动 Linux Kernel。 设备制造商要么使用比较流行的引导程序，比如 redboot、uboot、qi bootloader，要么自己开发，它不是 Android 操作系统的一部分。引导程序是 OEM 厂商或者运营商加锁和限制的地方。 引导程序分为两个阶段执行： 第一个阶段：检测外部的 RAM 以及加载对第二个阶段有用的程序； 第二个阶段：引导程序设置网络、内存等功能； 这些对于运行内核是必要的，为了达到特殊的目标，引导程序可以根据配置参数或者输入数据设置内核。 第三步，启动 Linux Kernel内核启动时，会设置缓存，加载各种驱动。当内核完成各种设置后，首先会在系统文件中寻找 init 文件，进而启动 init 进程。 第四步：启动 init 进程init 进程是第一个用户级别的进程，进程号固定为 1。init 进程的主要工作有： 创建（mkdir）和挂载（mount）启动所需要的文件目录； 初始化和启动属性服务（property service）； 解析 init.rc 配置文件并启动 zygote 、Service Manager 等进程；（Service Manager 主要用于管理系统服务） 第五步：启动 Zygote 进程Zygote 的意思为孵化器，主要用于孵化子进程。 Zygote 进程最初的名字为 app_process。这个名字在 &#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;android.mk 中有定义。 在 Android 系统中有两种程序，一种是 Java 应用程序，主要是基于 ART （Android Runtime），所有的应用程序都属于这一类；另一种是 Native 程序，也就是用 C&#x2F;C++ 开发的程序，如 Boot Animation（开机动画）。 所有的 Java 应用程序以及 system_server 进程都是由 Zygote 进程 fork 出来的。（Native 进程则是由 init 进程创建的） Zygote 进程是通过 Socket 的方式和其他进程通信的，这里的“其他进程”其实主要指的是 system_server 进程。 Zygote 是一个 C&#x2F;S 模型，Zygote 进程作为服务端，主要负责启动 system_server 进程，创建 Java 虚拟机，加载系统资源以及在后续的运行中启动 Java 应用程序。 其他进程可以向其发出“孵化”进程的请求，而 Zygote 进程接收到这个请求后会“孵化”出一个新的进程。比如，点击 Launcher 中的某个应用程序图标启动一个新的进程时，这个请求会到达 Framework 层的 ActivityManagerService（AMS）中，AMS 接收到这个请求后，会调用 Process 类发出“孵化”子进程的 Socket 请求，Zygote 监听到这个请求后会 fork 出一个新的进程。 第六步，启动 system_server 进程system_server也是是一个进程，是由Zygote进程fork出来的。这个进程是Android Framework里面非常重要的进程，因为系统里面重要的服务都是在这个进程里开启的。比如ActivityManagerService、PackageManagerService、WindowManagerService等等。 ActivityManagerService： 简称AMS，服务端对象，负责系统中所有Activity的生命周期（Activity的开启、暂停、销毁）。在SystemServer进程开启的时候，就会初始化ActivityManagerService。 任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的，AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。 system_server进程总结： 启动Binder线程池，这样就可以和其他进程进行通信 创建SystemServiceManager，其对于系统的服务进行创建，启动和生命周期管理 启动各种系统服务 Zygote 启动了 system_server 进程后，在 system_server 进程中会进一步启动 WindowManagerService（WMS）、ActivityManagerService（AMS）、PackageManagerService（PMS）等服务进程，等这些服务启动后，AMS 就会打开 Launcher 应用的 Home Activity，也就是手机桌面。 2. Android 属性系统最开始想的是检测模拟器时直接把模拟器里的prop文件改掉，每次开机调个脚本。但是有些属性值改了没有用，但是又属于检测项，于是干脆从rom入手 Android 中有很多 Property，他们无处不在，我们的熟悉的 android.os.Build 中的很多字段都是直接读取的对应的 Property 值。Property 都是以键值对的形式存在，键和值都是字符串类型，他们是全局的（各个进程看到的都一样），Android 中非常多的进程和应用直接或者间接依赖 Property 系统，并由此决定其运行期的行为。Property 实质上是由若干个属性读取进程和一个属性设置进程（Property Service）操作。 Property Service 位于 init 进程（拥有 root 权限），在系统开机后创建各个属性对应的内存映射文件，即分配一个共享内存区来存储的属性。各个 App 进程想获得属性信息可以使用对应的内存映射文件，直接从共享内存读取，为上层的 property api 提供数据来源。 Property属性组成Android 的系统属性包括两部分：文件保存的持久属性和每次开机导入的cache属性。前者主要保存在prop文件中，需要注意的是android属性的名称是有一定的格式要求的。ro.开头的属性将不能被更改属性值，persist.开头的属性会被永久记录，其他属性值在重新开机后均将被丢弃。 属性名以ro.开头，该属性被视为只读属性，一旦设置属性值不能改变； 属性名以persist.开头，该属性值将写入&#x2F;data&#x2F;property； 也就是说，如果程序调property_set设了一个以persist为前缀的属性，系统会在&#x2F;data&#x2F;property&#x2F;*里加一个文件记录这个属性，重启以后这个属性还有。如果property_set其它属性，因为属性是在内存里存，所以重启后这个属性就没有了。 Property属性的加载Android启动后，在 property_service.cpp 的 property_init 中完成 prop 的初始化。 系统中存在着几个文件，如 build.prop 和 default.prop 等，这些文件是在系统构建时候生成的，里面包含很多系统的配置。属性服务启动后会从系统文件中读取默认的属性，并写入共享内存中，并且后读入的属性将覆盖前面读取的相同的属性。也就是说，系统开机时会去加载这些文件中的信息并保存到 prop 模块(内存)中去，以便其它程序进行读取和使用。 系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同 Android 版本系统上可能不一样： &#x2F;default.prop 或者是 &#x2F;prop.default， &#x2F;vendor&#x2F;default.prop &#x2F;system&#x2F;build.prop &#x2F;vendor&#x2F;build.prop &#x2F;data&#x2F;local.prop &#x2F;data&#x2F;property&#x2F;* 系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。default.prop 的值是通过 build&#x2F;tools 目录下的 buildinfo.sh 生成的。要修改的话，就要修改编译系统了，这种方法不好维护，不推荐。一般来说我们可以把属性加到 &#x2F;system&#x2F;build.prop 或者 &#x2F;vendor&#x2F;build.prop。 Property prop文件的生成Android 编译时会收集各种property值，编译完成之后，文件生成在out&#x2F;target&#x2F;product&#x2F;system 目录下。在Android运行时刻可以通过property_get()[c&#x2F;c++]或 SystemProperties_get()[Java]读取这些属性值。以build.prop文件为例，build.prop的生成是由make系统解析build&#x2F;core&#x2F;Makefile完成。 总结：build.prop的生成是由make系统解析build&#x2F;core&#x2F;Makefile完成，关于build.prop生成过程的分析，可知属性的来源： buildinfo.sh ：系统默认属性一般在build&#x2F;tool&#x2F;buildinfo.sh，编译时写到文件 build.prop； system.prop追加； ADDITIONAL_BUILD_PROPERTIES 或 PRODUCT_PROPERTY_OVERRIDES追加；一般我们自定义属性就在对应的项目下 device&#x2F;$(TARGET_DEVICE_DIR)&#x2F;system.prop 定义自己的属性即可，建议修改属性在 system.prop 或 PRODUCT_PROPERTY_OVERRIDES，这对应于具体特定平台或产品的修改。 Android提供了两种访问系统属性的方法，一种是通过JAVA Framework层的代码SystemProperties.java中提供的接口，由于该类接口并没有放入到SDK中，因此APP开发并不能使用此接口，需要使用反射；一个是通过C++来访问，在代码中包含/android/system/core/include/cutils/properties.h头文件即可使用property_get/property_set来获取或者设置系统属性值了。 3. 插桩后需要写日志判断是否成功最近在弄系统定制功能的时候(比如打印File构造函数的参数)，需要修改libcore中的核心代码并打印日志输出。虽然Android提供了android.utils.Log日志工具类，但是不能在Android Java层的核心库libcore中调用。 Android Java 核心库中是无法直接使用 android.util.Log 的，添加后编译不通过，因为 framework 中的 Java API 依赖于 Java 核心库。 将android.utils.Log移植到libcore中有两种方式: 在现有的类中添加方法，并在native追加对应的方法，这种方式相对简单； ​ 比如java.lang.System中添加相应的方法，在对应System.c中添加对应的jni方法。 在libcore中添加新的接口类，并实现native的方法，这种方式相对复杂一点。 第一种方法，利用现有类 File.java 之前的源码阅读证明，Java层的 android.utils.Log 输出 log 实际上通过JNI的链接使用的是 println_native()方法，println_native()再去调用native层的__android_log_buf_write方法。 那么我们也可以在想要打印的 Java 类处也实现一个 println_native() ，搭建一个类似的JNI层，这样就能实现类似Log类的效果。 以AOSP&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;io&#x2F;File.java 类为例： 首先，在 File.java 里新建Log()方法，之后想打印的时候可以直接调用类内的方法； 然后，将AOSP&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;util&#x2F;Log.java里面的native方法声明 println_native() copy到 File.java文件里面； 接下来，把&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Log.cpp中对之对应的本地方法copy到libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;native&#x2F;FileSystemPreferences.c，加在static JNINativeMethod gMethods[ ]之前就行； JNI注册修改如下： 123456789101112static JNINativeMethod gMethods[] = &#123; NATIVE_METHOD(FileSystemPreferences, lockFile0, &quot;(Ljava/lang/String;IZ)[I&quot;), NATIVE_METHOD(FileSystemPreferences, unlockFile0, &quot;(I)I&quot;), NATIVE_METHOD(FileSystemPreferences, chmod, &quot;(Ljava/lang/String;I)I&quot;),&#125;;+++ static JNINativeMethod mygMethods[] = &#123;&#123; &quot;println_native&quot;, &quot; (IILjava/lang/String;Ljava/lang/String;)I&quot;, (void*) android_util_Log_println_native &#125;,&#125;;void register_java_util_prefs_FileSystemPreferences(JNIEnv* env) &#123; jniRegisterNativeMethods(env, &quot;java/util/prefs/FileSystemPreferences&quot;, gMethods, NELEM(gMethods));+++ jniRegisterNativeMethods(env, &quot;java/io/File&quot;, mygMethods, NELEM(mygMethods));&#125; 最后，在File.java里任意处调用 Log(tag,msg); 然后make update-api，编译运行即可。经测试，可打印Log。 第二种方法，在libcore中添加新的接口类，并实现native的方法","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Android 漏洞知识","slug":"Study/Android知识/Android漏洞知识","date":"2023-03-28T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/28/Study/Android知识/Android漏洞知识/","link":"","permalink":"https://beichen.link/2023/03/28/Study/Android%E7%9F%A5%E8%AF%86/Android%E6%BC%8F%E6%B4%9E%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Android四大基本组件分别是Activity，Service服务,Content Provider内容提供者，BroadcastReceiver广播接收器。 Android 漏洞1. Android 组件安全首先要知道，Android 中最重要的风险点就是 android:exported&#x3D;”true” 这一属性。组件被导出就意味着大概率会产生漏洞。 首先了解一下四大组件：activity，service，broadcast，contentprovider。 对于 app 来说，每一个界面都是一个 activity，每一个 activity 都会有着不同的功能，比如注册，登录，手势密码等。每一个 activity 的切换需要不同的条件。 service 服务，伴随着程序启动，会一直在后台运行，主要是检测作用，检测客户端的状态，上传用户的操作。 broadcast 分为两个方面，广播发送者和广播接收者。Android 提供一整套的 api，允许 app 自由的发送和接收广播。 contentProvider 是用来保存或者获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为 android 没有提供所有应用共同访问的公共存储区。比如通讯录数据。 越权绕过 四大组件暴露漏洞 Activity、Service、BroadcastReceiver、Content Provider组件都有【exported】属性，该属性被设置为true或是未设置exported值但IntentFilter不为空时，被认为是可以导出的，黑客可能构造恶意数据针对导出组件实施越权攻击； 如果不涉及跨进程或者与其他App没有共享数据或者交互就在清单文件中设置为false 拒绝服务攻击 Android 提供 Intent 机制来协助应用间的交互与通讯，Intent 负责对一次操作的动作、动作涉及的数据进行描述，系统则根据此 Intent 描述，来调用对应的 Activity、 servicer 和 BroadCast 等组件，来完成组件的调用。 如果程序没有对 Intent.getXXXExtra () 获取的异常或者畸形数据处理时没有进行异常捕获，就会导致攻击者可通过向受害者应用发送此类空数据、异常或者畸形数据来使该应用崩溃，简单的说就是通过 intent 发送空数据、异常或畸形数据给应用，来实现让应用崩溃的目的。 隐式意图调用漏洞 intent是一个可用于从一个app组件请求动作或处理事件的“消息对象”。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。 intent主要包括隐式意图和显式意图。调用Intent.setComponent()或Intent.setClass()方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。没有明确指定组件名的Intent为隐式意图。Android系统会根据隐式意图中intent-filter设置的动作(action)、类别(category)、数据（URI和数据类型）找到最合适的组件来处理这个意图。 隐式意图调用只设置Action，没有其他校验措施；建议使用显示调用或者增加Category或者Data数据做校验","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"Android 签名机制","slug":"Study/Android知识/Android签名机制","date":"2023-03-26T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/26/Study/Android知识/Android签名机制/","link":"","permalink":"https://beichen.link/2023/03/26/Study/Android%E7%9F%A5%E8%AF%86/Android%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、前置知识签名机制本质是对信息的一种加密措施，为的是保证信息的合法性。在说明签名机制之前，我们先来了解其中涉及到的四个概念：数字摘要、非对称加密、数字签名、数字证书。 数字摘要： 采用单向 Hash 函数将需要加密的明文生成一串固定长度的密文，这一串密文又称为数字指纹，其具有唯一性和不可逆性。 数字摘要的生成取决于 Hash 算法，常用的 Hash 算法有 MD5 、SHA1、SHA256，MD5 的长度是128位，SHA1的长度是160位，SHA256的长度为256位。 非对称加密 非对称加密也称为公钥密码。我更愿意用非对称加密这种叫法。因为可以体现出加密和解密使用不同的密钥。 对称加密中，我们只需要一个密钥，通信双方同时持有。而非对称加密需要4个密钥。通信双方各自准备一对公钥和私钥。其中公钥是公开的，由信息接受方提供给信息发送方。公钥用来对信息加密。私钥由信息接受方保留，用来解密。 一次信息传输的非对称加、解密过程： 消息接收方准备好公钥和私钥 私钥接收方自己留存、公钥发布给消息发送方 消息发送方使用接收方公钥对消息进行加密 消息接收方用自己的私钥对消息解密 公钥只能用做数据加密。公钥加密的数据，只能用对应的私钥才能解密。这是非对称加密的核心概念。 数字签名： 通过自己私钥对明文进行加密得到的一段数字串，用于保证信息来源的真实性和消息的完整性。 数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者用发送者的公钥解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 数字证书： 校验过程有个前提：接收方必须要知道发送方的公钥和所使用的算法。如果数字签名和公钥一起被篡改，接收方无法得知，还是会校验通过。如何保证公钥的可靠性呢？ 答案是数字证书，数字证书是身份认证机构（CA）颁发的，包含了以下信息： 证书颁发机构 证书颁发机构签名 证书绑定的服务器域名 证书版本、有效期 签名使用的加密算法（非对称算法，如RSA）、公钥 等 接收方收到消息后，先向CA验证证书的合法性（根据证书的签名、绑定的域名等信息。CA机构是权威的，可以保证这个过程的可靠性）再进行签名校验。 Android 签名与传统签名机制有些许不同。 首先，APK 的数字证书没有通过 CA 机构申请，而是开发者自定义的，且 Android 在安装 APK 时并不会校验证书本身的合法性，只是从中提取公钥和加密算法。正因如此，第三方 APK 在重新签名后依然能在没有安装这个 APK 系统中继续安装。 此外，Android 在对 APK 签名时并没有直接指定私钥、公钥和数字证书，而是使用 keystore 文件，将这些信息都包含在 keystore 文件中。 二、签名过程目前 Android 支持以下四种应用签名方案： v1方案：基于 JAR 签名。 v2方案：Android 7.0 引入，改动大。 v3方案：Android 9.0 引入，基于 v2 的升级。 v4方案：Android 11.0 引入，用来支持 ADB 增量 APK 安装。 V1 方案我们如果选中一个任意签名后的 apk 进行解压，会找到一个 META-INF 文件，这个文件里一般会有以 MF、SF 和 RSA 结尾的文件，如图： MANIFEST.MF：保存了 APK 除 META-INF 目录外的所有文件对应的数字摘要信息。在签名过程中，首先会遍历 APK 包下的所有文件，然后逐个生成 SHA256（JDK7.0之前采用 SHA1算法)数字摘要信息，再用 base64 进行编码之后将生成的摘要写入 MANIFEST.MF 文件中。 *.SF：对前一步生成的 MANIFEST.MF每一项值，使用 SHA256（JDK7.0之前采用 SHA1算法） 算法，用计算二次摘要，其中的值是对清单文件里的 SHA256 再进行 SHA256 后再次 base64 得到。 *.RAS：这里会把之前生成的 CERT.SF文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。 这里要注意的是， Android APK中的CERT.RSA证书是自签名的，并不需要这个证书是第三方权威机构发布或者认证的，用户可以在本地机器自行生成这个自签名证书。Android 目前不对应用证书进行 CA 认证。 签名验证过程 签名验证是发生在apk的安装过程中，一共分为三步： （1）检查apk中包含的所有文件，对应的摘要值与MANIFEST.MF文件中记录的值一致。 （2）使用证书文件（RSA文件）检验签名文件（SF文件）没有被修改过。 （3）使用签名文件（SF文件）检验MF文件没有被修改过。 为什么使用这样的签名流程呢？ 我们假设一下，首先，如果你改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。 其次，如果你对更改过的文件相应的算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。 最后，如果你还不死心，继续计算MANIFEST.MF的摘要值，相应的更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。 那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。 V2 方案V1方案存在以下问题： 覆盖范围不足：Zip 文件中部分内容不在验证范围，例如 META-INF 文件夹； 验证性能差：验证程序必须解压所有压缩的条目，这需要花费更多时间和内存 存在Janus漏洞：恶意开发人员可以通过Janus漏洞去绕过Android 的v1签名验证机制。 V2 是 Android 签名方案的一大步，它解决了 V1 遗留的签名校验慢和完整性的问题。Android7.0 中开始引入了APK签名方案v2，一种全文件签名方案，该方案能够发现对APK的受保护部分进行所有更改，相比v1来说校验速度更快，覆盖的范围也更广。但是考虑到版本兼容的问题，所以一般常见了v1+v2的混合签名模式。 V2 的实现原理是对 ZIP 文件进行一定处理。 ZIP 文件结构包括三大部分：数据区、中央目录和中央结尾记录，数据区包含了所有的文件记录，中央目录存储了所有本地文件头信息，中央目录结尾存放了中央目录的相关信息。 在解析 ZIP 文件时，程序首先会找到 ZIP 文件的 中央目录结尾，然后在中央目录结尾中找到 核心目录的起始偏移量 定位到 中央目录起始位置，然后开始遍历中央目录里的 本地文件头 ，根据本地文件头中的 文件头的相对位移 定位到相应的本地文件。 V2 是一种全文件签名方案，在使用 V2 方案对 APK 进行签名时，会在 APK 文件中插入一个 APK 签名分块，该分块位于 ZIP 中央目录 部分之前并紧邻该部分。在APK 签名分块 内，v2 签名和签名者身份信息会存储在 APK 签名方案 v2 分块中。 APK Signing Block 结构如下: 其中，APK签名方案V2分块才存着签名信息。在解析 APK 文件时，首先要通过以下方法找到 ZIP 中央目录 的起始位置：在文件末尾找到 ZIP 中央目录结尾 记录，然后从该记录中读取 中央目录的起始偏移量 。再往前通过 magic 值，可以快速确定中央目录前方可能是 APK 签名分块。然后，通过 size of block 值，可以高效地找到该分块在文件中的起始位置。 APK签名方案V2分块具体结构如下: SignerData（签名者数据）：主要包括签名者的证书，整个APK完整性校验hash，以及一些必要信息。 Signature（签名）：开发者对SignerData部分数据的签名数据。 PublicKey（公钥）：用于验签的公钥数据。 签名流程 步骤： 对原始apk文件的 文件信息部分、中央目录部分、EoCD部分，按照 1MB 大小分割为多个小块（Chunks）; 分别对每一个小块计算其摘要，类似于 V1 签名中的 MANIFEST.MF 文件； 对(2)中所有摘要计算其摘要，类似于 V1 签名中的 CERT.SF 文件； 添加X.509开发者数字证书（公钥） 这样一个签名者的SignerData数据都完成了 然后使用私钥对SignerData进行签名写到Signature里，把公钥写在PublicKey里 验证签名步骤 对 APK 签名方案 v2 分块中的每个 signer，执行以下操作： 从 signatures 中选择安全系数最高的受支持 signature algorithm ID。安全系数排序取决于各个实现&#x2F;平台版本。 使用 public key 并对照 signed data 验证 signatures 中对应的 signature。（现在可以安全地解析 signed data 了） 验证 digests 和 signatures 中的签名算法 ID 列表（有序列表）是否相同。（这是为了防止删除&#x2F;添加签名） 使用签名算法所用的同一种摘要算法计算 APK 内容的摘要。 验证计算出的摘要是否与 digests 中对应的 digest 一致。 验证 certificates 中第一个 certificate 的 SubjectPublicKeyInfo 是否与 public key 相同。 如果找到了至少一个 signer，并且对于每个找到的 signer，第 2 步都取得了成功，APK 验证将会成功。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"算法输入输出","slug":"Study/算法/算法输入输出","date":"2023-03-25T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/25/Study/算法/算法输入输出/","link":"","permalink":"https://beichen.link/2023/03/25/Study/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"引入输入包 import java.util.Scanner; 123456import java.util.Scanner;public class Main&#123; public static void main(String [] args)&#123; Scanner in = new Scanner(System.in); &#125;&#125; scanner.hasNextInt() &#x2F; scanner.nextInt() scanner.hasNextInt() 判断输入的这个字符是不是 int 类型，而不是接受这个字符一般和 scanner.nextInt()结合使用 scanner.nextInt()从控制台读取一个 int 类型, 遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容 1234Scanner scanner = new Scanner(System.in);while(scanner.hasNextInt())&#123;//如果输入的这个字符是int类型，那么获取 int num = scanner.nextInt();&#125; scanner.hasNextLine() &#x2F; scanner.nextLine() scanner.nextLine():读取一行，返回 String 类型，结束标记是 \\n, 读取输入后，nextLine()将光标定位在下一行 scanner.hasNextLine():根据行匹配模式去判断接下来是否有一行(包括空行\\n) scanner.hasNext() &#x2F; scanner.next() scanner.next():将空格看作是两个字符串的间隔，返回字符串，结束标记是 空格 scanner.hasNext():会判断接下来是否有非空字符 输入逗号分隔的数组 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // 1.new一个 Scanner 对象 Scanner sc = new Scanner(System.in); // 2.整数使用 nextInt(); int n = sc.nextInt(); // 3.nextLine()表示读取一行作为字符串，这里读取 n 后面的换行符 sc.nextLine(); int[] nums = new int[n]; // 4.数组作为一个字符串输入，并按照逗号切分，每个数字以 String 类型存储 // 4.1 扩展：sc.next()也是读取字符串，但是不是以换行分割，而是以空格分割 String[] input = sc.nextLine().split(&quot;,&quot;); // 5.String 转 int for (int i = 0; i &lt; n; i++) &#123; nums[i] = Integer.parseInt(input[i]); &#125; // 6.输出。print()仅输出内容，println输出内容并换行 for (int i = 0; i &lt; n; i++) &#123; System.out.print(nums[i]); if (i != n - 1) System.out.print(&quot;,&quot;); else System.out.print(&quot;\\n&quot;); &#125; &#125;&#125; 格式化输出 在需要指定输出小数位数的时候使用。 12345678910111213141516import java.text.DecimalFormat;public class Main &#123; public static void main(String[] args) &#123; // 方法一：String的format方法（推荐） double f = 111231.5585; // 保留 2 位小数（有四舍五入） System.out.println(String.format(&quot;%.2f&quot;, f)); // 方法二：DecimalFormat的format方法 double f = 111231.5585; DecimalFormat df = new DecimalFormat(&quot;#.00&quot;); System.out.println(df.format(f)); &#125;&#125; 输入数据个数或行数未知的情况 遇到这种情况需要判断输入是否结束。 1234567891011121314151617import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNextInt()) &#123; int num = sc.nextInt(); System.out.println(num); &#125; sc.nextLine(); // 读取数字后面的换行 while (sc.hasNextLine()) &#123; String str = sc.nextLine(); System.out.println(str); &#125; &#125;&#125; 更快的输入输出输入数据量大的时候会超时。此时使用 java.io 来处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; // 1.定义输入和输出 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out)); // 2.读入一个数字，默认读入String，需要转为 int int n = Integer.parseInt(reader.readLine()); // 3.读入一行，并按空格拆分 String s = reader.readLine(); String[] strs = s.split(&quot; &quot;); // 4.转为 int 数组 int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) &#123; nums[i] = Integer.parseInt(strs[i]); &#125; // 5.输出空行 writer.newLine(); // 6.输出数字 /* * BufferedWriter的write(int c)解释为“Writes a single character” * 所以其实写入的数据类型为char，内存长度只有2个字节，而且是以Unicode编码，所以会出现乱码 * 故需要将输入类型装换为 String 类型 */ writer.write(Integer.toString(n)); writer.newLine(); for (int i = 0; i &lt; n; i++) &#123; writer.write(Integer.toString(nums[i])); if (i &lt; n - 1) writer.write(&quot; &quot;); else writer.write(&quot;\\n&quot;); &#125; // 7.此时才会真正触发输出 writer.flush(); reader.close(); writer.close(); &#125;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"操作系统基础知识","slug":"Study/计算机基础/操作系统","date":"2023-03-22T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/22/Study/计算机基础/操作系统/","link":"","permalink":"https://beichen.link/2023/03/22/Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一、 进程之间通信方式进程之间通信是指不同进程之间交换数据或协调行为的方式。以下是几种常见的进程间通信方式： 管道（Pipe）：管道是一种半双工单向通信方式，其中一个进程写入数据，另一个进程从管道中读取。管道可以是匿名的或命名的，本质上就是内核中的一个缓存。 半双工通信，一条管道只能一个进程写，一个进程读。 一个进程写完后，另一个进程才能读，反之同理。 写了不读，管道也不会退出，命令就会卡住 管道这种通信方式效率低， 不适合进程间频繁地交换数据。 如果你学过Linux命令，那你肯定很熟悉 ｜ 这个竖线。 1$ ps auxf ｜ grep mysql 上面命令行里的 ｜ 竖线就是一个管道，它的功能是将前一个命令(ps auxf)的输出，作为后一个命令(grep mysq1)的输入，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才行。 同时，我们得知上面这种管道是没有名字，所以 ｜ 表示的管道称为匿名管道，用完了就销毁 消息队列（Message Queue）：发送进程将消息放入队列中，接收进程则从队列中接收消息。消息队列可以使用命名或非命名的方式创建。 前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。 对于这个问题，消息队列的通信模式就可以解决。比如，A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去读取数 据就可以了。同理，B进程要给A进程发送消息也是如此。 再来，消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体 (数据块)，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。 消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。 缺点：消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理 另一进程 读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。 共享内存（Shared Memory）：共享内存是一种更快速的进程通信方式。多个进程可以访问同一块内存，一端写入，另一端读取。需要注意的是，共享内存需要进行同步和互斥操作以避免竞争条件。 消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这一问题。 现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和 进程B的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去， 大大提高了进程间通信的速度。 信号（Signal）：信号是一种被动进程之间通信方式，一个进程可以将信号发送给另一个进程，该进程必须事先注册信号处理函数。 运行在shell终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如 Ctrl+C产生 SIGINT 信号，表示终止该进程； Ctrl+Z产生 SIGTSTP 信号，表示停止该进程，但还未结束； 如果进程在后台运行，可以通过kill命令的方式给进程发送信号，但前提需要知道运行中的进程PID号，例如： kill -9 1050，表示给PID为1050的进程发送SIGKILL 信号，用来立即结束该进程（例如：在任务管理器右键结束进程）； 所以，信号事件的来源主要有硬件来源(如键盘Cltr+C)和软件来源(如kill命令)。 信号量 当使用共享内存的通信方式，如果有多个进程同时往共享内存写入数据，有可能先写的进程的内容被其他进程覆盖了。因此需要一种保护机制，信号量本质上是一个整型的计数器，用于实现进程间的互斥和同步。 信号量代表着资源的数量，操作信号量的方式有两种： P操作：这个操作会将信号量减一，相减后信号量如果小于0，则表示资源已经被占用了，进程需要阻塞等待；如果大于等于0，则说明还有资源可用，进程可以正常执行。V操作：这个操作会将信号量加一，相加后信号量如果小于等于0，则表明当前有进程阻塞，于是会将该进程唤醒；如果大于0，则表示当前没有阻塞的进程。 如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为1。 具体的过程如下： 进程A在访问共享内存前，先执行了P操作，由于信号量的初始值为1，故在进程A执行P操作后信号量变为0，表示共享资源可用，于是进程A就可以访问共享内存。 若此时，进程B也想访问共享内存，执行了P操作，结果信号量变为了-1，这就意味着临界资源已被占用, 因此进程B被阻塞。 直到进程A访问完共享内存，才会执行V操作，使得信号量恢复为0，接着就会唤醒阻塞中的进程B，使得进程B可以访问共享内存，最后完成共享内存的访问后，执行 V操作，使信号量恢复到初始值1。 另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。 例如，进程A是负责生产数据，而进程B是负责读取数据，这两个进程是相互合作、相互依赖的，进程A必须先生产了数据，进程B才能读取到数据，所以执行是有前后顺序的。 那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为0。 具体过程： 如果进程B比进程A先执行了，那么执行到P操作时，由于信号量初始值为0，故信号量会变为-1，表示进程 A 还没生产数据，于是进程B就阻塞等待； 接着，当进程A生产完数据后，执行了V操作，就会使得信号量变为0，于是就会唤醒阻塞在P操作的进程B； 最后，进程B被唤醒后，意味着进程A已经生产了数据，于是进程B就可以正常读取数据了。 可以发现，信号初始化为0，就代表着是同步信号量，它可以保证进程A应在进程B之前执行。 套接字（Socket）：套接字是一种传输层协议，可以用于网络通信，也可以用于本地进程通信。套接字可以是基于流的或基于数据报的。 前面提到的管道，消息队列，共享内存，信号量和信号都是在同一台主机上进行进程间通信，如果想要跨网络和不同主机上的进程进行通信，则需要用到socket。 实际上，Socket不仅可以跨网络和不同主机进行进程间通信，还可以在同一主机进行进程间通信。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://beichen.link/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"反 IDA 分析","slug":"Study/逆向知识/反IDA分析","date":"2023-03-22T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/03/22/Study/逆向知识/反IDA分析/","link":"","permalink":"https://beichen.link/2023/03/22/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E5%8F%8DIDA%E5%88%86%E6%9E%90/","excerpt":"","text":"So文件 Android中的so文件是动态链接库，是二进制文件，即ELF文件。多用于NDK开发中。 1. 指令膨胀比如将简单的几条指令膨胀到几万条，增加控制流的复杂度，增加无用的控制流，但是完成的是相同的功能，这会给反汇编输出的阅读者带来了很大的困扰。 指令膨胀会显著增大输出的二进制可执行文件的体积，所以一般仅用于加固敏感部分的代码。对于指令膨胀，我们需要分析被膨胀部分的函数的输入和输出，猜测这部分指令的用途，再使用动态调试来辅助分析。 2. 虚拟机加固类似 VMProtect的方式。无论静态分析还是动态分析，你只能看到虚拟机本身的指令，和未知格式的指令。你只能试着分析和理解虚拟机的指令格式。想象一下，如果你对 Java 一无所知，有人给你了一个 Java 虚拟机的二进制文件，和一个 Java .class 文件。 3. 动态计算目标地址隐藏真实的控制流路径。利用多线程、进程间通讯、信号量来控制程序的执行。你需要仔细的分析这些控制逻辑，必要时使用动态分析来辅助。 注：可以通过动态计算函数调用地址方式反IDA F5使之失效，中间插入无效指令 4. 花指令花指令又称脏字节，英文为”junkcode”，顾名思义，即在程序中加入的一些垃圾指令，其目的是在不妨碍原有程序执行的前提下，阻碍程序反编译，增加静态分析难度，隐匿不想被逆向分析的代码块，混淆代码，绕过特征识别。 这也可以对抗 F5 反编译 反汇编器静态分析算法一般有两种： 一是线性扫描，从程序入口处依次读取机器码并进行反汇编，逐行命令进行线性扫描，在于在冯诺依曼体系结构下，无法区分数据与代码，从而导致将代码段中嵌入的数据误解释为指令的操作码，采用线性扫描技术的反汇编工具如OD、Windbg； 二是递归下降，从程序入口开始读取机器码进行反汇编，通过程序的控制流确定反汇编的下一条指令，遇到无条件跳转则从跳转目的地址处继续解析，遇到条件跳转则从两个命令执行分支处进行解析 (优先解析顺序执行分支)，即采用模拟程序运行的方式增加反汇编的准确度，采用递归下降反汇编的如IDA。 不可执行花指令指这部分花指令在程序执行过程中不会被执行，它是利用反汇编器 静态分析算法的缺陷 使得代码在反编译解析时出错。其原理使反汇编分析执行流命中执行会出错的垃圾数据，就会造成解析错误，而实际执行过程中垃圾数据并不会执行。 如：构造花指令破坏堆栈平衡 汇编中函数如果有参数或局部变量，在调用前会对堆栈进行保护 ，在返回前要还原函数调用前的堆栈，这一过程程序在编译时会自动加上，如果反编译器检测到指令破坏了堆栈平衡，即函数返回时与调用时堆栈状态发生了变化，就会报错。可以利用这一点构造破坏堆栈平衡的花指令，如下代码 1234567891011#include &quot;stdio.h&quot;int main(int argc, char const* argv[])&#123; _asm&#123; test eax,0 // 构造必然条件实现跳转(判断 eax 与 0 与的结果)，绕过破坏堆栈平衡的指令 jz label add esp,0x1 // 破坏了栈指针 label: &#125; printf(&quot;Hello world!\\n&quot;); return 0;&#125; 这类破环堆栈平衡的指令实际不会执行，但是由于IDA在反汇编分析时会分别从两个条件跳转处开始分析，因此判定堆栈不平衡导致反汇编失败，解决方法是NOP掉破坏堆栈平衡的指令。 可执行花指令花指令在程序执行过程中会被执行，但执行这些代码没有任何意义，执行前后不改变任何寄存器的值，也不改变程序执行逻辑和结果，目的是加大静态分析的难度，或是混淆特征码，绕过特征检测。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"网络基础知识","slug":"Study/计算机基础/网络","date":"2023-03-22T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/22/Study/计算机基础/网络/","link":"","permalink":"https://beichen.link/2023/03/22/Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/","excerpt":"","text":"网络模型 Tcp 与 Udp 区别 这里的「面向字节流」和「面向报文」该如何理解 发送方 UDP 对应用程序交下来的报文,在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文,既不合并,也不拆分,而是保留这些报文的边界。接收方 UDP 对 IP 层交上来的 UDP 用户数据报,在去除首部后就原封不动地交付上层的应用进程,一次交付一个完整的报文,所以说 UDP 是面向报文的。 而发送方 TCP 对应用程序交下来的报文数据块,视为无结构的字节流(无边界约束),但维持各字节,所以说 TCP 是面向字节流的。 Http、Https 两者区别 Http 是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，是一种用于在 Web 浏览器和 Web 服务器之间传输数据的应用层协议。 Https 是 HTTP 协议的一种安全版本，通过 SSL&#x2F;TLS 协议加密 HTTP 通讯内容，从而保证通讯过程中不被窃听和篡改。 两者的主要区别如下： 数据传输安全性：Http 的数据传输是明文传输的，网络上的任何人都可以拦截和查看数据；而 Https 采用 SSL&#x2F;TLS 协议对请求和响应进行加密，保证数据传输的安全性。 传输速度：由于 Https 需要进行加密和解密的操作，所以在数据传输的过程中，Https 比 Http 要慢。 端口号：Http 的默认端口号是 80，Https 的默认端口号是 443。 证书认证：Https 通信需要使用证书，每一个网站都需要有自己的数字证书。而 Http 不需要数字证书。 HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。) 使用场景：Http 主要用于 Web 开发、数据传输等方面，而 Https 主要用于保护用户的敏感信息，如银行、电商等领域。 总之，Https 相比 Http，更加安全可靠，但也更耗费资源和时间成本。 TCP 三次握手过程及状态变化 TCP 的三次握手和四次挥手实质就是 TCP 通信的连接和断开。 三次握手：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤 为什么是三次握手，不是两次握手呢 一个是保证序列号的同步机制 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认 另一个是防止重复连接，防止失效的连接请求报文段被服务端接收，从而产生错误。 PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入 ESTABLISHED 状态，而服务端在收到连接请求后就进入 ESTABLISHED 状态。 此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入 ESTABLISHED 状态，等待发送数据或主动发送数据。但此时的客户端早已进入 CLOSED 状态，服务端将会一直等待下去，这样浪费服务端连接资源。 四次挥手：即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。 ​ 三次握手过程详细说明： 客户端发送建立 TCP 连接的请求报文，其中报文中包含 seq 序列号，是由发送端随机生成的，并且将报文中的 SYN 字段置为 1，表示需要建立 TCP 连接。同时客户端进入 SYN-SEND 状态，等待服务器端回应（SYN&#x3D;1，seq&#x3D;x，x 为随机生成数值）； 服务端回复客户端发送的 TCP 连接请求报文，其中包含 seq 序列号，是由回复端随机生成的，并且将 SYN 置为 1，而且会产生 ACK 字段，ACK 字段数值是在客户端发送过来的序列号 seq 的基础上加 1 进行回复，以便客户端收到信息时，知晓自己的 TCP 建立请求已得到验证。表示服务器端已经收到了客户端的请求，并且准备好建立连接。此时，服务器端进入 SYN-RECEIVED 状态 客户端收到服务端发送的 TCP 建立验证请求后，会使自己的序列号加 1 表示，并且再次回复 ACK 验证请求，在服务端发过来的 seq 上加 1 进行回复。客户端和服务器端都进入 ESTABLISHED 状态，可以开始传输数据。 ​ 四次挥手： 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。 客户端发送断开 TCP 连接请求的报文，其中报文中包含 seq 序列号，是由发送端随机生成的，并且还将报文中的 FIN 字段置为 1，表示需要断开 TCP 连接。此时，客户端进入 FIN-WAIT-1 状态，等待服务器端的回应。； 收到挥手后，服务器进入 CLOSE-WAIT 状态。服务端会回复客户端发送的 TCP 断开请求报文，其包含 seq 序列号，是由回复端随机生成的，而且会产生 ACK 字段，ACK 字段数值是在客户端发过来的 seq 序列号基础上加 1 进行回复，以便客户端收到信息时，知晓自己的 TCP 断开请求已经得到验证。在这个状态下，服务器端还可以发送数据给客户端；收到后，客户端进入 FIN-WAIT-2 状态 服务端在回复完客户端的 TCP 断开请求后，不会马上进行 TCP 连接的断开，服务端会先确保断开前，所有传输到 A 的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的 FIN 字段置 1，并且产生随机 seq 序列号。服务端进入 LAST_ACK 状态； 客户端收到服务端的 TCP 断开请求后，客户端进入 TIME_WAIT 状态。同时会回复服务端的断开请求，包含随机生成的 seq 字段和 ACK 字段，ACK 字段会在服务端的 TCP 断开请求的 seq 基础上加 1，从而完成服务端请求的验证回复。客户端、服务端进入 CLOSED 状态 至此 TCP 断开的 4 次挥手过程完毕。为什么 A 要先进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态 为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，B 等待超时后就会重新发送连接释放请求，但此时 A 已经关闭了，不会作出任何响应，因此 B 永远无法正常关闭 浏览器上输入地址后的整个请求过程 DNS 解析：浏览器首先向 DNS 服务器发出域名解析请求，获取域名对应的 IP 地址。 TCP 连接：浏览器与服务器建立 TCP 连接，进行三次握手，确保可靠性。 发送 HTTP 请求：浏览器向服务器发送 HTTP 请求，请求中包含请求方式、请求头、请求体等信息。 服务器响应：服务器接收到浏览器发送的请求，根据请求做出相应的处理，并将响应结果返回给浏览器。响应包含状态码、响应头、响应体等信息。 接收文件：浏览器接收到服务器返回的响应结果。如果响应的是 HTML 页面，浏览器会对页面的格式和内容进行解析，并向服务器请求页面中的其他资源，如图片、视频等。 渲染页面：浏览器将页面的 HTML、CSS、JS 等文件解析完成后展示给用户。 断开连接：浏览器与服务器断开 TCP 连接，请求结束。 HTTP &#x2F; 1.1 针对于 http1.1 版本主要需要说明两点内容—-HTTP 无连接以及 HTTP 无状态 HTTP 无连接 无连接指的是 tcp 三次握手后建立的双向链接只能支持一次数据的传输，即使用一次就断开 如果一直处于无连接状态那么用户每次请求就会重新建立 tcp 的双向链路，此时的访问速度就有优化的空间 但是无连接仅仅只是 HTTP 1.0 版本，1.1 开始就有 keep alive 选项，意思为 http 数据传输后将 tcp 链接保持在打开的状态，以便未来的 http 请求继续使用，优点是 keepalive 长链接模式更加高效，避免了链接建立和释放的资源开销，缺点是长时间的 tcp 链接容易导致系统资源无效占用，浪费系统资源 HTTP 无状态 http 无状态是指协议对于交互性场景没有记忆能力，其实就是默认情况下 http 没有缓存功能，假设此时我们输入账户密码，刷新一次又需要重新输入 http 无状态的解决办法是什么？最主要的目的就是让服务器有记忆能力，现在我们较为常用的方法为 Cookie+Session HTTP 协议的响应码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常用的状态码： 200 OK &#x2F;&#x2F;客户端请求成功400 Bad Request &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用403 Forbidden &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务404 Not Found &#x2F;&#x2F;请求资源不存在，eg：输入了错误的 URL500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误503 Server Unavailable &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Session 和 Cookie 的关系 cookie cookie 其实是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就会在响应请求是使用 set-cookie 将用户状态信息写入到客户端浏览器文件中去 当浏览器下次请求访问该网站时会将 cookie 信息添加到 request 请求的数据当中来代替用户验证 由于 cookie 保存的数据信息是存在于客户端的浏览器目录下，所以此文件会有被篡改的风险，基于此种原因，出现了一种基于 cookie 的机制 Session Session Session 是另外一种记录客户端状态的机制，不同的是 cookie 保存在客户端浏览器中，而 Session 保存在服务器上。Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。 session 不仅会将客户端信息存储在服务器上，还会有一小部分信息存储在浏览器的 cookie 中，此时存储在 cookie 的内容相当于一把用来打开服务器对应信息的钥匙 首先用户登录，server 会为用户生成一个 session，为其分配唯一的 sessionId，这个 sessionId 是与某个用户绑定的，也就是说根据此 sessionid（假设为 abc） 可以查询到它到底是哪个用户，然后将此 sessionid 通过 cookie 传给浏览器之后浏览器的每次添加购物车请求中只要在 cookie 里带上 sessionId&#x3D;abc 这一个键值对即可，server 根据 sessionId 找到它对应的用户后，把传过来的商品 id 保存到 server 中对应用户的购物车即可 优点是解决了纯 cookie 可能被篡改文件的风险(就算你要改，改的也就是开锁的内容，并不触及到真正的用户信息)；缺点： 在集群环境下读取服务器存储的信息会有速度问题 get 和 post 的区别 get 请求用来从服务器上获得资源，而 post 是用来向服务器提交数据； get 将表单中数据按照 name&#x3D;value 的形式，添加到 action 所指向的 URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post 是将表单中的数据放在 HTTP 协议的请求头或消息体中，传递到 action 所指向 URL； get 传输的数据要受到 URL 长度限制（最大长度是 2048 个字符）；而 post 可以传输大量的数据，上传文件通常要使用 post 方式； get 可被浏览器缓存，post 不行 Http2.0、Http1.1、Http1.0 有哪些特性 HTTP 是一种应用协议，常用的有 HTTP1.0，HTTP1.1 和 HTTP2.0。各版本的 HTTP 在特性上存在一些差异，下面是它们的主要特点： HTTP1.0 HTTP1.0 是最早的 HTTP 协议版本，具有以下特点: 无状态：HTTP1.0 协议是无状态协议，无法保存之前请求的信息，每个请求都是独立的。 每次请求连接：HTTP1.0 协议每次请求都需要建立连接，请求响应之后立即断开连接。 无需压缩：HTTP1.0 不支持内容压缩，这样会导致传输的数据比较大，影响性能。 HTTP1.1 HTTP1.1 是在 HTTP1.0 的基础上发展起来的，主要包括以下特点: 持续连接：HTTP1.1 支持持久连接技术，即同一个连接可以在多个请求响应之间持续保持。 分块传输：支持分块传输，可以先传输一个头部，而不是等待整个文档下载完成之后再进行传输。 内容压缩：HTTP1.1 支持内容压缩技术，可以有效地减少传输的数据量，提高传输效率。 Host 请求头：HTTP1.1 支持 Host 请求头，可以在一个 IP 上运行多个 Web 站点。 HTTP2.0 HTTP2.0 是 HTTP1.1 的升级版，引入了一些新的特点： 多路复用：HTTP2.0 支持多路复用技术，可以通过一个连接同时发送多个请求和响应。 二进制协议：HTTP2.0 采用二进制协议（HTTP1.x 采用的是文本协议），可以有效减少传输数据量。 服务器推送：HTTP2.0 支持服务器推送技术，服务器可以在客户端请求页面之前将一些资源推送给客户端，提高加载速度。 请求优先级：HTTP2.0 支持请求优先级，客户端可以指定请求的优先级，可以更快的响应用户请求。 TCP 的拥塞控制 流量控制和拥塞控制的区别 流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。 拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。 TCP 中的拥塞控制 (qq.com) TCP 中使用了四种拥塞控制算法 慢开始 拥塞避免 快重传 快恢复 HTTPS 过程 数字签名：是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是靠数字签名技术。 数字签名原理： CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。 现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。 客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败 使用公钥加密和使用私钥加密的区别所在： 公钥加密，私钥解密的作用是加密信息。因为只有拥有私钥的人才可以获取信息明文。 私钥加密，公钥解密的作用是身份认证。因为只有拥有私钥的人才可以发送信息密文 TCP | IP 报文格式 IP 版本：4 位，用来表明 IP 协议实现的版本号，当前一般为 IPv4，即 0100，IPv6 的为 0110，这个字段确保可能运行不同 IP 版本的设备之间的兼容性。 首部长度：即报头长度，4 位，以 32 bit 的字来定义 IP 首部的长度，包括可选项。若该字段的最小值是 5 (标准头部长度)，即 532&#x3D;160 比特 &#x3D;20 字节，此字段最大值为 15 (有扩展部分)，即 1532 &#x3D;480 比特 &#x3D; 60 字节。 总长度：16 位，指明整个数据报的长度，按字节计算，最大长度为 2^16 字节。 标识：16 位，用来唯一标识主机发送的每一份数据报，IP 软件会在存储器中维持一个计数器，每产生一个数据段，计数器就加 1，并将此值赋给标志字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收问题，如数据报由于超过网络的 MTU (最大传送单元) 而必须分片时，这个标志字段的值就会被复制到所有的数据报的标识字段中，相同的标识字段的值使分片后各数据报片能正确的重装成为原来的数据报。 标志：3 位，分别是 RF、DF、 MF，目前只有 DF，MF 有效，DF(don’t fragment)，置为 0 时表示可以分段，置为 1 时是不能被分段，MF(more fragment)，置为 0 时表示该数据段为最后一个数据段，置为 1 时表示后面还有被分割分段。 段偏移量：13 位，指出较长的分组在分段后，某段在原分组的相对位置。也就是说相对用户字段的起点，该片从何处开始。段偏移以 8 个字节(有 3 位被 flags 占据)为偏移单位，这就是每个分片的长度一定是 8 字节 (64 位) 的整数倍。 生存期：8 位，用来设置数据报最多可以经过的路由器数，由发送数据的源主机设置，通常为 32、64、128 等，每经过一个路由器，其值减 1 ，直到 0 该数据报被丢弃。 协议：8 位，指明 ip 数据字段中的数据采用上层什么协议封装的，常见的有 ICMP(1)、IGMP(2)、TCP(6)、UDP(17) 首部校验和：16 位，填充根据 ip 头部计算得到的校验和码。计算方法是：对头部中每个 16 比特进行二进制反码求和，但不含涉及头部后的数据字段。 源 IP 地址：源 ip 地址，32 位。 目的 IP 地址：目标 ip 地址，32 位。 数据：不定长度，但受限于数据报的最大长度 2^16 ，这是在数据报中要传输的数据，它是一个完整的较高层报文或报文的一个分片。 TCP 源端口：2 个字节，是一个大于 1023 的 16 位数字，由基于 TCP 应用程序的用户进程随机选择。 目的端口：2 个字节，指明接收者所用的端口号，一般由应用程序来指定。 顺序号：4 个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数，序号是 32 bit 的无符号数，序号达到 2^32-1 后又从 0 开始。比如我们收到一个数据报中 sq(顺序号) &#x3D;0，数据报内容为 20 字节，那么下一个数据报的 sq 就应该是 21。当建立一个新的连接时，SYN 标志变为 1，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN。 确认序号：4 个字节，包含发送确认的一端所期待收到的下一个顺序号。因此，确认序号应该是上次已经成功收到数据字节顺序号加 1 。比如我们收到的一个数据报的 sq &#x3D; 0 ，数据报内容为 20 字节，那么我们的 ack(确认序号) 应该是 21 ，用来表明 sq&#x3D;0 ，内容为 20 字节的数据报已经收到，接下来期望收到的是 sq&#x3D;21 的数据报。只有 ACK 标志为 1 时确认序号字段才有效。 报文长度：4 位，给出报头中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的，这个字段占 4 bit，即 TCP 最多有 60 (15*4) 字节的首部。 保留区：6 位，保留给将来使用，目前必须置为 0 。 控制位：6 位，控制位包括 URG：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。 ACK：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。 PSH：为 1 表示是带有 PUSH 标志的数据，表示发送端缓存中已经没有待发送的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。 RST：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。 SYN：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步。 FIN：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。 窗口大小：2 个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。窗口大小是一个 16 bit 字段，因而窗口大小最大为 2^16-1 。 校验和：2 个字节，对整个的 TCP 报文段(包括 TCP 头部和 TCP 数据以及伪报文头)进行校验和计算。这是一个强制性的字段，要求由发送方计算和存储，并由接收端进行验证(接收端要与发送端数值结果完全一样，才能证明数据是有效的)。 紧急指针：2 个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式，只有当 URG 标志置为 1 时紧急指针才有效。 选项：n*4 字节，常见的可选字段是最长报文大小 MSS(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段 (为建立连接而设置 SYN 标志的那个段) 中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以需要添加填充位，使得报文长度为 32 位字的整数倍。 数据：不定长度，为上层协议封装好的数据。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://beichen.link/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Android 安全机制","slug":"Study/Android知识/Android安全机制","date":"2023-03-21T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/21/Study/Android知识/Android安全机制/","link":"","permalink":"https://beichen.link/2023/03/21/Study/Android%E7%9F%A5%E8%AF%86/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Android 系统架构Android采用分层的系统架构，由下往上分别是linux内核层、硬件抽象层、系统运行时库层、应用程序框架层和应用程序层。 Android 安全机制Android安全模型主要提供以下几种安全机制： 进程沙箱隔离机制 应用程序签名机制 权限声明机制 访问控制机制 进程通信机制 内存管理机制 1. 进程沙箱隔离机制 进程沙箱隔离机制，使得Android应用程序在安装时被赋予独特的用户标识（UID），并永久保持。应用程序及其运行的Dalvik虚拟机运行在独立的Linux进程空间，与其它应用程序完全隔离。 在特殊情况下，进程间还可以存在相互信任关系。如源自同一开发者或同一开发机构的应用程序，通过Android提供的共享UID（Shared UserId）机制，使得具备信任关系的应用程序可以运行在同一进程空间。 2. 应用程序签名机制规定APK文件必须被开发者进行数字签名，以便标识应用程序作者和在应用程序之间的信任关系。在安装应用程序APK时，系统安装程序首先检查APK是否被签名，有签名才能安装。当应用程序升级时，需要检查新版应用的数字签名与已安装的应用程序的签名是否相同，否则，会被当做一个新的应用程序。Android开发者有可能把安装包命名为相同的名字，通过不同的签名可以把他们区分开来，也保证签名不同的包不被替换，同时防止恶意软件替换安装的应用。 3. 权限声明机制AndroidMainifest文件权限声明。 要想获得在对象上进行操作，就需要把权限和此对象的操作进行绑定。不同级别要求应用程序行使权限的认证方式也不一样，Normal级申请就可以使用，Dangerous级需要安装时由用户确认，Signature和Signatureorsystem级则必须是系统用户才可用。 4. 访问控制机制确保系统文件和用户数据不受非法访问。 Android本质是基于Linux内核开发的，所以Android同样继承了Linux的安全特性，比如文件访问机制，Linux文件系统的权限控制是有user、group、other与读(r)、写（w）、执行（x）的不同组合来实现的。同样，Android也实现了这套机制，通常清空下，只有System、root用户才有权限访问到系统文件，而一般用户无法访问。 此处涉及到SE-Android 机制。 5. 进程通信机制基于共享内存的Binder实现，提供轻量级的远程进程调用（RPC）。通过接口描述语言（AIDL）定义接口与交换数据的类型，确保进程间通信的数据不会溢出越界。 此处涉及到Android Binder 机制 6. 内存管理机制基于Linux的低内存管理机制，设计实现了独特的LMK，将进程重要性分级、分组，当内存不足时，自动清理级别进程所占用的内存空间。同时，引入的Ashmem内存机制，使得Android具备清理不再使用共享内存区域的能力。 SE AndroidSEAndroid在架构和机制上与SELinux完全一样，考虑到移动设备的特点，所以移植到Android上的只是SELinux的一个子集。SEAndroid的安全检查几乎覆盖了所有重要的系统资源，包括域转换，类型转换，进程、内核、文件、目录、设备，App，网络及IPC相关的操作。 DAC 和 MACSELinux（Security-Enhanced Linux）是美国国家安全局（NSA）主导开发的Linux内核安全模块，为内核提供了强制访问控制（MAC），Linux默认的访问控制策略是自主访问控制（DAC） 在DAC中，对象的拥有者可以任意修改或授予此对象相应的权限，且进程理论上所拥有的权限与执行它的用户的权限相同； 这导致如果一个以root权限运行的进程被攻破， 攻击者就可以借此在系统中畅行无阻。 而在MAC中， 为所有进程和文件都设置了安全上下文， 当用户执行某项操作时， 除了要通过DAC的检查， 还需要符合MAC中制定的规则； 因此即便是root进程，其权限也会被限制在特定范围内，这虽然不能完全防御攻击，但可以将损失降到最低。任何进程想在 SELinux 系统上干任何事情，都必须在安全策略文件中赋予权限，凡是没有出现在安全策略文件中的权限都不拥有；即使你是root，也不一定拥有权限操作，这个并不能做到防御一切攻击，但是能将损失降到最小 SE-Linux 状态 Permissive mode: 其中权限拒绝被记录下来，但不强制执行。 Enforcing mode: 其中权限拒绝被记录和强制执行。 Disabled:表示SELinux没有实际运行。 可以通过getenforce和setenforce命令来查看和切换当前的模式 BinderBinder是什么？机制：Binder是一种进程间通信的机制 驱动：Binder是一个虚拟物理设备驱动 应用层：Binder是一个能发起进程间通信的JAVA类 Binder就是Android中的血管，在Android中我们使用Activity,Service等组件都需要和AMS（system_server）进行通信，这种跨进程的通信都是通过Binder完成。 为什么使用Binder 性能方面 Binder相对于传统的Socket方式，更加高效 Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂，且不安全。 安全方面 传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信的IP地址是客户端手动填入，很容易进行伪造 Binder机制从协议本身就支持对通信双方做身份校检，从而大大提升了安全性。 为什么要用多进程？ 虚拟机给每一个进程分配的内存是有限制的,LMK会优先回收对系统资源占用多的进程 为了突破内存限制，防止占用内存过多被杀 功能稳定性，一个进程崩溃对另外进程不造成影响：将不稳定功能放入独立进程 规避内存泄漏，独立的WebView进程阻隔内存泄漏导致问题 进程隔离： 操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离。 A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。 Binder原理1. IPC 原理从进程角度来看IPC（Inter process Communication）机制 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。 现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。 单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。 虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。 系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。 那么，传统的 IPC 方式中，进程之间是如何实现通信的？ 通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copyfromuser() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copytouser() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图： 这种传统的 IPC 通信方式有两个问题： 性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝； 接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。 2. Binder 跨进程通信原理动态内核可加载模块 &amp;&amp; 内存映射正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？ 这就得益于 Linux 的动态内核可加载模块（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。 那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。 这就不得不通过 Linux 下的另一个概念：内存映射。 Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。 映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。 内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。 Binder IPC 实现原理一次完整的 Binder IPC 通信过程通常是这样： 首先 Binder 驱动在内核空间创建一个数据接收缓存区； 接着在内核空间开辟一块内核缓存区，建立内核缓存区和内核中数据接收缓存区之间的映射关系，以及内核中数据接收缓存区和接收进程用户空间地址的映射关系； 发送方进程通过系统调用 copyfromuser() 将数据 copy 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。 Android的binder机制中发送进程为什么不和内核缓冲区以及接收进程同时建立内存映射？ 消息传递相比共享内存，大大降低了并发环境下处理同步互斥的复杂度，代价是额外的memcpy开销。 具体从Binder实现上来讲，可能你会觉得，如果收发双方都用共享内存，把共享区域当成消息传递的buffer，不是可以一举两得吗？发送方在buffer里构造好一个合法的binder调用请求，然后通知接收方读取，这样一次额外的memcpy都不用，也不需要额外的同步。 问题是，如果发送方是一个恶意的进程，在通知了接收方读消息以后，自己又去修改buffer——就可以轻松的跳过binder的数据验证，构造出能够造成越界访问的恶意数据。轻则crash收方进程和&#x2F;或binder驱动，造成其他应用&#x2F;系统&#x2F;内核崩溃，重则代码注入，拿下root。 用共享内存就会有race condition，就需要同步互斥，不然就可能会有各种各样的问题。Binder在设计上已经省掉了从binder驱动到接收进程的一次copy_to_user()，可以说是一个兼顾了多方面考虑的务实方案。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"Android ClassLoader","slug":"Study/Android知识/Android ClassLoader","date":"2023-03-20T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/20/Study/Android知识/Android ClassLoader/","link":"","permalink":"https://beichen.link/2023/03/20/Study/Android%E7%9F%A5%E8%AF%86/Android%20ClassLoader/","excerpt":"","text":"ClassLoader（Java）ClassLoader，顾名思义，就是用来动态加载 class 文件的。 ClassLoader 作用主要有三个：负责将 Class 加载到 JVM 中、审查每个类由谁加载（父优先的等级加载机制）、将 Class 字节码重新解析成 JVM 统一要求的对象格式 ClassLoader 是用来加载 class 文件的，它负责将*.class 加载为内存中的 Class 对象 加载机制为“双亲委派”，即能交给父类加载器去加载的，绝不自行加载 Class clz &#x3D; Classloader.loadClass(类全名)，其实就是通过一个类的全名，生成这个类的 Class 对象。 loadClass（）内部是先进行 parent.loadClass()让父类先进行加载，如果加载不成功，再使用该 classLoader 加载（双亲委派）。 双亲委派模型是一种组织类加载器之间关系的一种规范，他的工作原理是：如果一个类加载器收到了类加载的请求，它不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，这样层层递进，最终所有的加载请求都被传到最顶层的启动类加载器中，只有当父类加载器无法完成这个加载请求(它的搜索范围内没有找到所需的类)时，才会交给子类加载器去尝试加载。 优点：java 类随着它的类加载器一起具备了带有优先级的层次关系，这是十分必要的。比如 java.lang.Object，它存放在\\jre\\lib\\rt.jar 中，它是所有 java 类的父类，因此无论哪个类加载都要加载这个类，最终所有的加载请求都汇总到顶层的启动类加载器中，因此 Object 类会由启动类加载器来加载，所以加载的都是同一个类，如果不使用双亲委派模型，由各个类加载器自行去加载的话，系统中就会出现不止一个 Object 类，应用程序就会全乱了。 双亲委派的作用 防止同一个.class 文件重复加载。 对于任意一个类确保在虚拟机中的唯一性。由加载它的类加载器和这个类的全类名一同确立其在 Java 虚拟机中的唯一性。 保证.class 文件不被篡改，通过委派方式可以保证系统类的加载逻辑不被篡改。 然后，通过 findClass（类全名）来加载得到 Class 对象。 我们如果想自定义一个 classLoader，那么就是重写 findClass（）方法。findClass（）中，我们拿到要加载的路径，然后拿到路径对应文件的数据流。然后使用 classLoader 定义好的 defineClass（inputStream）来生成 Class 对象就可以了，主要就是给它提供一个路径，然后类全名能找到这个路径下对应的.class 文件，然后生成 inputStream 流。 ClassLoader（Android）Android 中的 ClassLoader 于 Java 中的稍微有些不同，虽然两者都是满足双亲委派，但是直接 findClass（）会抛异常，所以我们不能直接继承 classloader 来自定义 classLoader。 要使用 BaseDexClassLoader，BaseDexClassLoader 重写了 findClass（），要注意的是这里的 classloader 加载的是 dex，不是 class 字节码。 ClassLoader 比较常用的分为两种，PathClassLoader 和 DexClassLoader，虽然两者继承于 BaseDexClassLoader，BaseDexClassLoader 继承于 ClassLoader，但是前者只能加载已安装的 Apk 里面的 dex 文件，后者则支持加载 apk、dex 以及 jar，也可以从 SD 卡里面加载。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"}]},{"title":"android 加固原理","slug":"Study/逆向知识/APP加固原理","date":"2023-03-20T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/20/Study/逆向知识/APP加固原理/","link":"","permalink":"https://beichen.link/2023/03/20/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/APP%E5%8A%A0%E5%9B%BA%E5%8E%9F%E7%90%86/","excerpt":"","text":"简单加固原理介绍 我们在加固的过程中需要三个对象： 需要加密的Apk(源Apk) 壳程序Apk(负责解密Apk工作) 加密工具(将源Apk进行加密和壳Dex合并成新的Dex) 我们拿到需要加密的Apk和自己的壳程序Apk，然后用加密算法对源Apk进行加密。 再将壳Apk进行合并得到新的Dex文件，最后替换壳程序中的dex文件即可，得到新的Apk。 那么这个新的Apk，我们也叫作脱壳程序Apk。他已经不是一个完整意义上的Apk程序了，他的主要工作是：负责解密源Apk.然后加载Apk,让其正常运行起来。 加密阶段：将一个文件(加密之后的源Apk)写入到Dex中，需要修改Dex文件头，即： 脱壳dex的工作： 通过反射置换android.app.ActivityThread 中的mClassLoader为加载解密出APK的DexClassLoader，该DexClassLoader一方面加载了源程序、另一方面以原mClassLoader为父节点，这就保证了即加载了源程序又没有放弃原先加载的资源与系统代码。 找到源程序的Application，通过反射建立并运行。 这里需要注意的是，我们现在是加载一个完整的Apk,让他运行起来，那么我们知道一个Apk运行的时候都是有一个Application对象的，这个也是一个程序运行之后的全局类。所以我们必须找到解密之后的源Apk的Application类，运行的他的onCreate方法，这样源Apk才开始他的运行生命周期。这里我们如何得到源Apk的Application的类呢？这个我们后面会说道。使用meta标签进行设置。 Dalvik虚拟机会加载我们经过修改的新的classes.dex文件，并最先运行ProxyApplication类。在这个类里面，有2个关键的方法：attachBaseContext和onCreate方法 在attachBaseContext方法里，主要做两个工作： 读取classes.dex文件末尾记录加密dex文件大小的数值，则加密dex文件在新classes.dex文件中的位置为：len(新classes.dex文件) – len(加密dex文件大小)。然后将加密的dex文件读取出来，保存到资源目录下 然后使用自定义的DexClassLoader加载解密后的原dex文件 在onCreate方法中，主要做两个工作： 通过反射修改ActivityThread类，并将Application指向原dex文件中的Application ActivityThread类是Android APP进程的初始类，ActivityThread的main方法是一个APP的真正入口。 main函数里，在attach方法中会完成Application对象的初始化，然后调用Application的onCreate()方法 该类有个关键属性currentActivityThread，通过该属性能够获取到一系列其他关键的属性，例如mPackages，通过该属性，我们可以获取到mClassLoader属性，通过替换该属性我们可以替换系统加载器 创建原Application对象，并调用原Application的onCreate方法启动原程序 加固技术 一代（动态加载）： DEX 字节码文件整体加密 使用自定义 DexClassLoader 加载 DEX 文件 保护粒度是 DEX 整体文件 ; 第一代壳的特征 : 在内存中 , DEX 文件是整体的连续的内存块 , 如果找到了 DEX 文件的起始地址 , 可以很容易将整个 DEX 文件 dump 下来 ; DEX 脱壳加载方案 : 文件加载 : 通过监控文件访问记录 , 也可以找到 DEX 文件 ;内存加载 : 内存中的 DEX 文件是完整的 , 也可以从内存中加载 DEX 文件 ; 第一代加固技术的缺陷是依赖Java的动态加载机制，而这个机制要求关键逻辑（Payload）部分必须解压，并且释放到文件系统，这就给了攻击机会去获取对应的文件。虽然可以通过关键逻辑（Payload）被加载后，被从文件系统删除，用于防止被复制，但是攻击者可以拦截对应的删除函数，阻止删除。 而关键逻辑（Payload）会被加密后保存，可用于对抗静态分析，但是攻击者可以通过自定义虚拟机，拦截动态加载机制所使用的关键函数，在这个函数内部，复制文件系统中的关键逻辑（Payload）文件。 二代（不落地加载）：大体原理和第一代壳相同，和第一代壳不同的是，第一代壳将dex文件解密出来会保存到文件中，在通过DexClassLoader加载进内存中，而不落地加载直接重写DexClassLoader使其可以直接加载字节数组，避免写入文件中 一般两种方案实现： 拦截系统IO相关的函数（如read、write），在这些函数中提供透明加解密 直接调用虚拟机提供的函数进行不落地的加载 但兼容性很难解决，方案A透明加密方案由于其需要拦截系统的IO函数，这部分会使用inline hook或者got hook等技术，会带来一定的兼容性问题；方案B的不落地加载方案由于其需要调用系统内部的接口，而这个接口并不导出，各个厂商在实现时又有各自的自定义修改，导致该方案存在兼容性问题。 第二代加固技术在应用启动时要处理大量的加解密加载操作，会造成应用长时间假死（黑屏），用户体验差。 在加固技术实现上没有本质区别，虽然能防止第一代加固技术文件必须落地被复制的缺陷，但是也可以从以下方面进行对抗：例如内存中的DEX文件头会被清除，用于防止在dump文件中被找到；DEX文件结构被破坏，例如增加了一些错误的数据，提高恢复的成本。 但是Payload被加载之后，在内存中是连续的，利用gdb等调试工具dump内存后可以直接找到Payload，进行简单的处理之后可以恢复出100%的Payload文件。 和第一代加固技术的对抗方法一样，不落地加载也无法对抗自定义虚拟机。只需对上述的关键函数进行拦截然后将对应的内存段写出去，即可恢复Payload。注意，由于IO相关的函数被拦截，所以无法直接调用read&#x2F;write等函数进行直接的读写，需要使用syscall函数进行绕过。 虽然厂商会自己实现可能上述函数，从而绕过上述函数的拦截。但是Android的类加载器必须能找到对于的结构体才能正常执行，攻击者可以以类加载器做为起点，找到对应的Payload在内存中的位置。 三代（指令抽取）： 由于第二代加固技术仅仅对文件级别进行加密，其带来的问题是内存中的Payload是连续的，可以被攻击者轻易获取。第三代加固技术对这部分进行了改进，将保护级别降到了函数级别。 发布阶段将原始DEX内的函数内容（Code Item）清除，单独移除到一个文件中。运行阶段将函数内容重新恢复到对应的函数体。恢复的时间点有几个方式： 加载之后恢复函数内容到DEX壳所在的内存区域 加载之后将函数内容恢复到虚拟机内部的结构体上：虚拟机读取DEX文件后内部对每一个函数有一个结构体，这个结构体上有一个指针指向函数内容（CodeItem），可以通过修改这个指针修改对应的函数内容 拦截虚拟机内与查找执行代码相关的函数，返回函数内容。 依旧使用了java虚拟机进行函数内容的执行。攻击者可以通过自定义Android虚拟机，在解释器的代码上做记录一个函数的内容（CodeItem）。接下来遍历触发所有函数，从而获取到全部的函数内容。最终重新组装成一个完整的DEX文件。 四代（指令转换&#x2F;VMP）：第三代加固技术在函数级别的保护，使用Android虚拟机内的解释器执行代码，带来可能被记录的缺陷，第四代加固技术使用自己的解释器来避免第三代的缺陷。而自定义的解释器无法对Android系统内的其他函数进行直接调用，必须使用JAVA的JNI接口进行调用。 主要实现有两种： DEX文件内的函数被标记为native，内容被抽离并转换成一个符合JNI要求的动态库。 动态库内通过JNI和Android系统进行交互。 DEX文件内的函数被标记为native，内容被抽离并转换成自定义的指令格式，该格式使用自定义接收器执行，和A一样需要使用JNI和Android系统进行调用。 不论使用指令转换&#x2F;VMP加固的A方案或者B方案，其必须通过虚拟机提供的JNI接口与虚拟机进行交互，攻击者可以直接将指令转换&#x2F;VMP加固方案当作黑盒，通过自定义的JNI接口对象，对黑盒内部进行探测、记录和分析，进而得到完整DEX程序。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"暴力递归算法的一些尝试","slug":"Study/算法/暴力递归","date":"2023-03-14T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/14/Study/算法/暴力递归/","link":"","permalink":"https://beichen.link/2023/03/14/Study/%E7%AE%97%E6%B3%95/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92/","excerpt":"","text":"打印 n 层汉诺塔从最左边移动到最右边的全过程 六个函数相互嵌套递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 基础但是复杂的写法public static void hanoi1(int n)&#123; leftToRight(n);&#125;// 1-N层圆盘 从左移到右public static void leftToRight (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from left to right&quot;); return; &#125; leftToMid (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from left to right&quot;); midToRight(n-1); &#125;// 1-N层圆盘 从左移到中public static void leftToMid (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from left to mid&quot;); return; &#125; leftToRight (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from left to mid&quot;); righToMid(n-1); &#125;// 1-N层圆盘 从右移到中public static void rightToMid (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from right to mid&quot;); return; &#125; rightToLeft (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from right to mid&quot;); leftToMid(n-1); &#125;// 1-N层圆盘 从右移到左public static void rightToLeft (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from right to left&quot;); return; &#125; rightToMid (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from right to left&quot;); midToLeft(n-1); &#125;// 1-N层圆盘 从中移到左public static void midToLeft (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from mid to left&quot;); return; &#125; midToRight (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from mid to left&quot;); rightToLeft(n-1); &#125;// 1-N层圆盘 从中移到右public static void midToRight (int n)&#123; if (n == 1)&#123; System.out.println(&quot;Move 1 from mid to right&quot;); return; &#125; midToLeft (n-1); System.out.println(&quot;Move &quot;+ n + &quot; from mid to right&quot;); leftToright(n-1); &#125;// 简化之后的写法public static void hanoi2(int n)&#123; if ( n &gt; 0) &#123; func(n, &quot;left&quot;,&quot;right&quot;,&quot;mid&quot;) &#125;&#125;public static void func(int N, String from, String to, String other)&#123; if (N == 1)&#123; System.out.println(&quot;Move 1 from &quot;+ from + &quot;to &quot; + to); &#125;else &#123; func(N-1,from,other,to); System.out.println(&quot;Move N from &quot;+ from + &quot;to &quot; + to); func(N-1, other,to,from); &#125;&#125; 递归逆序栈f 函数实现功能： 123456789101112131415161718192021222324252627public static void reverse (Stack&lt;Integer&gt; stack)&#123; if (stack.isEmpty())&#123; return; &#125; int i = f(stack); reverse (stack); stack.push(i);&#125;public static int f (Stack&lt;Integer&gt; stack)&#123; int result = stack.pop(); if (stack.isEmpty())&#123; return result; &#125; else &#123; int last = f(stack); stack.push(result); return last; &#125;&#125;public static main (String[] args)&#123; Stack&lt;Integer&gt; test = new Stack&lt;Integer&gt;(); test.push(1); test.push(2); test.push(3); reverse(tset);&#125; 字符串的所有子序列123456789101112131415161718public static List&lt;String&gt; subs (String s)&#123; char[] str = s.toCharArray(); String path = &quot;&quot;; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); process1(str,0,ans,path); return ans;&#125;public static void process1(char[] str, int index, List&lt;String&gt; ans, String path)&#123; if (index == str.length)&#123; ans.add(path); return; &#125; String no = path; process1(str,index+1,ans,no); String yes = path + String.valueOf(str[index]); process1(str,index+1,ans,yes);&#125; 如果想打印字符串的所有不重复子序列，就用hashset，自动去重 字符串的所有排列1234567891011121314// str[0..i-1]是已经做好决定的// str[i..]有机会来到 i 位置// i 终止位置， str 当前的位置，就是一种结果，anspublic static void process (char[] str, int i, ArrayList &lt;String ans&gt;)&#123; if (i == str.length)&#123; ans.add(String.valueOf(str)); &#125; // 如果 i 没有终止， i.. 都可以来到 i 位置 for (int j = i; j &lt; str.length; j++)&#123; swap(str, i, j); process(str, i+1, ans); swap(str, i ,j); &#125;&#125; 如果想要字符串的全部不重复排列，当然可用hashset，但是也能用下面的方法 12345678910111213141516public static void process2(char[] str, int i, ArrayList&lt;String&gt; res)&#123; if (i == str.length)&#123; res.add(String.valueOf(str)); return; &#125; boolean[] visit = new boolean[26]; for (int j = i; j &lt; str.length; j++)&#123; if ( !visit[ str[j] - &#x27;a&#x27;] )&#123; visit[str[j]-&#x27;a&#x27;] = true; swap[str, i, j]; process2(str, i+1,res); swap(str,i,j); &#125; &#125;&#125; 从左往右的尝试模型 1 1234567891011121314151617181920212223242526272829303132333435public static int number (String str)&#123; if (str == null || str.length() == 0)&#123; return 0; &#125; return process(str.toCharArray(),0);&#125;public static int process(char[] str, int i)&#123; if (i == str.length)&#123; return 1; &#125; // &#x27;0&#x27; 是 无效转换 if (str[i] == &#x27;0&#x27;)&#123; return 0; &#125; // &#x27;1&#x27;可能是一位，也可能带着后面一位 if (str[i] == &#x27;1&#x27;)&#123; int res = process(str,i+1); if (i + 1 &lt; str.length)&#123; res += process(str, i+2); &#125; return res; &#125; // &#x27;2&#x27;可能是一位，也可能带着后面一位，但后面一位不能大于6 if (str[i] == &#x27;2&#x27;)&#123; int res = process(str, i+1); if (i + 1 &lt; str.lenth &amp;&amp; (str[i+1] &gt;= &#x27;0&#x27; &amp;&amp; str[i+1] &lt;= &#x27;6&#x27;))&#123; res += process(str, i+2); &#125; return res; &#125; // &#x27;3&#x27; -- &#x27;9&#x27; 就只看一位 return process(str,i+1); &#125; 从左往右的尝试模型 2 123456789101112131415161718// 0 ...index-1 上做了货物的选择，使得已经达到的重量是 already// 如果返回 -1， 认为没有方案// 如果不返回 -1， 认为返回的值是真实价值public static int process(int[] w, int[] v, int index, int alreadyW, int bag)&#123; if (alreadyW &gt; bag)&#123; return -1; &#125; if (index == w.length)&#123; return 0; &#125; int p1 = process(w, v, index+1, alreadyW, bag); //是从index+1开始的后面的最大价值 int p2next = process(w, v, index+1，alreadyW + w[index], bag); int p2 = -1; if (p2next != -1)&#123; p2 = v[index] + p2next; &#125; return Math.max(p1,p2);&#125; 范围上尝试的模型 12345678910111213141516171819202122public static int win1(int[] arr)&#123; if (arr == null || arr.length == 0)&#123; return 0; &#125; return Math.max(f(arr,0,arr.length -1), s(arr, 0, arr.length -1) );&#125;// 先手函数public static int f (int[] arr, int L, int R)&#123; if (L== R)&#123; return arr[L]; &#125; return Math.max(arr[L] + s(arr, L+1,R), arr[R]+s(arr, L,R-1));&#125;//后手函数public static int s (int[] arr, int L, int R)&#123; if (L== R)&#123; return 0; &#125; return Math.min(f(arr, L+1,R),f(arr,L,R-1) );&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Xposed 原理","slug":"Study/逆向知识/Xposed原理","date":"2023-03-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/03/10/Study/逆向知识/Xposed原理/","link":"","permalink":"https://beichen.link/2023/03/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/Xposed%E5%8E%9F%E7%90%86/","excerpt":"","text":"Xposed 组成 名称 介绍 Xposed Xposed框架Native部分 XposedBridge Xposed向开发者提供的API与相应工具类库 XposedInstaller Xposed框架Android端本地管理，环境框架，以及第三方module资源下载的工具 原理工作流程 xposed的主要接口在XposedBrigde.jar中，核心功能在替换的虚拟机中实现。 app_process是Android App的启动程序（具体形式是zygote fork() 调用app_process作为Android app的载体） Zygote在Android系统中App进程都是由Zygote进程“孵化”出来的。Zygote进程在启动时会创建一个虚拟机实例，每当它“孵化”一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的App进程里面去，从而使每个App进程都有一个独立的Dalvik虚拟机实例。 Zygote进程在启动的过程中，除了会创建一个虚拟机实例之外还会将 Java Rumtime 加载到进程中并注册一些Android核心类的JNI（Java Native Interface，Java本地接口）方法。 一个App进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的虚拟机实例拷贝，还会与Zygote进程一起共享 Java Rumtime ，也就是可以将 XposedBridge.jar 这个Jar包加载到每一个Android App进程中去。 安装 Xposed Installer 之后，系统 app_process 将被替换，然后利用Java的 Reflection 机制覆写内置方法，实现功能劫持。Xposed Installer 框架中真正起作用的是对方法的Hook和Replace。 Xposed框架核心思想在于将Java层普通函数注册成本地JNI方法，以此来变相实现hook机制 在Android系统启动的时候，Zygote进程加载 XposedBridge.jar，将所有需要替换的Method通过 JNI 方法hookMethodNative 指向Native方法 xposedCallHandler，这个方法再通过调用 handleHookedMethod 这个Java方法来调用被劫持的方法转入Hook逻辑。 上面提到的 hookMethodNative 是 XposedBridge.jar 中的私有的本地方法，它将一个方法对象作为传入参数并修改Dalvik虚拟机中对于该方法的定义，把该方法的类型改变为Native并将其实现指向另外一个B方法。 换言之，当调用那个被Hook的A方法时，其实调用的是B方法，调用者是不知道的。在hookMethodNative的实现中，会调用 XposedBridge.jar 中的 handleHookedMethod 这个方法来传递参数。handleHookedMethod 这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是 xposedCallHandler。 而 handleHookedMethod 实现里面会根据一个全局结构 hookedMethodCallbacks 来选择相应的Hook函数并调用他们的 before 和 after 函数，当多模块同时Hook一个方法的时候 Xposed 会自动根据 Module 的优先级来排序。 调用顺序如下：A.before -&gt; B.before -&gt; original method -&gt; B.after -&gt; A.after。 检测在做Android App的安全防御中检测点众多， Xposed Installer 检测是必不可少的一环。对于Xposed框架的防御总体上分为两层：Java层和Native层。 Java 层需要说明的是，Java层的检测基本只能检测出基础的 Xposed Installer框架，而不能防护其对App内方法的Hook，如果框架中带有反检测，则Java层检测大多不起作用。 通过PackageManager查看安装列表 最简单的检测，我们调用Android提供的PackageManager的API来遍历系统中App的安装情况来辨别是否有安装Xposed Installer相关的软件包。 123456PackageManager packageManager = context.getPackageManager();List applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);for (ApplicationInfo applicationInfo: applicationInfoList) &#123; if (applicationInfo.packageName.equals(&quot;de.robv.android.xposed.installer&quot;)) &#123; // is Xposed TODO... &#125; &#125; 通常情况下使用Xposed Installer框架都会屏蔽对其的检测，即Hook掉PackageManager的getInstalledApplications方法的返回值，以便过滤掉de.robv.android.xposed.installer来躲避这种检测。 自造异常读取栈 Xposed Installer框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现Xposed相关的“身影”，我们可以通过自造异常Catch来读取异常堆栈的形式，用以检查其中是否存在Xposed的调用方法。 1234567try &#123; throw new Exception(&quot;blah&quot;);&#125; catch(Exception e) &#123; for (StackTraceElement stackTraceElement: e.getStackTrace()) &#123; // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存在Xposed &#125;&#125; 异常堆栈显示： 12345678910111213E/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference...at com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)at com.meituan.test.MiFGService$1.run(MiFGService.java:41)at android.os.Looper.loop(Looper.java:136)at android.app.ActivityThread.main(ActivityThread.java:5072)at java.lang.reflect.Method.invokeNative(Native Method)at java.lang.reflect.Method.invoke(Method.java:515)...at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)at de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块at dalvik.system.NativeStart.main(Native Method) 检查关键Java方法被变为Native JNI方法 当一个Android App中的Java方法被莫名其妙地变成了Native JNI方法，则非常有可能被Xposed Hook了。由此可得，检查关键方法是不是变成Native JNI方法，也可以检测是否被Hook。 通过反射调用Modifier.isNative(method.getModifiers())方法可以校验方法是不是Native JNI方法，Xposed同样可以篡改isNative这个方法的返回值。 反射读取XposedHelper类字段 通过反射遍历XposedHelper类中的fieldCache、methodCache、constructorCache变量，读取HashMap缓存字段，如字段项的key中包含App中唯一或敏感方法等，即可认为有Xposed注入。 12345678910111213141516171819202122boolean methodCache = CheckHook(clsXposedHelper, &quot;methodCache&quot;, keyWord);private static boolean CheckHook(Object cls, String filedName, String str) &#123; boolean result = false; String interName; Set keySet; try &#123; Field filed = cls.getClass().getDeclaredField(filedName); filed.setAccessible(true); keySet = filed.get(cls)).keySet(); if (!keySet.isEmpty()) &#123; for (Object aKeySet: keySet) &#123; interName = aKeySet.toString().toLowerCase(); if (interName.contains(&quot;meituan&quot;) || interName.contains(&quot;dianping&quot;) ) &#123; result = true; break; &#125; &#125; &#125; ... return result;&#125; Native 层由上文可知，无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。 每个App在系统中都有对应的加载库列表，这些加载库列表在&#x2F;proc&#x2F;下对应的self&#x2F;maps文件中描述，在Native层读取&#x2F;proc&#x2F;self&#x2F;maps文件不失为检测Xposed Installer的有效办法之一。 由于Xposed Installer通常只能Hook Java层，因此在Native层使用C来解析&#x2F;proc&#x2F;self&#x2F;maps文件，搜检App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和So库等文件。 123456789101112131415161718192021bool is_xposed()&#123; bool rel = false; FILE *fp = NULL; char* filepath = &quot;/proc/self/maps&quot;; ... string xp_name = &quot;XposedBridge.jar&quot;; fp = fopen(filepath,&quot;r&quot;)) while (!feof(fp)) &#123; fgets(strLine,BUFFER_SIZE,fp); origin_str = strLine; str = trim(origin_str); if (contain(str,xp_name)) &#123; rel = true; //检测到Xposed模块 break; &#125; &#125; ...&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"Frida 原理初识","slug":"Study/逆向知识/frida原理学习","date":"2023-03-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/03/10/Study/逆向知识/frida原理学习/","link":"","permalink":"https://beichen.link/2023/03/10/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/frida%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"frida的代码结构使用Frida可以进行注入（Inject）、拦截（Intercept）、代码跟踪（Stalk）。 frida-core: Frida 核心库 frida-gum: inline-hook 框架 bindings: frida-python: python frida-node: Node.js frida-qml: Qml frida-swift: Swift frida-tools: CLI tools capstone: instruction disammbler frida-corefrida-core的功能有进程注入、进程间通信、会话管理、脚本生命周期管理等功能，屏蔽部分底层的实现细节并给最终用户提供开箱即用的操作接口。 而这一切的实现都在 frida-core 之中，正如名字所言，这其中包含了 frida 相关的大部分关键模块和组件，比如 frida-server、frida-gadget、frida-agent、frida-helper、frida-inject 以及之间的互相通信底座。 1. frida 注入原理 ptracefrida 注入是基于 ptrace实现的。frida 调用ptrace向目标进程注入了一个frida-agent-xx.so文件。后续骚操作是这个so文件跟frida-server通讯实现的。ida调试也是基于 ptrace实现的。 ptrace系统调用从名字上看是用于进程跟踪的，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。 其基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。 frida注入的主要思路就是找到目标进程pid ,使用ptrace跟踪目标进程获取mmap，dlpoen，dlsym等函数的地址。然后远程调用mmap在目标进程申请一段内存空间用来保存信息，向mmap分配的空间写入 frida-agent-32&#x2F;64.so ，调用dlopen加载so库，启动执行各种操作由agent去实现(远程调用dlsym函数获取目标函数地址-&gt;使用ptrace_call远程调用被注入模块的函数 ) frida-agent 注入到目标进程并启动后会启动一个新进程与 host 进行通信，从而 host 可以给目标进行发送命令，比如执行代码，激活&#x2F;关闭 hook，同时也能接收到目标进程的执行返回以及异步事件信息等。 frida注入之后会在远端进程分配一段内存将agent拷贝过去，并在目标进程中执行代码，执行完成后会 detach 目标进程，这也是为什么在 frida 先连接上目标进程后还可以用gdb&#x2F;ida等调试器连接，而先gdb连接进程后 frida 就无法再次连上的原因(frida在注入时只会ptrace一下下，注入完毕后就会结束ptrace。所以ptrace占坑这种反调试使用spawn方式启动即可)。 attach模式 attach到已经存在的进程，核心原理是ptrace修改进程内存，如果进程处于调试状态（traceid不等于0），则attach失败 spawn模式 启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，如hook RegisterNative等，注入完成后调用resume恢复进程。 2. frida hook 原理frida 的 hook 区分了 art 模式和 dalvik 模式。 frida兼容了低版本的Android, 低于Android 5.0时，采用Dalvik虚拟机。frida的Dalvik hook和xposed的hook原理相同，都是把要hook的java函数变成native函数，并修改函数的入口为自定义的内容，这样在调用时就会执行自定义的代码。 下面主要讲的是art模式。 frida的ART hook实现也是把java method转为native method, 但ART的运行机制不同于Dalvik, 其实现也较为复杂，这里从ART运行机制开始解释。 ART 是一种代替 Dalivk 的新的运行时,它具有更高的执行效率。ART虚拟机执行 Java 方法主要有两种模式：quick code 模式和 Interpreter 模式。 quick code 模式：执行 arm 汇编指令 Interpreter 模式：由解释器解释执行 Dalvik 字节码 即使是在quick code模式中，也有类方法可能需要以Interpreter模式执行。反之亦然。解释执行的类方法通过函数artInterpreterToCompiledCodeBridge的返回值调用本地机器指令执行的类方法；本地机器指令执行的类方法通过函数GetQuickToInterpreterBridge的返回值调用解释执行的类方法； 不管是解释模式还是其他模式，只要目标方法有 native 代码，那么该方法的代码地址都是会保存在 entry_point_from_quick_compiled_code_ 字段，只不过这个字段的含义在不同的场景中略有不同。 所以我们若想要实现 ART Hook，理论上只要找到对应方法在内存中的 ArtMethod 地址，然后替换其 entrypoint 的值即可。 jniCode 替换为用户指定的 js 函数封装而成的 NativeFunction，并将 accessFlags 设置为 kAccNative，即 JNI 方法。quickCode 和 interpreterCode 分别是 Quick 模式和解释器模式的入口，替换为了上文中查找保存的 trampoline，令 Quick 模式跳转到 JNI 入口，解释器模式跳转到 Quick 代码，这样就实现了该方法的拦截，每次执行都会当做 JNI 函数执行到 jniCode 即我们替换的代码中。 所以 frida 要将 java method 转为 native method，需要将ARTMethod 结构进行修改。 12345678910patchMethod(methodId, &#123; //jnicode入口entry_point_from_jni_改为自定义的代码 &#x27;jniCode&#x27;: implementation, //修改为access_flags_为native &#x27;accessFlags&#x27;: (Memory.readU32(methodId.add(artMethodOffset.accessFlags)) | kAccNative | kAccFastNative) &gt;&gt;&gt; 0, //art_quick_generic_jni_trampoline函数的地址 &#x27;quickCode&#x27;: api.artQuickGenericJniTrampoline, //artInterpreterToCompiledCodeBridge函数地址 &#x27;interpreterCode&#x27;: api.artInterpreterToCompiledCodeBridge&#125;); frida-gumfrida-gum是基于inline-hook实现的，它还有很多丰富的功能，比如用于代码跟踪 Stalker、用于内存访问监控的MemoryAccessMonitor，以及符号查找、栈回溯实现、内存扫描、动态代码生成和重定位等。 1. InterceptorInterceptor 是 inline-hook 的封装。 hook的实现有很多种，inlinehook是Native层hook的一种方式。通过修改原函数开头的汇编指令，直接跳转到指定函数。 平时用来开发的高级语言必须转换成低级语言才能被CPU执行，根据是否有中间结果的区别，完成转换的可能是编译器或虚拟机。和百花齐放的高级语言不同，低级语言只有两种，汇编和机器码（即二进制码），汇编是机器码的文本化表示，两者是一对一的对应关系。 逻辑上讲，汇编是为了解决机器码可读性的产物，汇编在执行前需要先翻译成机器码，这个过程叫assembing，所以汇编语言叫ASM。 指令级别的hook跟高级语言层面的实现方式在感官上有很大区别，高级语言中不管借助什么手段，只需将hook代码织入到目标代码之中即可，但这种方式在指令级别是行不通的。 我们需要知道，操作系统将程序指令成段装载到内存里，我们手动把若干指令插入到某个位置就是改动了程序装载后的内存结构，这意味着程序需要重新做地址重定位才能正常运行，这本该由链接器完成的工作换成人工来计算几乎是不可能的，所以这肯定不是实现hook的正确方式。为了保持内存结构不变，正确的方法是使用指令替换而不是指令插入的方式来实现hook，见下图： 假设目标方法内有ins0, ins1, ins2三条指令，首先将起始指令替换为等长的跳转指令jump_ins，jump_ins负责跳转到hook方法执行。 而hook操作后，往往还需要保留调用原方法的能力以保证功能可用性，所以hook方法内还有一个跳转指令来调回原方法继续执行（jump ins1）。 调回前需要先补充执行目标方法已被替换的原始指令（图中ins0），保证原方法完整性。 综上，inline hook需要完成的工作就是图中绿色的部分，即跳转指令的替换、补充执行原指令、跳回原方法继续执行这三步。 2. Stalker潜行者又称为尾行痴汉，可以实现指定线程中所有函数、所有基本块、甚至所有指令的跟踪。一般想使用指令跟踪都是使用内存断点或者unidbg模拟执行so。 Stalker的功能实现，在线程即将执行下一条指令前，先将目标指令拷贝一份到新建的内存中，然后在新的内存中对代码进行插桩 3. MemoryAccessMonitorMemoryAccessMonitor可以实现对指定内存区间的访问监控，在目标内存区间发生读写行为时可以触发用户指定的回调函数。 通过阅读源码发现这个功能的实现方法非常简洁，本质上是将目标内存页设置为不可读写，这样在发生读写行为时会触发事先注册好的中断处理函数。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"大厂设备指纹获取和对抗","slug":"Study/逆向知识/设备指纹获取与绕过","date":"2023-03-03T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/03/03/Study/逆向知识/设备指纹获取与绕过/","link":"","permalink":"https://beichen.link/2023/03/03/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9%E8%8E%B7%E5%8F%96%E4%B8%8E%E7%BB%95%E8%BF%87/","excerpt":"","text":"现在大厂的设备指纹层出不穷，但是想要确保稳定性和唯一性高精准其实也挺难的一件事，有的是通过设备信息比重进行的设备 ID 唯一值确认。比如 A 设备信息占比 10%，B 设备信息占比 20%，当比重超过 60%以上，设备指纹才会发生变化。这样的好处就是当你只修改某一个字段的时候，设备指纹不发生变化。还有的干脆找一个隐蔽的并且唯一的设备信息，作为缓存，每次读取缓存的方式去判断，设备信息是唯一。 比如常见的有 Native 获取 DRM，popen cat &#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number ，svc 读取 bootid 并且保存到文件，netlinker 获取网卡。都是很常见并且隐蔽的的设备指纹。这篇文章主要介绍了各种指纹的获取情况，如何修改，站在上帝视角去俯看，攻击者和被攻击者遇到的问题 。 前置知识Android IPC 代理是什么？Android 本身是 CS 架构，客户端（client）服务端（server），我们常用的通过 context 上下文调用的 API 都是直接调用代理人的方式去调用的，而真正的服务端是 ActivityManagerServer 简称，AMS 他有很多代理，比如 PackageManager，ActivityManager 等，这些都是 AMS 的代理人。而 AMS 就是被代理人。 代理模式是一种设计模式，代理人可以提供被代理人的部分或者全部功能，实现代码封装，做鉴权，代码安全的角度，代理模式很常用的设计模式。 AMS 和代理们通过 Binder 进行通讯，Binder 是什么，有什么好处这里就不详细展开了，安卓面试八股文，可以理解成进程间通讯的东西，底层实现是通过共享内存，数据传输，读取速度更快。 当我们调用代理人的 API 的时候，本质上是通过 Binder 去发送一些数据包，和 AMS 通讯，当 AMS 收到消息以后把结果在传输给对应的代理人。然后返回给调用方。在每个 Manager 里面都有一个代理人 。 之前很久之前有一种动态代理的技术，原理就是替换了里面的代理人，因为代理是一个接口，然后我们自己通过 Proxy 这个类创建一个代理，然后反射 set 回去，就可以实现常用的 API 拦截和 Hook。 类似 VA 的沙盒，对多开的 App 提供一份自己实现的代理，然后控制这些代理的返回值，以此实现沙盒相关操作。 还有一种比较好的过 APK 签名的方法就是直接 Hook”水管” 也就是 hook binder 的通讯的方法，当接收到指定事件以后，直接修改具体的结果，以此对 Java 层进行全量 Hook。binder 的通讯方法被 Hook 以后，调用者和代理人只能拿到被修改以后的结果，以此实现 Java 层的全量 Hook， 设备指纹设备指纹面临的主要挑战 第一，设备重置之后，保持设备指纹不变。 第二，设备更新之后（包括硬件），保持设备指纹不变。 第三，保证设备指纹的唯一性，避免两个不同的设备产生相同的设备指纹 设备指纹主要分为三部分，Java 层设备指纹，Native 设备指纹，popen 执行一些命令获取设备信息，包括一些核心的设备指纹。 这篇文章也主要围绕这三部分进行展开讨论。比如一些内核文件等信息，我也会放在 Native 层进行讨论。 所有的每个设备指纹我都分为两部分 Get（如何获取，站在开发者角度） Mock (如何进行修改测试，站在攻击者角度) Java 层设备指纹 Setting 相关（重要）： Get： 在 setting 里面大家经常遇到的可能就是 android id 的获取 API 如下: 1Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID) Mock: 方法 Hook 底层调用的是 getStringForUser(resolver, name, resolver.getUserId()) 三个参数，如果 Hook 的话可以对这个方法进行入手。 内存反射 很多开发者会采用内存反射的方式去获取变量，所以仅仅是通过 hook 方法的方式不够 Android 高版本绕过了反射限制以后，或者判断当前手机没有 API 反射限制以后直接通过反射变量的方式去获取。 蓝牙网卡 MAC（普通） 蓝牙的网卡不是普通的网卡，后面会介绍 netlinker 获取真实的网卡。 Get： 主要方法就是通过 BluetoothAdapter-&gt;getAddress 12345678public String getAddress() &#123; try&#123; return mManagerService.getAddress(mAttributionSource); &#125; catch(RemoteException e) &#123; Log.e(TAG, ``&quot;&quot;``, e); &#125; return null;&#125; Mock: 可以看到这个方法主要是通过 IPC 的代理类方式去获取的。所以 Hook 的话尽可能先 Hook 代理的 IPC 类。先尝试反射 android.bluetooth.IBluetooth$Stub$Proxy，然后 Hook IPC 里面的 getAddress，而不是直接 HookBluetoothAdapter-&gt;getAddress 因为很多大厂获取设备的指纹的时候会检测这个方法是否被 Hook，检测也很简单，只需要获取这个 art method 结构体以后判断这个方法入口是否被替换。 比如 Sandhook 之类的常用的 Hook 框架，低版本采用的是 inlinehook 形式，在高版本里面采用的是入口替换，可以直接获取到方法的入口的函数地址，判断一下函数所在的 so 即可。 所以尽可能 HookIPC 的方法。如果用 XPosed 去修改的话，还需要注意魔改，否则大厂会通过 XposedHelpers-&gt;sHookedMethodCallbacks 变量把你 Hook 的方法进行上报。 serial（普通） 这个变量在高版本里面基本已经拿不到，及时拿到了也是一个 unknow，但是也需要兼容低版本的 Android 。 IMEI , IMSI ,ICCID,Line1Number (普通) 这些基础的 Java 设备指纹字段没啥好说的，百度一下就能找到具体的获取方法，但是修改的时候需要注意，不要直接 Hook，尝试优先 Hook ipc 即可 。 Build 相关（次要）： Build 里面还是有很多有用的东西，比如手机是否开启 adb ,usb 接口的状态之类的。 我们主要将 Build 里面分为两部分 ：配置相关和指纹相关。 指纹相关又分为两部分，单一字段 &#x2F;复合字段。 配置相关 指纹相关 单一字段（只有一个设备信息） 复合字段（多个单一字段复合而成） 这个单独通过 Java 层去修改是完全不够的，底层走的是 system_property_get 这个方法。还要防止 popen getprop 这种方法去扫描全部的 Build 相关参数。 系统默认账号（普通）： 很多大厂会把这个字段也作为指纹的一部分，所以这个方法也需要处理。 Get: 1AccountManager-&gt;getAccounts Mock: 优先 Hook ipc 传感器相关（普通）： 虚拟机和真实设备的最大区别就在于，虚拟机不存在真实的硬件设备支持。因此虚拟机在很多功能上会存在缺失。 比如：各类传感器要么缺失，要么采集的数值都是 0 或者某个固定值；相机功能异常，无法拍照等。这些都是常见的虚拟机硬件缺失的特征。 同时，可以使用硬件动态特征检测。它的基本原理是基于硬件的一些动态执行层产生的特征（如：加速度传感器的偏差）来识别虚拟设备。 举个例子，因为加速度传感器校准结果的不精确性，其产生的最终结果会存在一定的偏差。通过多次快速地查询加速度传感器，我们就可以模拟出同一时刻，加速度传感器返回的结果值。又因为存在机械偏差，所以这些结果值是不同的，那通过这些值，我们就可以计算出该传感器的线性偏差。 这个函数不需要太多处理，每个手机类型基本都差不多，每次打乱一下返回结果排序顺序即可。 Get: 1SensorManager-&gt;getFullSensorList Mock: 优先 Hook ipc Java 层 DRM 相关（重要字段）： 这个 DRM 是水印相关，主要为了处理不同手机加水印的唯一 ID 核心的是一个叫 deviceUniqueId 的东西，这玩意是一个随机的 32 位字节数组。很多大厂用这个作为核心的设备指纹，不仅在 Java 层进行获取，还有在 Native 层进行获取，在后面 Native 设备指纹会再次介绍到。 Get: 1MediaDrm-&gt;getPropertyByteArray``MediaDrm-&gt;getPropertyString Hook 的话很简单，这个方法没有 IPC 底层，有自己的实现，直接 Hook get 的方法即可 。java 层 Hook 是远远不够的，还需要处理 native 层。每次随机 32 位字节数组即可。 Java 层网卡信息（普通）： 大厂应该不会信任 Java 层的 mac，底层都是通过 netlinker 直接获取网卡，或者直接 popen 执行 ip a 进行网卡信息的全量获取。直接在底层处理 netlinker，所以 Java 层不进行处理。任何获取网卡的方法，底层最终走的都是 netlinker 去获取的网卡 直接通过 netlinker 获取网卡，这种方式在安卓 10 上面貌似已经失效了，但是手机 Root 以后是没有限制的（亲测 android 13 开发板获取成功），这种方式还可以用来检测当前手机是否 Root。 但是当执行 ip a 这种命令的时候，或者调用 Java 层原始 API 的时候，底层还是走的 netlinker，直接在底层通过 ptrace 在函数调用执行完毕以后，对寄存器进行 Mock 和 Set 即可 文件创建时间（次要）： 很多大厂会收集&#x2F;sdcard&#x2F; 或者相册目录的一些创建时间，作为设备指纹，但是很多文件都是默认的 1970 时间戳，有的少数文件夹创建时间也是很重要的设备标识 。Java 里面 File 对象有文件的创建时间。 Native 层设备指纹聊了挺多 Java 相关的设备指纹，其实 Java 层采集的指纹，并不是关键因素，核心的指纹基本都在 native 层进行处理的。Native 部分会详细介绍包括内核文件，还有一些获取指纹的骚操作 。 Build(system_property_get &amp; system_property_read)(重要) 之前在 Java 层介绍了，Java 获取最终总的是 native_get，而 native_get 底层走的就是这个 system_property_get 。 为什么不直接在__system_property_find 函数处理？ 因为 get 和 read 底层走的都是 find 函数，为什么不直接在 find 函数处理呢，find 函数返回的是 prop_info* 这个指针指向的是系统内存的变量，如果直接对内存变量强制写入可能会导致系统的不稳定，导致出现问题。之前踩过这个坑。所以就只处理了 get 和 find 这两个函数 。 Native 获取 DRM ID（重要） 这个指纹也是很多大厂用作唯一 ID 的核心指纹。处理的话也需要注意，很核心的一个设备指纹 ID。 Netlinker 获取网卡信息 因为之前说过，Linux 底层不管什么样的获取网卡，最终底层直接会走 Netlinker 去获取网卡。 在 android 10 以下可以绕过系统权限从而获取网卡信息，高版本已经失效了 。 底层都是 svc 直接调用 recvfrom 或者 recvmsg 去接受 socket 的消息 。所以不处理 svc 的话，无法做到全量修改的。我用的是 ptrace 在 recvfrom 执行完毕以后，读取参数寄存器，将数据修改以后在重新覆盖寄存器即可 内核文件相关（重要）： 内核文件指的是系统的相关文件，很多大厂会直接通过 popen cat 或者直接 fopen 只读的方式去读取文件内容。核心的也就那几个。 一般读取的时候都是直接 svc openat 底层。 需要用到 svc 的 IO 重定向，如果这块不处理的话，基本没办法进行 mock 和修改。 APK 签名：目前主要的获取签名就两种办法，比较常用，一般大厂和加固都在使用。这里顺手写一下原理 。 Java 层直接 通过 binder 和 AMS 通讯获真实签名信息。这种方法的好处我就不多说了，直接和 AMS 通讯，获取最真实的签名信息。这么一来你不管你 Hook pms 里面的哪些方法也没啥用。 hook 获取签名的方法，用这种方式都可以直接绕过。那有没有什么办法可以绕过这种检测呢？ 绕过原理：因为和 AMS 通讯需要用到 Binder，Binder 可以理解成“水管” ，他虽然和 AMS 直接进行通讯，但是还是要经过我们的水管，我们直接对这个水管处理即可 。在通讯时候对水管进行拦截。在 BinderProxy -&gt; transact 的方法里面进行拦截和替换签名信息即可 。 Native 层 svc 读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析 zip 解析里面的签名文件信息。Java 层是通过 AMS 通讯获取签名信息，Native 层我们直接用 svc openat 读取 apk 文件 ， 进行手动解析 apk 的签名 。不信任系统 Api 的解析结果。这个也是常用的检测签名办法。这样拿到的结果就是可信的结果。 绕过原理：svc openat 的 IO 重定向，当他读取原始&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 的时候我们将它修改成原始 apk 的路径。 这么一来他读取到的是原始 apk 路径，而不是被修改的路径，得到的签名也就是原始的签名。底层在处理一下 svc readlink readlintat 防止检测路径被替换。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"指针","slug":"Study/算法/快慢指针","date":"2023-03-02T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/02/Study/算法/快慢指针/","link":"","permalink":"https://beichen.link/2023/03/02/Study/%E7%AE%97%E6%B3%95/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/","excerpt":"","text":"链表的快慢指针一、链表的中间结点 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 123456789public ListNode middleNode(ListNode head)&#123; ListNode low = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null)&#123; fast = fast.next.next; low = low.next; &#125; neturn low;&#125; 二、回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 12345678910111213141516171819202122232425262728293031323334353637public boolean isPalindrome(ListNode head)&#123; ListNode mid = middleNode(head); ListNode rev = reverseList(mid); while (rev != null)&#123; if (head.value != rev.value)&#123; return false; &#125; head = head.next; rev = rev.next; &#125; return true;&#125;public ListNode middleNode(ListNode head)&#123; ListNode low = head; ListNode fast = head; while (fast.next != null &amp;&amp; fast != null)&#123; fast = fast.next.next; low = low.next; &#125; return low;&#125;public ListNode reverseList(ListNode head)&#123; if (head == null || head.next == null)&#123; return head; &#125; ListNode current = head; ListNode pre = null; while (current != null)&#123; ListNode next = current.next; current.next = pre; pre = current; current = next; &#125; return pre;&#125; 也可以考虑用栈。 1234567891011121314public static boolean isPalindrome (Node head)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node cur = head; while (cur != null )&#123; stack.push(cur); cur = cur.next; &#125; while (head != null)&#123; if (head.value != stack.pop().value)&#123; return false; &#125; head = head.next; &#125;&#125; 三、链表中倒数第K个结点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 12345678910111213public ListNode getKthFromEnd (ListNode head,int k)&#123; ListNode pre = head; ListNode sec = head; int i = 0; while ( pre != null)&#123; if (i &gt;= k)&#123; sec = sec.next; &#125; pre = pre.next; i++； &#125; return sec;&#125; 四、删除链表的倒数第n个结点 给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 12345678910111213141516171819202122public ListNode removeNthFromEnd (ListNode head , int n)&#123; ListNode pre = new ListNode (-1); ListNode cur = new ListNode(-1); ListNode x = new ListNode(-1); x.next = head; pre.next = head; cur.next = head; int i = 0; while (pre != null)&#123; if (i &gt;= n+1)&#123; cur = cur.next; &#125; pre = pre.next; i++; &#125; if (cur.next == head)&#123; x.next = cur.next.next; &#125;else&#123; cur.next = cur.next.next; &#125; return x.next;&#125; 五、环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 123456789101112131415public boolean hasCycle(ListNode head)&#123; if (head == null || head.next == null)&#123; return false; &#125; ListNode node = head; ListNode pre = head; while (pre != null || pre.next != null)&#123; node = node.next; pre = pre.next.next; if (pre == node)&#123; return true; &#125; &#125; return false;&#125; 继续： 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 123456789101112131415161718192021222324public ListNode detectCycle (ListNode head)&#123; if (head == null || head.next == null)&#123; return null; &#125; ListNode low = head; ListNode fast = head; ListNode third = head; while (fast.next != null || fast != null)&#123; fast = fast.next.next; low = low.next; if (low == fast)&#123; break; &#125; &#125; if (fast == null || fast.next == null)&#123; return null; &#125; while (third != low )&#123; third = third.next; low = low.next; &#125; return third; &#125; 额外数据结构记录(哈希表等) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static NodePartition2 (Node head, int pivot)&#123; Node sH = null; // small head Node sT = null; // small tail Node eH = null; // equal head Node eT = null; // equal tail Node bH = null; // big head Node bT = null; // big tail Node next = null; while (head != null)&#123; next = head.next; head.next = null; if (head.value &lt; pivot )&#123; if (sH == null)&#123; sH = head; sT = head; &#125;else &#123; sT.next = head; sT = head; &#125; &#125;else if (head.value == privot)&#123; if (eH == null)&#123; eH = head; eT = head; &#125;else &#123; eT.next = head; eT = head; &#125; &#125;else &#123; if (bH == null)&#123; bH = head; bT = head; &#125;else &#123; bT.next = head; bT = head; &#125; &#125; head = next; &#125; // 边界条件没理解 if (sT != null)&#123; sT.next = eH; eT = eT == null ? sT : eT; &#125; if (eT != null )&#123; eT.next = bH; &#125; return sH != null ? sH : (eH != null ? eH :bH); &#125; 123456789101112131415public static NodeList copyListWithRand (Node head)&#123; HashMap &lt;Node,Node&gt; map = new HashMap&lt;Node,Node&gt;(); Node cur = head; while (cur != null)&#123; map.put(cur,new Node(cur.value)); cur = cur.next; &#125; cur = head; while (cur != null)&#123; map.get(cur).next = map.get(cur.next); map.get(cur).rand = map.get(cur.rand); cur = cur.next; &#125; return map.get(head);&#125; 也可以 12345678910111213141516171819202122232425262728293031public static NodeList copyListWithRand(Node head)&#123; if (head == null )&#123; return null; &#125; Node cur = head; Node next = null; while (cur != null)&#123; next = cur.next; cur.next = new Node (cur.value); cur.next.next = next; cur = next; &#125; cur = head; Node curCopy = null; while (cur != null)&#123; next = cur.next.next; curCopy = cur.next; curCopy.rand = cur.rand != null ? cur.rand.next:null; cur = next; &#125; Node res = head.next; cur = head; while (cur != null)&#123; next = cur.next.next; curCopy = cur.next; cur.next = next; curCopy.next = next != null ? next.next :null; cur = next; &#125; return res;&#125;","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ART 在 Android 安全攻防中的应用","slug":"Study/逆向知识/ART 在 Android 安全攻防中的应用","date":"2023-03-02T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/02/Study/逆向知识/ART 在 Android 安全攻防中的应用/","link":"","permalink":"https://beichen.link/2023/03/02/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/ART%20%E5%9C%A8%20Android%20%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"在日常的 Android 应用安全分析中，经常会遇到一些对抗，比如目标应用加壳、混淆、加固，需要进行脱壳还原；又或者会有针对常用注入工具的检测，比如 frida、Xposed 等，这时候也会想知道这些工具的核心原理以及是否自己可以实现。 其实这些问题的答案就在 Android 的 Java 虚拟机实现中。可以是早期的 Dalvik 虚拟机，也可以是最新的 ART 虚拟机。从时代潮流来看，本文主要专注于 ART。不过，为了铭记历史，也会对 Dalvik 虚拟机做一个简单的介绍。最后会从 ART 的实现出发对一些实际的应用场景进行讨论。 Jvm我们知道，Java 是一门跨平台的语言，系统实际运行的是 Java 字节码，由 Java 虚拟机去解释执行。 Android 代码既然是用 Java 代码编写的，那么运行时应该也会有一个解析字节码的虚拟机。和标准的 JVM 不同，Android 中实际会将 Java 代码编译为 Dalvik 字节码，运行时解析的也是用自研的虚拟机实现。 之所以使用自研实现，也许一方面有商业版权的考虑，另一方面也确实是适应了移动端的的运行场景。 Dalvik 指令基于寄存器，占 1-2 字节，Java 虚拟机指令基于栈，每条指令只占 1 字节；因此 Dalvik 虚拟机用空间换时间从而获得比 Oracle JVM 更快的执行速度。 启动其实 Java 代码执行并不慢，但其启动时间却是一大瓶颈。如果每个 APP 运行都要启动并初始化 Java 虚拟机，那延时将是无法接受的。在 Android 12 应用启动流程分析 一文中我们说到，APP 应用进程实际上是通过 zygote 进程 fork 出来的。这样的好处是子进程继承了父进程的进程空间，对于只读部分可以直接使用，而数据段也可以通过 COW(Copy On Write) 进行延时映射。查看 zygote 与其子进程的 /proc/self/maps 可以发现大部分系统库的映射都是相同的，这就是 fork 所带来的好处。 Java 虚拟机是在 Zygote 进程创建的，并由子进程继承，因此 APP 从 zygote 进程中 fork 启动后就无需再次启动 Java 虚拟机，而是复用原有的虚拟机执行轻量的初始化即可。 接口Android Java 虚拟机包括早期的 Dalvik 虚拟机和当前的 ART 虚拟机，我们将其统称为 Java 虚拟机，因为对于应用程序而言应该是透明的，也就是说二者应该提供了统一的对外接口。 这个接口可以分为两部分，一部分是提供给 Java 应用的接口，即我们常见的 JavaVM、JNIEnv 结构体提供的诸如 FindClass、GetMethodID、CallVoidMethod 等接口；另一部分则是提供给系统开发者的接口，系统通过这些接口去初始化并创建虚拟机，从而使自身具备执行 Java 代码的功能。 JniInvocation.Init 方法中即进行了第二部分接口的初始化操作，其中主要逻辑是根据系统属性 (persist.sys.dalvik.vm.lib.2) 判断待加载的虚拟机动态库，Dalvik 虚拟机对应的是 libdvm.so，ART 虚拟机对应的是 libart.so 总的来说，Java 虚拟机只在 Zygote 进程中创建一次，子进程通过 fork 获得虚拟机的一个副本，因此 zygote 才被称为所有 Java 进程的父进程；同时，也因为每个子进程拥有独立的虚拟机副本，所以某个进程的虚拟机崩溃后不影响其他进程，从而实现安全的运行时隔离。 DalvikDalvik 是早期 Android 的 Java 虚拟机，伴随着 Android 5.0 的更新，正式宣告其历史使命的结束 虽然 Dalvik 已经被 ART 取代，但其中的 Dalvik 字节码格式还是被保留了下来。即便在最新版本的 Android 中，编译 Java 生成的依旧是 DEX 文件 ARTART 全称为 Android Runtime，是继 Dalvik 之后推出的高性能 Android Java 虚拟机 提前优化在我们使用 Android-Studio 编译应用时，实际上是通过 Java 编译器先将 .java 代码编译为对应的 Java 字节码，即 .class 类文件；然后用 dx(在新版本中是 d8) 将 Java 字节码转换为 Dalvik 字节码，并将所有生成的类打包到统一的 DEX 文件中，最终和资源文件一起 zip 压缩为 .apk 文件。 在安装用户的 APK 时，Android 系统主要通过 PacketManager 对应用进行解包和安装。其中在处理 DEX 文件时候，会通过 installd 进程调用对应的二进制程序对字节码进行优化，这对于 Dalvik 虚拟机而言使用的是 dexopt 程序，而 ART 中使用的是 dex2oat 程序。 dexopt 将 dex 文件优化为 odex 文件，即 optimized-dex 的缩写，其中包含的是优化后的 Dalvik 字节码，称为 quickend dex； dex2oat 基于 LLVM，优化后生成的是对应平台的二进制代码，以 oat 格式保存，oat 的全称为 Optimized Android Runtime。oat 文件实际上是以 ELF 格式进行存储的，并在其中 oatdata 段(section) 包含了原始的 DEX 内容。 值得一提的是，在 Andorid 系统中 dex2oat 会将优化后的代码保存在 &#x2F;data&#x2F;app 对应的应用路径下，系统应用会保存在 &#x2F;data&#x2F;dalvik-cache&#x2F; 下 AOT 和 JIT 是什么？AOT,即 Ahead-of-time,指预先编译. JIT,即 Just-In-Time,指即时编译. 区别: 主要区别在于是否在“运行时”进行编译. AOT 编译是在程序运行之前将整个源代码或字节码文件一次性地编译成本地机器码。这意味着在程序运行时不需要再进行额外的编译工作，直接执行已经编译好的机器码。 JIT 编译是在程序运行过程中动态地将热点代码（频繁执行的代码）从字节码即时编译成本地机器码。JIT 编译器会根据实际的执行情况来选择需要编译的代码，并且可以根据优化策略对代码进行优化。 优劣AOT 优点： 在程序运行前编译,可以避免在运行时的编译性能消耗和内存消耗. 可以在程序运行初期就达到最高性能. 可以显著的加快程序的启动. AOT 缺点： 在程序运行前编译会使程序安装的时间增加. 牺牲 Java 的一致性. 将提前编译的内容保存会占用更多的外存. JIT 优点： 可以根据当前硬件情况实时编译生成最优机器指令. 当程序需要支持动态链接时,只能使用 JIT. 可以根据进程中内存的实际情况调整代码,使内存能够更充分的利用. JIT 缺点： 编译需要占用运行时资源,会导致进程卡顿. 由于编译时间需要占用运行时间,对于某些代码的编译优化不能完全支持,需要在程序流畅和编译时间之间做权衡. 在编译准备和识别频繁使用的方法需要占用时间,使得初始编译不能达到最高性能. 混合编译: Android N 引入了使用编译+解释+JIT 的混合运行时,以获得安装时间,内存占用,电池消耗和性能之间的最佳折衷. 优点: 即使是大型应用程序的安装时间也减少到几秒钟. 系统更新安装得更快,因为它们不需要优化步骤. 应用程序的 RAM 占用空间较小,在某些情况下降至 50％. 改善了表现. 降低电池消耗. 文件加载APP 的代码(DEX&#x2F;OAT 文件) 是如何加载到进程中的？ 在 Java 中负责加载指定类的对象是 ClassLoader，Android 中也是类似，BaseDexClassLoader 继承自 ClassLoader 类，实现了许多 DEX 相关的加载操作，其子类包括: DexClassLoader: 负责从 .jar 或者 .apk 中加载类； PathClassLoader: 负责从本地文件中初始化类加载器； InMemoryDexClassLoader: 从内存中初始化类加载器； 应用场景通过上面的分析，我们大致了解了 ART 虚拟机的文件、代码加载流程，以及对应 Java 方法和指令的运行过程。正所谓无利不起早，之所以花费这么多时间精力去学习 ART，是因为其在 Android 运行过程中起着举足轻重的作用，下面就列举一些常见的应用场景。 热修复 &amp; Hook所谓热修复，就是在不修改原有代码的基础上修改应用功能，比如替换某些类方法的实现，达到热更新的目的。犹记得在几年前，热修复的概念在 Android 生态中甚嚣尘上，随着 ART 替换 Dalvik，以及碎片化引入的一系列问题导致这种方案逐渐销声匿迹。但是热修复的使用场景并没有完全消失，比如在 Android 应用安全研究中 Hook 的概念也是热修复的一种延续。 那么根据前面总结的知识可以考虑一个问题，如何在运行时劫持某个 Java 方法的执行流程？最好是可以在指定方法调用前以及返回前分别触发我们自己定义的回调，从而实现调用参数和返回值的观察和修改。 根据前文对方法调用和代码加载的分析，Android 中的 Java 方法在 ART 中执行都会通过 ArtMethod::Invoke 进行调用，在其内部要么通过解释器直接解释执行(配合 JIT)；要么通过 GetEntryPointFromQuickCompiledCode 获取本地代码进行执行，当然后者在某些场景下依然会回退到解释器，但入口都是固定的，即entry_point_from_quick_compiled_code 所指向的 quick 代码。因此，要想实现 Java 方法调用的劫持，可以有几种思路: 修改 ArtMethod::Invoke 这个 C++ 函数为我们自己的实现，在其中增加劫持逻辑； 修改目标 Java 方法属性，令所有调用都走 quick 分支，然后将 entry_point_from_quick_compiled_code 修改为指向我们自己的实现，从而实现劫持； 类似于上述方法，不过不修改指针的值，而是修改 stub code； frida 实际上是使用了我们上述的第 3 种 Hook 思路，即修改 stub code 为我们的劫持代码，这种方式一般称之为 dynamic callee-side rewriting，优点是即便对于 OAT 极致优化的系统类方法也同样有效。 加固了解过 Android 逆向工程的人应该都知道，基于 Java 编译出来的 Dalvik 字节码其实很好理解，加上一些开源或者商业的反编译工具，甚至可以将字节码还原为和源代码非常接近的 Java 代码表示。这对于很多想在代码中隐藏秘密的公司而言是很不愿意看到的。 因此，安全工程师们就想出了一些保护代码防止静态逆向分析的方案，业内常称为 加壳，国外叫做 Packer，即在原始字节码上套上一层保护壳，并在运行时进行执行解密还原。 回顾我们学习的知识可以脑暴出几种安全加固方案(其实是业内已有方案): 把整个 DEX 文件加密，然后在壳程序启动时还原解密文件并加载； 优化上述方案，不落地文件，直接在内存中解密加载； 提取出 DEX 文件中的字节码，并在运行时还原； 替换掉 DEX 文件中每个方法的字节码为解密代码，运行时解密执行； 这些加固方案根据解密粒度不同也常称为整体壳、抽取壳。对于整体加密的方案不必多说，在 PC 时代也有很多类似的混淆方法；而对于抽取壳，实现就百花齐放了，比如有的加固方案是在类初始化期间进行还原，有的是在方法执行前进行还原。 回顾上面介绍热修复的内容，壳代码其实也可以看做是一个热修复框架，只不过是对于每个函数都进行了劫持，在目标函数运行前对实际的字节码进行还原； 有些类级别的加固则是基于上文中代码加载流程，在类的初始化函数()中执行解密操作，因为 Java 标准保证了这是一个类最先执行的代码。 由于抽取壳本身对字节码进行了加密，因此在应用安装期间 dex2oat 就无法优化这些代码，以至于在运行时只能通过解释执行，虽然有一部分 JIT 的加持，但还是让 ART 的大部分优化心血付诸东流；另外，加壳本身会使用到 ART 中的一些内部符号和偏移，因此需要针对不同版本进行适配，一个不小心就是用户端的持续崩溃。 也因为这些原因，很多头部厂商的 Android 应用其实是不加壳的，对于真正需要保护的代码，可以选择 JNI 用 C&#x2F;C++ 实现，并配上 LLVM 成熟的混淆方案进行加固。 脱壳由于很多安全公司把加固做成了商业服务，因此除了正常应用，大部分恶意软件和非法应用也都用上了商业的加固方案，这对于正义的安全研究员而言是一个确实的阻碍，因此脱壳也就成了常见需求。 一开始我们在遇到加固的应用时候会先尝试进行手动进行分析、调试、还原，但是后来大家发现其实基于 ART 的运行模式有更通用的解决方式。 这里以目前相对较新的抽取壳为例，回顾上文代码方法调用和代码加载的章节，不论加固的抽取和还原方法如何，最终还是要回到解释执行的(至少在 JIT 之前)，因为加密的代码在安装时并没有被 AOT 优化。而且为了保证原始代码逻辑不变，对应加密方法在实际运行之前肯定需要被正确解密还原。 基于这点事实，我们可以在 ArtMethod 调用前进行断点，然后通过 method-&gt;GetDexFile() 获得对应 dex 文件在内存中的地址并进行转储保存。如果当前内存中的 dex 部分偏移被恶意修改，那么还可以通过 method-&gt;GetCodeItem() 获取对应方法解密后的字节码地址进行手动转储恢复。 如果要恢复完整的 dex 文件，则需要令目标程序在运行时调用所有类的所有方法，这显然不太现实；不过网上已经有了一些开源的方案基于主动调用的思路去批量伪造方法调用，触发壳的解密逻辑从而实现全量还原，比如 DexHunter 和 FART，都是通过修改 Android 源码实现的脱壳方案。 方法跟踪对于上述 Android 应用加壳的方案，在数次攻防角斗下已经被证明了只能作为辅助防护，因此移动安全厂商又提出了一些新的加固方案，比如直接对字节码本身下手，套用 LLVM 控制流和数据流混淆的那一套方案，将字节码的执行顺序打乱，插入各种无效指令来阻碍逆向工程；又或者将字节码的实现抽批量自动取到 JNI 层，并辅以二进制级别的安全加固，这种方案通常称为 Java2C，即将 Java 代码转译成 C 代码编译来防止逆向分析。…… 这时，传统的脱壳方法就不见得有效了，因为即便还原出字节码或者 Java 代码，其流程也是混乱的，对于 Java2C 则更不用说，只能在二进制中想办法将 JNI 调用还原。 总结本文主要目的是分析 Android 12 中 ART 的实现，包括 Java 方法初始化和执行的过程。基于对 ART 的深入理解，我们也列举了几种实践中经常遇到的场景，比如热修复、动态注入、安全加固、脱壳等。也许在工作中信奉拿来主义，只需要工具能用就行，但了解工具背后的原理，才能更好适应当前不断激化的攻防对抗环境，从而更好地迎接未来的挑战。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"哈希表和有序表","slug":"Study/算法/哈希表和有序表","date":"2023-03-01T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/03/01/Study/算法/哈希表和有序表/","link":"","permalink":"https://beichen.link/2023/03/01/Study/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E6%9C%89%E5%BA%8F%E8%A1%A8/","excerpt":"","text":"哈希表 String 也是按值传递。 12345HashMap&lt;Integer, String&gt; mapTest = new HashMap &lt;&gt;();mapTest.put(1,&quot;test&quot;);HashSet&lt;Integer&gt; HashSet1 = new HashSet&lt;&gt;();hashSet1.add(3); 有序表 时间复杂度 O(logN) 12TreeMap&lt;Integer,String&gt; treeMap1 = new TreeMap&lt;&gt;();treeMap1.put(7,&quot;test&quot;); 有序表必须设置比较器 1234567public static class NodeComparetor implements Comparator&lt;Node&gt;&#123; public int compare(Node o1,Node o2)&#123; return o1.value - o2.value; &#125;&#125; TreeSet&lt;Node&gt; treeSet = new TreeSet&lt;&gt;(new NodeComparator());","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Android 抓包的整理","slug":"Study/逆向知识/抓包学习","date":"2023-03-01T00:00:00.000Z","updated":"2023-12-07T09:39:19.751Z","comments":true,"path":"2023/03/01/Study/逆向知识/抓包学习/","link":"","permalink":"https://beichen.link/2023/03/01/Study/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/%E6%8A%93%E5%8C%85%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"抓包方式 hook app 业务层，根据业务代码逻辑找到触发请求的函数，比如按钮触发，或者触发数据上报时的提示框等方式。分析后找到发送数据的地方 hook 打印。 优点：不受 app 的防抓包手段的影响，只要能 hook 到就能抓到包。 缺点：必须分析 app 找关键点，并且每个不同的请求都要找对应的触发函数，效率太慢。 系统框架层的 hook。直接 hook 系统源码发送和接受数据的地方。 优点：可以直接省略掉业务层的分析。因为业务层不论逻辑怎么样最终都是调用系统的或者是第三方的库来进行数据传输。并且通用性更好。基本不用修改就可以抓很多 app 的包。并且可以在这里直接打印堆栈回溯请求触发的函数，提高分析的效率。同样不受防抓包手段影响。 缺点：hook 出来的抓包数据不便于我们分析和筛选。只能在日志中查找对应的数据，分析数据包会比较繁琐。简单的需求或者是溯源时使用比较好 中间人抓包，使用 charles、burp 等抓包工具进行拦截，中间人抓包在 https 请求时，抓包软件的证书在中间冒充服务端接收客服端的请求。然后又冒充客户端，发送请求给服务端。在中间拿到了客户端和服务端的数据。 优点：专业的抓包分析软件，更加友好的分析页面。更加强大的功能，例如可以拦截请求进行改写替换，安装证书可以解析抓到的 https 数据包。支持 vpn 抓包 缺点：防抓包手段针对的主要目标，例如服务端验证客户端证书，不正确就拒绝访问，我们需要把客户端的证书给 dump 出来，然后让中间人抓包使用指定证书。或者是客户端验证服务端证书。我们需要找到并 hook 去掉验证的代码。无法抓 tcp 和 udp 的包 网卡抓包、路由抓包。如 wireshark，科来之类的。 优点：这种方式不受任何限制，并且通杀，绝对能抓到。 缺点：对于加密的数据没有办法。需要自己进行解密，对于 http 和 https 包的展示不太友好 其中比较通用一点的是系统层的 hook。所以我这里主要针对这个记录下系统层 hook 的方式抓取 http、https、tcp、udp 的数据 网络知识首先贴一个网上找的经典的网络模型图。可以看出 http 包是处于应用层的一种封装，所以我们抓 tcp 包的时候就可以抓到 http 包。 HTTPS 流程超文本传输安全协议（HyperText Transfer Protocol Secure，缩写：HTTPS）是一种通过计算机网络进行安全通信的传输协议。 HTTPS 经由 HTTP 进行通信，利用 SSL&#x2F;TLS 来加密数据包。其主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。 加密与签名 Hash「Hash 算法」也被称为散列算法。「Hash 算法」没有一个固定的公式，只要符合散列思想的算法都可以被称为是「Hash 算法」。 通常无法通过数据的 hash 值还原出原始数据，不同数据的 hash 值不同，所以可以用「Hash 算法」来校验完整性，检测数据是否完整或者是否有更改。 对称加密加密与解密使用同样的密钥。 对称加密效率较高，被广泛应用于各种加密协议，然而在通讯前需要将密钥发送给对方，容易导致密钥泄漏。 非对称加密使用了一对密钥：公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发给任何请求者。通过公钥加密的数据只能由私钥解开。 相比对称加密而言，非对称加密是十分安全的，但是加密和解密效率却没有对称加密高。 数据签名 数据签名可以理解为：利用非对称加密中的私钥对「数据的 Hash 值」进行加密后的数据。 签名的验证者使用公钥对数据签名进行解密，并将解密结果与自己计算出的数据的 Hash 值进行比对，结果相同则证明数据完整、签名有效，否则，则认为数据无效。 加密过程：公钥加密，私钥解密； 数字签名：私钥加密，公钥解密； 数字证书数字证书用来证明公钥拥有者的身份。 数字证书中包含：拥有者的公钥、拥有者名称、证书颁发者信息、证书信息签名及有效期等 SSL&#x2F;TSL ClientHelloClient 首先发送本地的 TLS 版本、支持的加密算法套件，并且生成一个随机数 R1 Server Hello Server 端确认 TLS 版本号。从 Client 端支持的加密套件中选取一个，并生成一个随机数 R2 一起发送给 Client。 Server 向 Client 发动自己的 CA 证书(包含公钥)、证书签名。 证书校验 Client 判断证书签名与 CA 证书是否合法有效 Client 生成随机数 Pre-Master ，并使用第二步中的公钥对 Pre-Master 进行加密，将加密后的 Pre-Master 送给服务器 这一步结束后，Client 与 Server 就都有 R1、R2、Pre-Master 了，两端便可以使用这 3 个随机数独立生成对称加密会话密钥了,避免了对称加密密钥的传输,同时可以根据会话密钥生成 6 个密钥（P1~P6）用作后续身份验证 Client 握手结束通知 Client 使用 P1 将之前的握手信息的 hash 值加密并发送给 Server Client 发送握手结束消息 Server 握手结束通知 Server 计算之前的握手信息的 hash 值，并与 P1 解密客户端发送的握手信息的 hash 对比校验 验证通过后，使用 P2 将之前的握手信息的 hash 值加密并发送给 Client Client 开始 HTTPS 通讯 Client 计算之前的握手信息的 hash 值，并与 P2 解密 Server 发送的握手信息的 hash 对比校验 验证通过后，开始发起 HTTPS 请求。 中间人对抗攻击而使用中间人抓包。常常会碰到防抓包手段。这些手段一般都是针对证书的检测。 服务端验证客户端证书 服务端会检测客户端交互使用的证书是不是正确的。这种情况我们可以直接将客户端里面使用的证书导出来，然后设置让 charles 使用指定的证书来抓包。 对于这种双向认证的 APP 定位一般就是 KeyStore.getInstance X509TrustManager PKCS12. 那么就拿我们脱完壳的 dex 搜索一下. 根据我们三个关键词搜索的结果来看 这个类 com.hundsun.net.a.e 有很大的嫌疑! 因为所有关键词的搜索结果都指向了这个类!!! 然后进到类中查看,果然发现了关键函数 这里出现了一个 client.p12 的证书文件,根据代码指引,这个文件就存在于 APK assets 目录下那我们拿下来看下 这东西典型不符合 p12 证书的格式,明显是个 base64 的压缩流,那我们再看下代码. 果然在得到证书文件后它把得到的证书流进行了 DES 解密操作 其实这时候我们只需要 HOOK KeyStore 的 load 函数 就能拿到证书的流跟密码. 12345678910111213141516171819202122232425262728293031function hook_KeyStore_load() &#123; Java.perform(function () &#123; var StringClass = Java.use(&quot;java.lang.String&quot;); var KeyStore = Java.use(&quot;java.security.KeyStore&quot;); KeyStore.load.overload( &quot;java.security.KeyStore$LoadStoreParameter&quot; ).implementation = function (arg0) &#123; console.log(&quot;KeyStore.load1:&quot;, arg0); this.load(arg0); &#125;; KeyStore.load.overload(&quot;java.io.InputStream&quot;, &quot;[C&quot;).implementation = function (arg0, arg1) &#123; console.log( &quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null ); if (arg0 != null) &#123; var byteArray = Java.array(&quot;byte&quot;, new Array(10240).fill(0)); arg0.read(byteArray); console.log(buf2hex(byteArray, 10240)); &#125; this.load(arg0, arg1); &#125;; console.log(&quot;hook_KeyStore_load...&quot;); &#125;);&#125;setImmediate(hook_KeyStore_load); 客户端验证服务端证书 大概就是客户端向服务端请求。然后服务端把自己的证书返回了。客户端验证一下证书是否正确有效。没啥问题才正常通讯。而这种判断逻辑直接在客户端的。那就直接 hook 修改让他不要处理就行了。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"}]},{"title":"左神数据结构-简单排序算法","slug":"Study/算法/左神数据结构","date":"2023-02-27T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/02/27/Study/算法/左神数据结构/","link":"","permalink":"https://beichen.link/2023/02/27/Study/%E7%AE%97%E6%B3%95/%E5%B7%A6%E7%A5%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"选择排序 时间复杂度O(n^2) 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 1234567891011121314151617public static void SelectjionSort(int[] array) &#123; if (array == null || array.length &lt;2) return; for (int i = 0; i &lt; array.length - 1; i++)&#123; int minIndex = i; for (int j = i + 1; j &lt; array.length; j++)&#123; minIndex = array[j] &lt; array[minIndex] ? j : minIndex; &#125; swap(array, i, minIndex); &#125;&#125;public static void swap(int[] array, int i, int j)&#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp;&#125; 冒泡排序 时间复杂度O(n^2) 每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数归位，第二趟只能将倒数第 2 位上的数归位，依次类推下去。如果有 n 个数进行排序，只需将 n-1 个数归位，也就是要进行 n-1 趟操作。 而 “每一趟 ” 都需要从第一位开始进行相邻的两个数的比较，将较大的数放后面，比较完毕之后向后挪一位继续比较下面两个相邻的两个数大小关系，重复此步骤，直到最后一个还没归位的数。 1234567891011121314151617181920public static void bubbleSort(int[] array)&#123; if (array == null || array.length &lt; 2)&#123; return; &#125; for (int e = array.length - 1; e &gt; 0; e--)&#123; for (int i = 0; i &lt; e; i++)&#123; if (array[i] &gt; array[i+1])&#123; swap(array,i,i+1) &#125; &#125; &#125;&#125;public static void swap(int[] array, int i, int j)&#123; // ^ 是异或，满足交换律和结合律，a ^ 0 = a , a ^ a = 0 // 这种交换就不需要额外增加一个temp变量，但是i,j要是独立的两块内存空间，数组里面就i不能等于j array[i] = array[i] ^ array[j]; array[j] = array[i] ^ array[j]; array[i] = array[i] ^ array[j];&#125; 一道关于异或的题目：(位运算比算数运算快得多) 在一个数组中，已知一种数出现了奇数次，其他所有数都出现了偶数次，问怎么找到这个数？继续下去，如果有两种数都出现了奇数次，怎么找到这两种数？要求时间复杂度o(n),空间o(1)。 思路： 第一问，所有数直接异或，结果就是奇数次的数值。 第二问，所有数直接异或，结果是a ^ b的数值，且这个数值必不等于零。对于这个数，找一个二进制位的值为 1 其他位都为 0 的情况，那所有的数都可以分成两类：此二进制位上为 1 和为 0 ，除了两种数。都各自出现偶数次。那么 a ^ b 直接跟其中一类所有数异或，就能得到一种出现奇数次的数。 12345678910111213141516171819202122public static int printOddTimesNum1(int[] arr)&#123; int eor = 0; for (int cur : arr )&#123; eor ^ = cur; &#125; return eor；&#125;public static int printOddTimesNum2(int[] arr)&#123; int eor = 0, onlyOne = 0; for (int cur :arr)&#123; eor ^= cur; &#125; // eor = a ^ b , a ^ b != 0 ,eor 必然有一个位置是1 int rightOne = eor &amp; (~eor + 1); // 提取出最右的 1 for (int cur : arr)&#123; if ((cur &amp; rightOne) == 0)&#123; onlyOne ^= cur; &#125; &#125; return eor ^ onlyOne;&#125; 插入排序 时间复杂度 O(n^2) 插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌 。 插入排序是指在待排序的元素中，假设前面n-1(其中n&gt;&#x3D;2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序 123456789101112public static void insertSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; // 0~0 已经有序的， 0~i想有序的 for (int i = 1; i &lt; arr.length; i++)&#123; // 0~i 做到有序 for (int j = i -1 ; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j+1]; j--)&#123; swap(arr,j,j+1); &#125; &#125;&#125; 插入排序和冒泡排序的区别： 冒泡排序是拿一个元素和无序序列去遍历比较，比较得到整个无序序列中最值，然后放入有序序列，而一旦放入有序序列，就不再碰了 冒泡排序的当前元素是无论如何不会触摸有序序列的，非常生动的体现了冒泡的情形，泡泡是乱的，最大的泡泡在大大小小杂乱无章的泡泡群中漂浮到最上面 而插入排序呢恰恰相反 插入排序是拿一个元素和有序的数列去比，从单一元素的假有序一个一个加，拿一个元素进入有序序列，碰到比自己大或小的就即刻坐下，不再继续比较 插入排序的当前元素是无论如何不会触摸无序序列的 冒泡排序因为是无序，所以你即使遇到下一个比自己大，你不知道后面有没有更大的，你只能换一下，把手中的换成刚刚比较出更大的，去比接下来的 冒泡的每一次冒，都要把无序序列轮一遍 插入排序恰恰相反，一旦你遇到比自己大或小的了，你就知道，后面都是比自己大或小的，就没必要再继续往前走了，现在坐下，当前元素就进入了有序序列 插入的每一次插，都不一定要轮一遍有序序列 二分法 时间复杂度 O(logn) 在一个有序数组中，找某个数是否存在 在一个有序数组中，找&gt;&#x3D;某个数的最左侧位置 局部最小值问题 定义局部最小的概念。 1234arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。 给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。 二分查找并不是数组有序时才能使用，只要你能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找，一般 mid 值取 mid &#x3D; left + (right - left) &#x2F; 2，避免 mid &#x3D; (left + right) &#x2F; 2 造成的因边界值过大导致溢出的情况。也可以写为 mid &#x3D; left + (right-left)&gt;&gt;1 如果遍历过程中，有了这样的情况，mid位置的值左大右小(右小左大同理)，则说明了出现了新的两端严格递减区间，而两端严格递减区间之间一定有局部最小值，所以就二分，收缩边界到新的边界，以此类推。 12345678910111213141516171819public static int localMin(int[] nums)&#123; if (nums == null || nums.length == 0 ) return -1; int N = nums.length; if( N == 1 || (nums[0] &lt; nums[1]) ) return 0; if (nums[N-1] &lt; nums[N-2]) return N-1; int left = 0; int right = N-1; while (left &lt; right )&#123; int mid = left + (right - left)/2; if (nums[mid+1] &gt; nums[mid])&#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return right;&#125; 对数器通常我们在笔试的时候或者参加编程大赛的时候，自己实现了一个算法，但是不能够判断该算法是否完全没问题，如果在比赛平台上验证，通常只会告诉你有没有错误，出了错不会告诉你哪里有问题，对于排错来说是非常坑爹的，所以对数器就横空出世了，对数器就是用一个绝对OK的方法和随机器生成的样本数据进行合体，如果你的算法是没问题的，那么和对数器的这个百分之百正确的方法一个元素一个元素的比较，也一定是equals的。如果返回false，说明你的算法有问题。 纳尼？？我都能写出一个百分之百正确的对数器了，还用得着跟我自己实现的算法比较么？肯定也是对的啊，话是如此，没错，但是算法的目的是更高效、更优的处理一些问题，你的比较器的时间复杂度和空间复杂度往往是比较低的，因为这样才能保证它的准确性，而你笔试或者比赛写出的算法，复杂度往往比较高，所以可以通过低复杂度但是绝对正确的方法验证你的算法正确不正确。 看一下左神大佬是怎么定义对数器的概念的：1.有一个你想要测的方法a；2.实现一个绝对正确但是复杂度不好的方法b；3.实现一个随机样本产生器；4.实现对比算法a和b的方法；5.把方法a和方法b比对多次来验证方法a是否正确；6.如果有一个样本使得比对出错，打印样本分析是哪个方法出错；7.当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 简单递归的时间复杂度计算 只看算法进行一次的情况下： N为母问题的数据量，N&#x2F;b为每个相同的子问题的数据量，a为子问题的调用次数，o(N^d)为除了调用子问题以外的时间复杂度。 1234567891011121314public static int getMax(int[] arr)&#123; return process(arr,0,arr.length - 1);&#125;public static int process(int[] arr,int L,int R)&#123; if (L==R)&#123; return arr[L]; &#125; int mid = L +((R - L) &gt;&gt; 1); int leftMax = process(arr,L,mid); int rightMax = process(arr,mid+1,R); return Math.max(leftMax,rightMax);&#125; 调用过程 时间复杂度： T(N) &#x3D; 2 * T(N&#x2F;2)+O(1), 根据Maser公式，T(N) &#x3D; O(N) 归并排序 时间复杂度 O(NlogN) 归并排序是用分治思想，分治模式在每一层递归上有三个步骤： 分解（Divide）：将n个元素分成个含n&#x2F;2个元素的子序列。 解决（Conquer）：用合并排序法对两个子序列递归的排序。 合并（Combine）：合并两个已排序的子序列已得到排序结果。 1234567891011121314151617181920212223242526272829303132333435public static void mergeSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; process(arr,0,arr.length - 1);&#125;public static void process(int[] arr,int L,int R)&#123; if(L==R)&#123; return; &#125; int mid = L + ((R - L)&gt;&gt;1); process(arr,L,mid); process(arr,mid+1,R); merge(arr,L,mid,R);&#125;public static void merge(int[] arr,int L,int M,int R)&#123; int[] help = new int (R-L+1); int i = 0; int p1 = L; int p2 = M+1; while(p1 &lt;= M &amp;&amp; p2 &lt;= R)&#123; help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= M)&#123; // if p1 没越界 help[i++] = arr[p1++] &#125; while (p2 &lt;= R)&#123; // if p2 没越界 help[i++] = arr[p2++] &#125; for(i = 0; i &lt; help.length; i++)&#123; arr[L+i] = help[i]; &#125;&#125; 一道题：小和问题。 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求某个数组的小和。(类似的还有求逆序对问题) 123456789101112131415161718192021222324252627282930313233343536public static int smallSum(int[] arr)&#123; if (arr == null || arr.length &lt; 2 )&#123; return 0; &#125; return process(arr,0,arr.length - 1);&#125;public static int process(int[] arr,int l,int r)&#123; if (l == r)&#123; return 0; &#125; int mid = l + ((r - l) &gt;&gt; 1); return process(arr,l,mid) + process(arr,mid+1,r) + merge(arr,l,mid,r);&#125;public static int merge(int[] arr,int L,int m,int R)&#123; int[] help = new int[R-L+1]; int i = 0, p1 = L, p2 = m+1, res = 0; while (p1 &lt;= m &amp;&amp; p2 &lt;= R)&#123; //这里和归并排序有区别，归并是 &lt;=,这里全是 &lt; //原因就是当遇见两边数字相等的情况，小和为0，右边指针要想继续走下去，必定是先拷贝右边的数字，这样指针才能继续 //排序是为了通过 R - p2 + 1 求小和 res += arr[p1] &lt; arr[p2] ? (R - p2 + 1) * arr[p1] : 0; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; while (p1 &lt;= m)&#123; help[i++] = arr[p1++]; &#125; while (p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for (i = 0;i &lt; help.length; i++)&#123; arr[L+i] = help[i]; &#125; return res;&#125; 快排 时间复杂度 O(NlogN) 空间复杂度 O(logN) 数组被最后一个元素划分，分三部分，&lt; 区，&#x3D; 区, &gt;区。 1234567891011121314151617181920212223242526272829303132333435public void quickSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; quickSort(arr,0,arr.length - 1);&#125;public staric void quickSort(int[] arr,int L,int R)&#123; if(L &lt; R)&#123; swap(arr,L + (int) (Math.random() * (R-L+1)),R); int[] p = partition(arr,L,R); quickSort(arr,L,p[0] - 1); // &lt; 区 quickSort(arr,p[1] +1 ,R); // &gt; 区 &#125;&#125;// 默认以 arr[R] 做划分， &lt; ==arr[R] &gt; // 返回等于区域的左边界和右边界public static int[] partition (int[] arr,int L,int R)&#123; int less = L - 1; // &lt; 区 右边界 int more = R; // &gt; 区 左边界，注意默认以 arr[R] 做划分，那 &gt; 区 左边界就是 R while (L &lt; more )&#123; // L 就是当前数的位置， arr[R] 就是划分值 if (arr[L] &lt; arr[R])&#123; swap(arr, ++less,L++); &#125; else if (arr[L] &gt; arr[R])&#123; swap(arr,--more,L); &#125; else &#123; L++; &#125; &#125; // 当 &gt; 区 左边界 和 当前位置撞上时， while 停止，最后再把arr[R] 放入等于区 swap(arr,more,R); return new int[] &#123;less + 1,more&#125;;&#125; 堆排序 时间复杂度 O(N logN) 在完全二叉树的情况下，以数组存储，各节点的下标为： 大根堆： 父节点大于孩子节点。 123456789101112131415161718192021222324252627282930313233343536373839public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2 ) return; for(int i = 0 ;i &lt; arr.length; i++) &#123; // O(N) heapInsert( arr , i ); // O(logN) &#125; int heapSize = arr.length; swap(arr, 0, --heapSize); while( heapSize &gt; 0)&#123; //O(N) heapify(arr, 0, heapSize); // O(logN) swap(arr, 0, --heapSize); &#125;&#125; // 某个数现在处在 index 位置，继续往上移动public static void heapInsert(int[] arr, int index) &#123; while ( arr[index] &gt; arr[ (index - 1)/2 ] )&#123; // index = 0,(index -1/2) = 0 swap(arr, index, (index - 1)/2); index = (index - 1)/2 ; &#125;&#125; // 某个数现在处在 index 位置，能否往下移动public static void heapify(int[] arr, int index, int heapSize) &#123; int left = index * 2 +1; //左孩子下标 while (left &lt; heapSize)&#123; //当下方还有孩子的时候 // 两个孩子中，谁的值大，把下标给 largest int largest = left +1 &lt; heapSize &amp;&amp; arr[left +1] &gt;arr[left] ? left +1 : left; // 父节点和孩子比较，谁大给 largest largest =arr[largest] &gt; arr[index] ? largest : index ; if (largest == index)&#123; break; &#125; swap(arr, largest, index); index = largest; left = index *2 +1; &#125;&#125; 使用小根堆，距离最大是k，也就是说前K+1个数里必定有一个最小值会在排好序的最终数组里的固定位置。 12345678910111213public void sortArrDistanceLessK (int[] arr, int k)&#123; // 默认·小根堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt; (); int index = 0; for (;index &lt;= k; index++)&#123; heap.add(arr[index]); &#125; int i = 0; for (;index &lt; arr.length; i++)&#123; arr[i] = heap.poll(); heap.add(arr[index++]) &#125;&#125; 比较器 例： PriorityQueue 默认是小根堆，也可以传入一个比较器使得成为大根堆。","categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"ausera_docker 部署","slug":"LAB/APP Detection engine/ausera_docker","date":"2023-01-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/01/15/LAB/APP Detection engine/ausera_docker/","link":"","permalink":"https://beichen.link/2023/01/15/LAB/APP%20Detection%20engine/ausera_docker/","excerpt":"","text":"docker pull james0818&#x2F;jdk1.8.0_241:latest , 发现 docker 没启动，直接 sudo service docker start 发现 docker 命令老需要加 sudo ，所以添加自己用户到 docker 组 12345678# 查看用户组及成员sudo cat /etc/group | grep docker# 添加用户到docker组sudo gpasswd -a $&#123;USER&#125; docker # 增加读写权限sudo chmod a+rw /var/run/docker.sock# 重启dockersudo systemctl restart docker 查看 pull 下来的本地镜像 docker images， 然后重命名镜像，docker tag oldname:tag newname:tag ，删除镜像， docker rmi image_name: tag 创建容器 docker run –name 容器名 镜像名 , 删除容器 docker rm 容器名, 查看运行的容器 docker ps , 查看所有容器 docker ps -a 以交互模式创建镜像 docker run -it 镜像名 &#x2F;bin&#x2F;bash, 以交互模式进入容器 docker start -i 容器名 容器文件传输 docker cp 本地文件 容器名: 路径 打包容器成镜像 docker commit 镜像名 打包镜像成本地文件 docker save 镜像名&gt;文件名.tar 搭建本地私有docker 仓库 12345678910111213141516# 先下载registry镜像docker pull registry# 在daemon.json文件中添加私有镜像仓库的地址并重启sudo vim /etc/docker/daemon.json# 修改内容&#123; &quot;insecure-registries&quot;: [&quot;192.168.223.30:5000&quot;], #添加此段，“，”不可少，ip是本机IP地址 &quot;registry-mirrors&quot;: [&quot;https://4abdkxlk.mirror.aliyuncs.com&quot;]&#125;# 重启 dockersudo systemctl daemon-reloadsudo systemctl restart docker.service# 创建registry容器并开放端口docker create -it registry /bin/bash# -p指定端口，一内一外；-v表示挂载，前者是宿主机，后者是容器docker run -d -p 5000:5000 -v /data/registry:/tmp/registry registry 给镜像打标签后上传到私有仓库 将镜像改名为 IP&#x2F;镜像名, docker tag nginx:latest 192.168.50.128:5000&#x2F;nginx 上传 docker push 192.168.50.128:5000&#x2F;nginx 获取私有仓库列表查看是否上传成功, curl -XGET http://192.168.50.128:5000/v2/_catalog, 会返回镜像名 从私有仓库下载镜像 docker pull 192.168.50.128:5000&#x2F;nginx 其他机器pull 镜像时，需要先 vim etc&#x2F;docker&#x2F;daemon.json，添加 1234567&#123; &quot;insecure-registries&quot;: [&quot;192.168.1.26:5000&quot;]&#125;# 重启dockersystemctl daemon-reloadsystemctl restart docker python2.7 apk-engine.py &#x2F;root&#x2F;ausera&#x2F; &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.8.0_241 &#x2F;root&#x2F;ausera&#x2F;engine-configuration&#x2F;libs&#x2F;android-platforms","categories":[{"name":"APP Detection engine","slug":"APP-Detection-engine","permalink":"https://beichen.link/categories/APP-Detection-engine/"}],"tags":[{"name":"android，Docker","slug":"android，Docker","permalink":"https://beichen.link/tags/android%EF%BC%8CDocker/"}]},{"title":"人脸实名认证-百度SDK系APP","slug":"Paper/SDK-Test/百度","date":"2023-01-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/01/15/Paper/SDK-Test/百度/","link":"","permalink":"https://beichen.link/2023/01/15/Paper/SDK-Test/%E7%99%BE%E5%BA%A6/","excerpt":"","text":"com.baidu.idl.face 完美人生.apk 实际为旷视SDK，数据加密，怀疑就直接上传图片一次通信，没研究明白，没注销功能，不好重复测，应用为360加固 好医生.apk 百度sdk，仅活体识别不认证，照片直接url明文传输, 百度服务端返回结果直接使用，但无法注销 空仆.apk 功能不好测，先交钱 发现精彩.apk 银行金融类app，认证需先绑卡 申万宏源证券.apk 银行金融类app，无法启动 全民付.apk 应用无法启动 拍机堂.apk 人脸不好测，好像功能有问题 com.baidu.pass.biometrics.face.liveness.activity 百度百科.apk 人物百科助手.apk 宝宝知道.apk 百度智能云.apk 百度新闻.apk 百度大字版.apk 百度知道.apk 百度文库.apk 百度汉语.apk 百度网盘.apk 简单搜索.apk 贴吧极速版.apk 百度地图.apk 百度CarLife+.apk 百度地图关怀版.apk 百度手机卫士.apk 度小满金融.apk 百度浏览器.apk","categories":[{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"}],"tags":[{"name":"Face Security","slug":"Face-Security","permalink":"https://beichen.link/tags/Face-Security/"}]},{"title":"人脸实名认证-百度SDK系APP","slug":"Paper/SDK-Test/腾讯","date":"2023-01-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/01/15/Paper/SDK-Test/腾讯/","link":"","permalink":"https://beichen.link/2023/01/15/Paper/SDK-Test/%E8%85%BE%E8%AE%AF/","excerpt":"","text":"com.tencent.cloud.huiyansdkface.facelight.ui.FaceVerifyActivity 43个 腾讯体育.apk 前程无忧51Job.apk 安徽掌上10000.apk 店长直聘.apk 春雨诊所.apk 中国人保.apk 前程无忧51Job.apk 伴伴.apk 搜狐新闻.apk 优创.apk 环刷.apk 云小号.apk 人人直播.apk 王者营地.apk 伊对.apk 皮队友.apk 嘀嗒出行.apk 一嗨租车.apk 首汽约车.apk 旅程出租司机.apk 南京银行.apk 天下信用.apk 江苏长江商业银行.apk 鹏华A加钱包.apk 廊坊直销银行.apk 格上财富.apk 冠通掌中宝.apk 辽宁振兴银行.apk 掌上宏源.apk 蓝海银行.apk 格上基金.apk 东莞银行.apk BOSS直聘.apk 无双队友.apk 小米商城.apk 猫眼.apk 转转.apk 他趣.apk 汇金生态.apk 凤凰潮.apk 宇宙农场.apk 环球生态.apk com.webank.facelight.ui.FaceVerifyActivity 共60个 映客.apk 虎牙直播.apk 抱抱.apk 企鹅体育.apk 嗨8.apk FY短视频.apk 微视.apk 春秋航空.apk 格林.apk 春秋旅游.apk 凤凰会.apk 广安门医院.apk 微视.apk 蓝舞者.apk 芒果动听.apk 龟鼓.apk 撕歌.apk 千聊.apk 一只船教育.apk 三茅HR.apk 北极星招聘.apk 勤思必胜.apk 研达课堂.apk 哇雅.apk 圣世英学.apk 高铁管家.apk 钱夹谷谷.apk 探探.apk 珍爱.apk YY手游语音.apk 谁是凶手.apk 菜鸡.apk cosama二次元社区.apk 小鹿电竞.apk 航班管家.apk 吉祥航空.apk 油联天下.apk 5U打车司机端.apk 宝沃汽车.apk 拼客出行.apk 刷宝.apk 摇钱花.apk i云保.apk 国金期货.apk 乐刷极速版.apk 小雨伞.apk 中信期货.apk 青银村镇银行.apk 阿左旗黄河村镇银行.apk 陕西岐山长银村镇银行.apk 保险智能顾问.apk 徽常有财.apk 开心玩.apk 蘑菇街.apk 微店.apk 微拍堂.apk 顺联动力.apk 铁甲二手机.apk cdf海南免税.apk 蜘足链动.apk 妙伴生活.apk 遨天下.apk 悟喜生活.apk","categories":[{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"}],"tags":[{"name":"Face Security","slug":"Face-Security","permalink":"https://beichen.link/tags/Face-Security/"}]},{"title":"人脸实名认证-阿里SDK系APP","slug":"Paper/SDK-Test/阿里","date":"2023-01-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2023/01/15/Paper/SDK-Test/阿里/","link":"","permalink":"https://beichen.link/2023/01/15/Paper/SDK-Test/%E9%98%BF%E9%87%8C/","excerpt":"","text":"com.alibaba.security.biometrics.face.auth.FaceLivenessActivity 21个 土豆视频.apk 相当于优酷，抓不到包 氧秀直播.apk 饿了么.apk 饿了么商家版.apk 喵街.apk 和淘宝账号联动 我家瑜伽.apk 阿里云盾实人认证，oss，和momo一样(activity对不上)，但此应用需要身份证照片 饿了么.apk 喜马拉雅.apk 梆梆壳，一样阿里云盾，但是次数有限制2次 网易云音乐.apk 阿里卖家.apk 盯盯.apk 爱兑分.apk 360壳，阿里云盾实人认证，oss ，不需要身份证，注销后不可再登录 趣充.apk 赫兹.apk 阿里云盾实人认证，oss，和momo一样 爱心益动.apk 阿里小号.apk 盒马.apk 和淘宝账号联动 淘小铺.apk 打不开 一刻钟配送.apk 阿里云盾实人认证，oss，和momo一样 奢社.apk 应用进不去 CGD.apk 应用跑路 com.aliyun.identity.face.ui.FaceActivity 7个 美拍.apk 时味短视频.apk 嗨客短视频.apk 捞月狗.apk 美图秀秀.apk 美颜相机.apk 铁路12306.apk 得到.apk com.aliyun.aliyunface.ui.FaceLoadingActivity 27个 龙珠直播.apk 要手持身份证，寄 芝嫲视频.apk 亿园天下.apk 打不开 炫见.apk 无忧行.apk 一亩田.apk 云听.apk 猎聘.apk 开课吧.apk 乐享农业.apk 亮点云商.apk 微博.apk Soul.apk oss 一张图片+一段视频 偶派.apk 摩托范.apk 秒拍.apk oss 一张图片 黄河银行.apk 台州银行.apk 比心陪练.apk 腾讯系 乐享农业.apk 星聚汇.apk 董车长.apk 星辰大海.apk 掌趣生活.apk 广告太多进不去 佰惠橙选.apk 金派优选.apk 小熊易购.apk 应用跑路 com.aliyun.aliyunface.ui.ToygerActivity 6个 快看吧.apk 无法注册 天津银行.apk 客汇宝.apk oss，只有一张图片 七七商城.apk 全天候网络竞技.apk 谷多多.apk com.xhl.alipayfacecertifycomponent.AliFaceVertifyActivity 35个 新重庆.apk 看万州.apk 最江津.apk 掌上大足.apk 爱涪陵.apk 人人长寿.apk 巫溪.apk 翠翠秀山.apk 铜梁.apk 家在梁平.apk 巫山.apk 帅开州.apk 智慧云阳.apk 重庆荣昌.apk 见十.apk 掌新南岸.apk 忠义之州.apk 重庆江北.apk 幸福万盛.apk 酉州城事.apk 今日合川.apk 重庆垫江.apk 渝北掌媒.apk 武隆印象.apk 重庆渝中.apk 今日南川.apk 五彩石柱.apk 苗乡彭水.apk 缙享北碚.apk 永川头条.apk 大渡口之声.apk 爱璧山.apk 沙磁荟.apk 掌上城口.apk 奉节头条.apk 渝快办接口，先身份证后人脸，身份证oss 形式，oss key 抓包传输，但人脸为blob形式 com.alipay.face.ui.FaceLoadingActivity 20个 蜂鸟众包.apk 警察叔叔.apk 类似郑好办加密 ，有blob 淮安公积金.apk 苏州公积金.apk 贵港公积金.apk 园区社保中心.apk 需要社保信息，寄 蜻蜓主播.apk 类似郑好办，但图片base64不加密 学习强国.apk 爱山东济时通.apk 打不开 好签.apk 认证要钱 延强润杨司机.apk 没有人脸功能 花椒直播.apk 类似郑好办加密，但不blob PicoPico.apk 带带陪玩.apk 打不开，闪退 高德地图.apk 好运全程司机.apk 无法注册 花椒直播.apk 大象新闻.apk 找不到人脸功能 奇侠镇.apk 跑路 億家人.apk","categories":[{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"}],"tags":[{"name":"Face Security","slug":"Face-Security","permalink":"https://beichen.link/tags/Face-Security/"}]},{"title":"人脸识别-论文前期预调研","slug":"Paper/人脸识别-论文调研","date":"2022-08-26T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/08/26/Paper/人脸识别-论文调研/","link":"","permalink":"https://beichen.link/2022/08/26/Paper/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/","excerpt":"","text":"案例1：南都发布的《人脸识别应用场景合规报告》： 测评结果显示，20款App中，16款对个人信息作了信息加密和传输加密处理，另有4款娱乐特效App存在问题。其中，“趣演”没有对人脸信息进行加密处理，用户的换脸视频的链接可被公开访问。这意味着，换脸视频可能被任何人获取。“ZAO”、“更美”、“新氧医美”等3款App，尽管使用了HTTPS安全传输协议，但没有对数据本身加密，导致用户人脸照片等信息被上传服务器后，服务器返回链接可被互联网公开访问。这意味着，攻击者一旦截获传输数据包，就将获得用户的一系列敏感个人信息。 案例2：「00 后」攻破厦门银行人脸识别系统，伪造76个假账户。 银行APP未防止重放攻击，攻击者进行人脸识别步骤时，利用软件抓包技术将银行系统下发的人脸识别身份认证数据包进行拦截并保存。 APP人脸识别本地运算，手机客户端从服务器端获取了黑客本人的高清身份照，和黑客手机摄像头采集的黑客本人照片做了比对，通过后的结果加密在一起上传，这个加密包被截获后，太容易重放攻击了。 研究现状 J. Im, S. Jeon and M. Lee, “Practical Privacy-Preserving Face Authentication for Smartphones Secure Against Malicious Clients,” in IEEE Transactions on Information Forensics and Security, vol. 15, pp. 2386-2401, 2020, doi: 10.1109&#x2F;TIFS.2020.2969513. 人脸识别二阶段：注册和验证。 注册时，客户端生成密钥对，使用公钥加密人脸特征向量，公钥和请求标识符一起发送给服务器，服务器存储加密的生物特征 验证时，同样上传加密人脸特征向量，服务器利用同态加密计算两个加密特征向量之间的匹配分数，进行图像比对并发送验证结果。 生物特征的同态加密:同态加密的主要吸引力在于能够在加密域内执行基本的算术运算，如加法和乘法。 Šedenka J,Govindarajan S,Gasti P,et al.Secure outsourced biometric authentication with performance evaluation on smartphones[J].IEEE Transactions on Information Forensics and Security,2014,10(2):384-396. 安全两方计算是指在没有可信任第三方的情况下，两个互相不信任的参与方在均不泄露本身私有信息的前提下，通过合作计算来完成对整体数据的分析，以得到自己想要的结果。混淆电路是安全两方计算公共函数f最有效的协议之一。 客户端与服务端通过混淆电路比对加密存储在数据库里的人脸图像。 K. Zhou and J. Ren, “PassBio: Privacy-Preserving User-Centric Biometric Authentication,” in IEEE Transactions on Information Forensics and Security, vol. 13, no. 12, pp. 3050-3063, Dec. 2018, doi: 10.1109&#x2F;TIFS.2018.2838540. 阈值谓词加密(TPE)方案可以加密两个向量x和y，通过这种方式，x和y的内积可以被计算并与预定义的阈值进行比较。TPE只显示比较结果，不能学习x和y的关键信息。 谓词加密技术保证加密消息的安全性，同时保护查询关键字的隐私。 Abidin, Aysajan. (2016). On Privacy-Preserving Biometric Authentication. 10.1007&#x2F;978-3-319-54705-3_11. 三方模型：客户端、服务端、密码服务提供者(cryptographic service provider[ CSP)] )负责保存私钥并协助服务器完成人脸验证。 三方模型下基于加法同态加密的保护隐私的人脸验证算法 F. Toutara and G. Spathoulas, “A distributed biometric authentication scheme based on blockchain,” 2020 IEEE International Conference on Blockchain (Blockchain), 2020, pp. 470-475, doi: 10.1109&#x2F;Blockchain50366.2020.00068. 第三方对用户进行身份验证，主要是以太坊智能合约和分布式文件系统实例 客户端同态加密生物特征向量，生成一组特征模板并上传到以太坊智能合约中，客户端保存每个模板的密钥 验证时第三方随机选择模板，客户端使用选定的模板id产生新的加密特征向量并发送第三方比对 Y. He, G. Dong, D. Liu, Y. Hao, H. Peng and Y. Chen, “A secure face authentication scheme based on honeypot technology,” 2021 6th International Conference on Communication, Image and Signal Processing (CCISP), 2021, pp. 129-133, doi: 10.1109&#x2F;CCISP52774.2021.9639321. 采用随机投影技术对原始人脸特征数据进行加密 采用fuzzy commitment完成人脸身份认证，数据库里只存储hash 蜜罐模板检测生物特征模板是否数据泄漏","categories":[{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"}],"tags":[{"name":"Face Security","slug":"Face-Security","permalink":"https://beichen.link/tags/Face-Security/"}]},{"title":"Arm服务器上运行Android Emulator","slug":"LAB/Emulator/arm emulator","date":"2022-07-15T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/07/15/LAB/Emulator/arm emulator/","link":"","permalink":"https://beichen.link/2022/07/15/LAB/Emulator/arm%20emulator/","excerpt":"","text":"安装emulator 尝试下载Android sdk，通过命令行工具创建AVD，但运行AVD时提示emulator不支持本机架构。 尝试在arm服务器上运行Android Studio的AVD，更新初始sdk后发现AS上下载的sdk只适配了x86的emulator，arm服务器上一旦创建虚拟机就会卡死。 尝试直接在服务器上编译源码，再运行AOSP原生emulator，但下载源码后提示无法编译，lunch时出现 error : android10&#x2F;prebuilts&#x2F;go&#x2F;linux-x86&#x2F;&#x2F;bin&#x2F;go: cannot execute binary file: Exec format error 尝试解决但失败，后尝试用docker搭建Android10编译环境，未成功。最后发现AOSP源码编译只能在x86机器上进行，放弃。 最后在github上找到arm版emulator，地址：https://github.com/google/android-emulator-container-scripts/issues/192，移植到sdk后再运行AS的avd成功，但会提示kvm 服务不可用，AS运行emulator也会卡死。尝试命令行运行创建好的虚拟机，报错，但error提示了解决kvm的办法，运行 sudo gpasswd -a $USER kvm &#x2F;&#x2F;赋予运行kvm的权限 结果提示kvm服务成功运行。接下来出现新的error: error：qt.qpa.plugin: Could not load the Qt platform plugin “xcb“ even though it was found. 发现是Qt加载插件出现问题，通过设置QT_DEBUG_PLUGINS&#x3D;1，可以查看Qt的插件加载信息。所以设置环境变量： export QT_DEBUG_PLUGINS&#x3D;1 再次运行程序时，会打印出很多信息，细节是提示了: plugins&#x2F;platforms&#x2F;libqxcb.so: (libxkbcommon-x11.so.0: cannot open shared object file: No such file or directory ​ google后找到解决方案：运行 sudo apt install pyqt5-dev-tools pyqt5-dev 后成功解决error。​ 附未知效果的依赖包安装命令： 1sudo apt-get install -y --no-install-recommends libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev g++-aarch64-linux-gnu gcc-aarch64-linux-gnu git build-essential python qemu-kvm ninja-build ccache libgl1-mesa-glx lz4 libc6 adb unzip xcb xfce4 xfce4-goodies tree libpcre2-16-0 cpu-checker qemu-kvm libaio1 libaio-dev ​ 最后，成功运行arm emulator ： 12cd download/android-sdk-linux/emulator./emulator -avd Pixel_3a_XL_API_29 -qemu -cpu max -machine gic-version=max 待解决的问题： 安装应用部分能安装，部分安装失败，adb报error:INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res&#x3D;-113. 能安装：小红书 沪江网校 个人所得税 美团外卖 b站 微信 得物 咪咕阅读 闲鱼 不能安装： 抖音 银行类app 夸克浏览器 qq音乐 qqHD 百度贴吧 微博 momo 知乎 mooc emulator显示界面模糊，原因未知。 自定义运行emulator针对前述部分应用不能安装的情况，判断是AS上AVD创建的是Aarch64-v8的虚拟机，经测试，不可兼容armeabi-v7的apk。 问：为什么最开始尝试的时候选择AS上AVD？答：主要是由于SDK的问题，命令行创建avd需要对应版本的andrid sdk，同时也需要指定avd运行的arm img，自己去单独下载较为麻烦，交给AS刚好，但AS上只能指定 arm64-v8的系统image，同时以上完成的启动emulator需要两个附加参数，AS无法启动时附加，故之前选取的方案是在AS上创建avd，再在命令行内加入附加参数启动emulator。 为解决此问题，尝试找到一种不用通过AS上AVD创建虚拟机的方法，也就是编译源码后输出SDK，既可以自修改虚拟机img，又可命令行创建AVD。 编译AOSP输出SDK lunch时选择aosp_arm-eng（为armv7，aosp_arm64-eng就是v8），然后make sdk。编译成功后，在android-10.0.0_r33&#x2F;out&#x2F;host&#x2F;linux-x86&#x2F;sdk&#x2F;sdk&#x2F;android-sdk_eng.xiehao_linux-x86下即为SDK产品，目录结构接近AS使用的sdk，但少了tools与emulator子目录。 &#x2F;tools&#x2F;bin目录下存放着 avdmanager 与 sdkmanager 两个关键命令，进入bin目录下运行 .&#x2F;avdmanager 与 .&#x2F;sdkmanager 即可启动。 而&#x2F;emulator目录下存放着emulator命令，进入此目录下运行 .&#x2F;emulator 即可启动。 复制此 SDK 至 arm 服务器下，并将AS链接的sdk文件夹里的tools、emulator（arm版）文件夹拷贝过去，至此一个完整的可运行arm emulator的android sdk就设置好了。 SDK创建AVD 在编译好的SDK目录下，执行以下代码即可创建AVD，并运行arm emulator： 12345678cd mysdk/tools/bin## sdk的system-image目录下只有android-10这个子目录，但创建avd时参数为system-images;android-29;default;armeabi-v7a，同时config.ini中sys.dir也显示为android-10./avdmanager create avd -n xiehao -k &#x27;system-images;android-29;default;armeabi-v7a&#x27; ./avdmanager list avd ## 查看已创建的AVD信息cd ../../emulator./emulator -avd xiehao -qemu -cpu max -machine gic-version=max &amp;adb devices -l ##当有多个emulator同时运行时查看其编号adb -t 5 logcat * | grep &quot;mytag&quot; ## 查看指定编号的emulator日志 我们也可在AS创建AVD的基础上更改config.ini的参数，指定 image.sysdir.1 路径，这样就能让emulator使用我们自编译的img，即image.sysdir.1=/home/xiehao/download/mysdk/system-images/android-10/armeabi-v7a","categories":[{"name":"Emulator","slug":"Emulator","permalink":"https://beichen.link/categories/Emulator/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"AOSP对抗模拟器检测","slug":"LAB/Emulator/anti-Emulator","date":"2022-07-10T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/07/10/LAB/Emulator/anti-Emulator/","link":"","permalink":"https://beichen.link/2022/07/10/LAB/Emulator/anti-Emulator/","excerpt":"","text":"检测点1：qemu检测qemu模拟器上特有文件 qemu_pipe：hasQumuPipes: {“&#x2F;dev&#x2F;socket&#x2F;qemud”, “&#x2F;dev&#x2F;qemu_pipe”} qemu pipe是一个通用的虚拟设备，用于提供guest os和emulator通信的功能，类似于一个抽象的通信层，这样就不用写很多虚拟设备了；而Android img中的&#x2F;dev&#x2F;socket&#x2F;qemud是用来和qemu虚拟机中的&#x2F;system&#x2F;bin&#x2F;qemud通信的 1234567public static boolean hasPipes() &#123; for (String pipe : known_pipes) &#123; File qemu_socket = new File(pipe); if (qemu_socket.exists()) &#123; log(&quot;pip is &quot;+pipe); return true; &#125; 对抗思路： 既然检测代码是通过File.exist()判断是否存在这些特有文件，那么是不是可以通过修改AOSP源码JAVA层里的File.exist()函数体返回值对抗。而File.exist()源码位于AOSP&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;io&#x2F;File.java libcore是Android Java核⼼类库，是 Android 系统中支持但本身不属于 Android的 Java 库。Android 系统中支持众多 Java 标准的库，例如 java.lang 包。这部分内容由 libcore 来提供。luni 实际上是 lang、util、net、io 这 4 个内容头字母的组合，Java 中主要类库模块的首字母组合，表示 Java 语言最为核心部分的内容。 子工程目录 描述 luni Java 基础包、扩展包、组织提供的类库等 libart art 运行时部分相关包 dalvik dalvik 虚拟机相关的包 dom 文档对象模型 json json 串在 Java 中的支持 xml XML工具 ojluni Open JDK 版的 Java 包 File.exist()修改后如下： 1234567891011121314public boolean exists() &#123; SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkRead(path); &#125; if (isInvalid()) &#123; return false; &#125; ++ if (path.contains(&quot;qemu_pipe&quot;))&#123; logger.info(&quot;FILE.isExist()-------pipe&quot;); return false; &#125; return fs.checkAccess(this, FileSystem.ACCESS_OK);&#125; //在815行 检测点2：网络运营商检测移动网络运营商：checkOperatorNameAndroid() 虚拟机的手机运营商一般都是 “android”，测试的时候记得要授予软件电话权限。 123TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);String operatorName = telephonyManager.getNetworkOperatorName(); if (operatorName.equalsIgnoreCase(&quot;android&quot;)) 对抗思路： 同样是修改TelephonyManager.java里的getNetworkOperatorName()实现，路径为AOSP&#x2F;frameworks&#x2F;base&#x2F;telephony&#x2F;java&#x2F;android&#x2F;telephony&#x2F;TelephonyManager.java。代码修改如下： 1234public String getNetworkOperatorName() &#123; -- return getNetworkOperatorName(getSubId()); return &quot;中国联通&quot;; &#125; 检测点3：传感器检测是否存在光传感器： checkLightSensor() 由于光传感器模拟器不容易伪造，市面上的安卓模拟器大部分也不存在光传感器，所以可通过判断设备是否存在光传感器来判断是否为模拟器。但实际操作中对于Android原生emulator，此检测方法不合适。 12345678910111213public static Boolean checkLightSensorManager(Context context)&#123; SensorManager sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE); Sensor sensor8 = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT); //光 if (null == sensor8) &#123; return true; &#125; else &#123; Log.d(&quot;sensor&quot;,&quot; &quot;+sensor); return false; &#125;&#125; AS模拟器运行结果显示此模拟器存在light sensor，检测方法失效，log： 12345678Sensor name=&quot;Goldfish Light sensor&quot;, vendor=&quot;The Android Open Source Project&quot;, version=1, type=5, maxRange=40000.0, resolution=1.0, power=20.0, minDelay=10000 ​ 从上面流程来看，首先我们要获取sensorservice，然后创建一个SensorManager，再从SensorManager从获取到具体传感器。 framework层，SensorService代码在frameworks\\base\\services\\sensorservice\\SensorService.cpp中，app中通过getSystemService()方法可以访问到getSystemService。 SensorManager代码在frameworks\\base\\core\\java\\android\\hardware\\SensorManager.java中，但未涉及lightSensor相关代码，最后在device&#x2F;generic&#x2F;goldfish&#x2F;sensors&#x2F;sensors_qemu.c找到此sensor信息。 1234567891011121314151617&#123; .name = &quot;Goldfish Light sensor&quot;, .vendor = &quot;The Android Open Source Project&quot;, .version = 1, .handle = ID_LIGHT, // 传感器id标识 .type = SENSOR_TYPE_LIGHT, .maxRange = 40000.0f, //传感器值变化的最大范围 .resolution = 1.0f, //要报告的传感器数据的最小差异 .power = 20.0f, //近似功耗 .minDelay = 10000, //最小延时 .maxDelay = 500 * 1000, .fifoReservedEventCount = 0, //预留event数量 .fifoMaxEventCount = 0, .stringType = &quot;android.sensor.light&quot;, .requiredPermission = 0, .flags = SENSOR_FLAG_ON_CHANGE_MODE, .reserved = &#123;&#125;&#125;, 尝试在sensors_qemu.c文件里改动此sensor属性，重新编译后打印日志如下： 1234Sensor name=&quot;xiehao_light&quot;, vendor=&quot;me&quot;, version=38, power=40.0,","categories":[{"name":"Emulator","slug":"Emulator","permalink":"https://beichen.link/categories/Emulator/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"emulator检测原理","slug":"LAB/Emulator/emulator检测原理","date":"2022-07-07T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/07/07/LAB/Emulator/emulator检测原理/","link":"","permalink":"https://beichen.link/2022/07/07/LAB/Emulator/emulator%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86/","excerpt":"","text":"分析检测点 检测设备信息 ——- 检测特征多，但可修改源码伪造，有效 Build.FINGERPRINT.startsWith(&quot;generic&quot;) 唯一识别码 Build.MODEL.contains(&quot;google_sdk&quot;) 版本 Build.MANUFACTURER.contains(&quot;Genymotion&quot;) 硬件制造商 Build.HARDWARE.equals(&quot;goldfish&quot;) 硬件名称 Build.PRODUCT.equals(&quot;sdk_x86&quot;) 产品的名称 检测包名 ——– 根据包名判断Intent能否被解析 ，无效 mListPackageName.add(&quot;com.google.android.launcher.layouts.genymotion&quot;); mListPackageName.add(&quot;com.bluestacks&quot;); mListPackageName.add(&quot;com.bignox.app&quot;); 检测移动网络运营商 ——- 虚拟机的手机运营商一般都是 android，有效 123TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);String operatorName = telephonyManager.getNetworkOperatorName(); if (operatorName.equalsIgnoreCase(&quot;android&quot;)) 检测模拟器上特有文件qemu_pipe ——-通用的虚拟设备，用于提供guest os和emulator通信的功能，类似于一个抽象的通信层，有效 ​ hasQumuPipes: &#123;&quot;/dev/socket/qemud&quot;, &quot;/dev/qemu_pipe&quot;&#125; 1234567public static boolean hasPipes() &#123; for (String pipe : known_pipes) &#123; File qemu_socket = new File(pipe); if (qemu_socket.exists()) &#123; log(&quot;pip is &quot;+pipe); return true; &#125; ​ 如果是x86架构的话，还会检测x86特征文件，方法同上 检测虚拟机驱动 ——–读取驱动文件, 检查是否包含已知的qemu驱动，无效 123for (File drivers_file : new File[]&#123;new File(&quot;/proc/tty/drivers&quot;), new File (&quot;/proc/cpuinfo&quot;)&#125;)-------------------------if (driver_data.contains(known_qemu_driver)) // goldfish checkLightSensor ——检测是否存在光传感器，无效 12345678910111213public static Boolean checkLightSensorManager(Context context)&#123; SensorManager sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE); Sensor sensor8 = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT); //光 if (null == sensor8) &#123; return true; &#125; else &#123; Log.d(&quot;sensor&quot;,&quot; &quot;+sensor8); return false; &#125;&#125; AS模拟器运行结果显示此模拟器存在light sensor，检测方法失效，log： 12345678Sensor name=&quot;Goldfish Light sensor&quot;, vendor=&quot;The Android Open Source Project&quot;, version=1, type=5, maxRange=40000.0, resolution=1.0, power=20.0, minDelay=10000 ​ 从上面流程来看，首先我们要获取sensorservice，然后创建一个SensorManager，再从SensorManager从获取到具体传感器。​ framework层，SensorService代码在frameworks\\base\\services\\sensorservice\\SensorService.cpp中，app中通过getSystemService()方法可以访问到getSystemService，SensorManager代码在frameworks\\base\\core\\java\\android\\hardware\\SensorManager.java中，但未涉及lightSensor相关代码，最后在device/generic/goldfish/sensors/sensors_qemu.c找到此sensor信息。 1234567891011121314151617&#123; .name = &quot;Goldfish Light sensor&quot;, .vendor = &quot;The Android Open Source Project&quot;, .version = 1, .handle = ID_LIGHT, // 传感器id标识 .type = SENSOR_TYPE_LIGHT, .maxRange = 40000.0f, //传感器值变化的最大范围 .resolution = 1.0f, //要报告的传感器数据的最小差异 .power = 20.0f, //近似功耗 .minDelay = 10000, //最小延时 .maxDelay = 500 * 1000, .fifoReservedEventCount = 0, //预留event数量 .fifoMaxEventCount = 0, .stringType = &quot;android.sensor.light&quot;, .requiredPermission = 0, .flags = SENSOR_FLAG_ON_CHANGE_MODE, .reserved = &#123;&#125;&#125;, 尝试在sensors_qemu.c文件里改动此sensor属性，.name = &quot;xiehao_light&quot;, .vendor = &quot;me&quot;, .version = 38,重新编译后打印日志如下： 1234Sensor name=&quot;xiehao_light&quot;, vendor=&quot;me&quot;, version=38, power=40.0,","categories":[{"name":"Emulator","slug":"Emulator","permalink":"https://beichen.link/categories/Emulator/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android Property分析","slug":"LAB/AOSP/Android-property分析","date":"2022-05-14T15:05:16.000Z","updated":"2023-12-07T09:39:19.743Z","comments":true,"path":"2022/05/14/LAB/AOSP/Android-property分析/","link":"","permalink":"https://beichen.link/2022/05/14/LAB/AOSP/Android-property%E5%88%86%E6%9E%90/","excerpt":"","text":"一、Android Property介绍 Property Service Android 中有很多 Property，他们无处不在，我们的熟悉的 android.os.Build 中的很多字段都是直接读取的对应的 Property 值。Property 都是以键值对的形式存在，键和值都是字符串类型，他们是全局的（各个进程看到的都一样），Android 中非常多的进程和应用直接或者间接依赖 Property 系统，并由此决定其运行期的行为。Property 实质上是由若干个属性读取进程和一个属性设置进程（Property Service）操作。 Property Service 位于 init 进程（拥有 root 权限），在系统开机后创建各个属性对应的内存映射文件，即分配一个共享内存区来存储的属性。各个 App 进程想获得属性信息可以使用对应的内存映射文件，直接从共享内存读取，为上层的 property api 提供数据来源。 Property Tree 属性共享内存中的内容，其实被组织成一棵字典树。内存块的第一个节点是个特殊的总述节点，类型为 prop_area。紧随其后的就是字典树的“树枝”和“树叶”了，树枝以 prop_bt 表达，树叶以 prop_info 表达。我们读取或设置属性值时，最终都只是在操作“叶子”节点而已。 每一个映射文件都是一个 128K 大小的二进制文件，以 prop_area 结构开头，它代表着共享内存块的起始，属性名将以‘.’符号为分割符，被分割开来。比如 ro.secure 属性名就会被分割成“ro”和“secure”两部分，而且每个部分用一个 prop_bt 节点表达。属性名中的这种‘.’关系被表示为父子关系，当一个属性名对应的“字典树枝”都已经形成好后，会另外创建一个 prop_info 节点，专门表示这个属性，该节点就是“字典树叶”。 Property属性组成 Android 的系统属性包括两部分：文件保存的持久属性和每次开机导入的cache属性。前者主要保存在prop文件中，需要注意的是android属性的名称是有一定的格式要求的。ro.开头的属性将不能被更改属性值，persist.开头的属性会被永久记录，其他属性值在重新开机后均将被丢弃。 属性名以ro.开头，该属性被视为只读属性，一旦设置属性值不能改变； 属性名以persist.开头，该属性值将写入&#x2F;data&#x2F;property； 属性名以net.开头，当设置这个属性时，“net.change”属性将会自动设置，以加入到最后修改的属性名。 Property属性的加载 Android的启动后，在 property_service.cpp 的 property_init 中完成 prop 的初始化。系统中存在着几个文件，如 build.prop 和 default.prop 等，这些文件是在系统构建时候生成的，里面包含很多系统的配置。属性服务启动后会从系统文件中读取默认的属性，并写入共享内存中，并且后读入的属性将覆盖前面读取的相同的属性。也就是说，系统开机时会去加载这些文件中的信息并保存到 prop 模块(内存)中去，以便其它程序进行读取和使用。 系统启动的时候会从几个配置文件中加载属性的默认值，大概有以下几个文件， 在不同 Android 版本系统上可能不一样： &#x2F;default.prop 或者是 &#x2F;prop.default， &#x2F;vendor&#x2F;default.prop &#x2F;system&#x2F;build.prop &#x2F;vendor&#x2F;build.prop &#x2F;data&#x2F;local.prop &#x2F;data&#x2F;property&#x2F;* 系统会按先后顺序依次加载以上文件，后加载的属性将覆盖原先的值。default.prop 的值是通过 build&#x2F;tools 目录下的 buildinfo.sh 生成的。要修改的话，就要修改编译系统了，这种方法不好维护，不推荐。一般来说我们可以把属性加到 &#x2F;system&#x2F;build.prop 或者 &#x2F;vendor&#x2F;build.prop。 二、Property prop文件的生成Android 编译时会收集各种property值，编译完成之后，文件生成在out&#x2F;target&#x2F;product&#x2F;system 目录下。在Android运行时刻可以通过property_get()[c&#x2F;c++]或 SystemProperties_get()[Java]读取这些属性值。以build.prop文件为例，build.prop的生成是由make系统解析build&#x2F;core&#x2F;Makefile完成。 Makefile中首先定义各种变量，这在下一步执行时会用到。比如： 12PRODUCT_DEFAULT_LANGUAGE=&quot;$(calldefault-locale-language,$(PRODUCT_LOCALES))&quot; \\PRODUCT_DEFAULT_REGION=&quot;$(calldefault-locale-region,$(PRODUCT_LOCALES))&quot; \\ Makefile中调用build&#x2F;tools&#x2F;buildinfo.sh执行脚本，echo一些属性并输出到build.prop，如ro.product.locale.language&#x2F; ro.product.locale.region就是些属性，等号后面是值。 12echo&quot;ro.product.locale.language=$PRODUCT_DEFAULT_LANGUAGE&quot;echo&quot;ro.product.locale.region=$PRODUCT_DEFAULT_REGION&quot; Makefile中直接把$(TARGET_DEVICE_DIR)&#x2F;system.prop的内容追加到build.prop中。 收集ADDITIONAL_BUILD_PROPERTIES中的属性，追加到build.prop中。 ADDITIONAL_BUILD_PROPERTIES又会收集PRODUCT_PROPERTY_OVERRIDES中定义的属性。 123ADDITIONAL_BUILD_PROPERTIES:= \\ $(ADDITIONAL_BUILD_PROPERTIES)\\ $(PRODUCT_PROPERTY_OVERRIDES) 总结：build.prop的生成是由make系统解析build&#x2F;core&#x2F;Makefile完成，关于build.prop生成过程的分析，可知属性的来源： buildinfo.sh ：系统默认属性一般在build&#x2F;tool&#x2F;buildinfo.sh，编译时写到文件 build.prop； system.prop追加； ADDITIONAL_BUILD_PROPERTIES 或 PRODUCT_PROPERTY_OVERRIDES追加；一般我们自定义属性就在对应的项目下 device&#x2F;$(TARGET_DEVICE_DIR)&#x2F;system.prop 定义自己的属性即可，建议修改属性在 system.prop 或 PRODUCT_PROPERTY_OVERRIDES，这对应于具体特定平台或产品的修改。 三、Android系统属性获取跟踪在 Android 应用程序开发中，可以通过 android.os.Build 类来访问一些属性信息，如设备品牌，设备名称，CPU 信息等。我们以使用 Build.BRAND 获取brand信息来分析 Android 系统中是如何获取属性信息的。 android.os.Build类 android.os.Build.java 源码位于 &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;Build.java，BRAND 的定义如下： 12/** The name of the underlying board, like &quot;goldfish&quot;. */public static final String BOARD = getString(&quot;ro.product.board&quot;); 从上述代码易知，BRAND 值是通过调用类方法 getString(“ro.product.brand”)来获取的，而 getString 代码如下： 1234@UnsupportedAppUsageprivate static String getString(String property) &#123; return SystemProperties.get(property, UNKNOWN);&#125; android.os.SystemProperties类 再往下，getString 通过 SystemProperties 类(即&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;SystemProperties.java)的 get(String key, String def) 获取对应属性信息，该函数代码如下： 123456789101112/** * Get the String value for the given &#123;@code key&#125;. * @param key the key to lookup * @param def the default value in case the property is not set or empty * @return if the &#123;@code key&#125; isn&#x27;t found, return &#123;@code def&#125; if it isn&#x27;t null, or an empty * string otherwise * @hide */public static String get(@NonNull String key, @Nullable String def) &#123; if (TRACK_KEY_ACCESS) onKeyAccess(key); return native_get(key, def);&#125; 也就是会调用 Native Code，对应 key 的 value 值为空则默认为 string def。在 SystemProperties.java 内有相应 Native 方法声明。 android_os_SystemProperties.cpp Native Code 对应的具体实现为 SystemProperties_getSS 方法，路径为 frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_os_SystemProperties.cpp，如下： 1234567891011121314151617jstring SystemProperties_getSS(JNIEnv *env, jclass clazz, jstring keyJ,jstring defJ)&#123; // Using ConvertKeyAndForward is sub-optimal for copying the key string, // but improves reuse and reasoning over code. auto handler = [&amp;](const std::string&amp; key, jstring defJ) &#123; std::string prop_val = android::base::GetProperty(key, &quot;&quot;); if (!prop_val.empty()) &#123; return env-&gt;NewStringUTF(prop_val.c_str()); &#125;; if (defJ != nullptr) &#123; return defJ; &#125; // This function is specified to never return null (or have an // exception pending). return env-&gt;NewStringUTF(&quot;&quot;);&#125;;return ConvertKeyAndForward(env, keyJ, defJ, handler);&#125; 注意里面的 android::base::GetProperty(key, “”) 方法，获取属性值并存入到 prop_val 里。 properties.cpp GetProperty 方法位于 &#x2F;system&#x2F;core&#x2F;base&#x2F;properties.cpp，起作用的是 __system_property_find 函数。 GetProperty函数的内部逻辑，会根据 __BIONIC__这个宏是否定义，分两个不同的逻辑。可以看到如果该宏已定义的话，会继续调用 __system_property_find,；如果该宏未定义，则从全局变量 g_properties中读取 property_value值。 123456789101112131415161718192021std::string GetProperty(const std::string&amp; key, const std::string&amp; default_value) &#123;std::string property_value;#if defined(__BIONIC__)const prop_info* pi = __system_property_find(key.c_str());if (pi == nullptr) return default_value;__system_property_read_callback(pi, [](void* cookie, const char*, const char* value, unsigned) &#123; auto property_value = reinterpret_cast&lt;std::string*&gt;(cookie); *property_value = value; &#125;, &amp;property_value);#elseauto it = g_properties.find(key);if (it == g_properties.end()) return default_value;property_value = it-&gt;second;#endif// If the property exists but is empty, also return the default value.// Since we can&#x27;t remove system properties, &quot;empty&quot; is traditionally// the same as &quot;missing&quot; (this was true for cutils&#x27; property_get).return property_value.empty() ? default_value : property_value;&#125; system_property_api.cpp 方法 GetProperty 会继续调用__system_property_find。__system_property_find 实现在bionic&#x2F;libc&#x2F;bionic&#x2F;system_property_api.cpp中: 1234__BIONIC_WEAK_FOR_NATIVE_BRIDGEconst prop_info* __system_property_find(const char* name) &#123;return system_properties.Find(name);&#125; system_properties是一个全局对象，对应的类为SystemProperties: 123static SystemProperties system_properties;static_assert(__is_trivially_constructible(SystemProperties), &quot;System Properties must be trivially constructable&quot;); system_properties.cpp SystemProperties 类实现在bionic&#x2F;libc&#x2F;system_properties&#x2F;system_properties.cpp中， 实现代码比较多， 我们直接看Find方法的实现： 1234567891011const prop_info* SystemProperties::Find(const char* name) &#123;if (!initialized_) &#123; return nullptr;&#125;prop_area* pa = contexts_-&gt;GetPropAreaForName(name);if (!pa) &#123; async_safe_format_log(ANDROID_LOG_ERROR, &quot;libc&quot;, &quot;Access denied finding property \\&quot;%s\\&quot;&quot;, name); return nullptr;&#125;return pa-&gt;find(name);&#125; Find 方法调用成员变量contexts_的 GetPropAreaForName 方法来获取一个prop_area，也就是从存放属性值的共享内存块中读取。如果无法获取，则打印 Access denied finding property日志。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android-JNI","slug":"LAB/AOSP/Android-JNI层与so库","date":"2022-05-07T00:00:00.000Z","updated":"2023-12-07T09:39:19.743Z","comments":true,"path":"2022/05/07/LAB/AOSP/Android-JNI层与so库/","link":"","permalink":"https://beichen.link/2022/05/07/LAB/AOSP/Android-JNI%E5%B1%82%E4%B8%8Eso%E5%BA%93/","excerpt":"","text":"一、JNI介绍JNI是Java Native Interface的缩写，中文为JAVA本地调用。通过它可以做到Java与C&#x2F;C++代码互调。 Java程序中的函数可以调用Native语言写的函数，Native一般指的是C&#x2F;C++编写的函数。 Native程序中的函数可以调用Java层的函数，也就是说在C&#x2F;C++程序中可以调用Java的函数。 在Android平台中，JNI就是一座将Native和Java连接起来的桥梁，将两种语言紧密地联系在了一起。 二、JNI实例分析：MediaPlayer在Android中，主要的JNI代码在以下的路径中：AOSP&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;，这个路径中的内容将被编译成库libandroid_runtime.so，这就是一个普通的动态库，被放置在目标系统的&#x2F;system&#x2F;lib目录中。 除此之外，Android还包含其他的JNI库，例如，媒体部分的JNI目录frameworks&#x2F;base&#x2F;media&#x2F;jni&#x2F;中，被编译成库文件libmedia_jni.so。 以Java层的MediaPlayer类为例： Java层对应的是MediaPlayer类，类中有一些函数需要由Native层来实现。 JNI层对应的是libmedia_jni.so，media_jni是JNI库的名字。其中，下划线前的“media”是Native层库的名字。下划线后的“jni”表示它是一个JNI库。注意，JNI库的名字可以随便取，不过Android平台基本上都采用“lib模块名_jni.so”的命名方式。JNI中的各个文件实际上就是C++的普通文件，其命名一般 和支持的Java类有对应关系。这种关系是习惯上的写法，而不是强制的。 Native层对应的是libmedia.so，这个库完成了实际的功能。 三、MediaPlayer的Java层MediaPlayer将通过JNI库libmedia_jni.so和Native层的libmedia.so交互。从上面的分析中还可知道：JNI层必须实现为动态库的形式，这样Java虚拟机才能加载它并调用它的函数。 上面代码中列出了两个比较重要的要点： 一个是加载JNI库； 另一个是Java的native函数。 前面说过，如果Java要调用native函数，就必须通过一个位于JNI层的动态库来实现。顾名思义，动态库就是运行时加载的库，那么在什么时候以及什么地方加载这个库呢？ 这个问题没有标准答案，原则上是：在调用native函数前，任何时候、任何地方加载都可以。通行的做法是在类的static语句中加载，调用System.loadLibrary方法就可以了。这一点在上面的代码中也见到了，我们以后就按这种方法编写代码即可。 另外，System.loadLibrary函数的参数是动态库的名字，即media_jni。系统会自动根据不同的平台拓展成真实的动态库文件名，例如在Linux系统上会拓展成libmedia_jni.so，而在Windows平台上则会拓展成media_jni.dll。 从上面代码中可以发现，native_init函数前有Java的关键字native，它表示这个函数将由JNI层来实现。 四、MediaPlayer的JNI层native_init函数位于android.media这个包中，它的全路径名应该是android.media.MediaPlayer.native_init，而JNI层函数的名字是android_media_MediaPlayer_native_init。 因为在Native语言中，符号“.”有着特殊的意义，所以JNI层需要把Java函数名称（包括包名）中的“.”换成“_”。也就是通过这种方式，native_init找到了自己JNI层的本家兄弟android.media.MediaPlayer.native_init。 那问题来了，如何才能知道Java层的native_init函数对应的是JNI层的android_media_MediaPlayer_native_init(JNIEnv *env)函数呢？ 答案是通过注册JNI函数。 “注册”之意就是将Java层的native函数和JNI层对应的实现函数关联起来，有了这种关联，调用Java层的native函数时，就能顺利转到JNI层对应的函数执行了。而JNI函数的注册方法实际上有两种：静态注册与动态注册。但在Android 源码开发环境下，大多采用显式注册native方法，NDK开发模式下一般采用隐式注册native函数。以下只介绍JNI显式注册方法。 应用层的Java类一般是通过VM去寻找*.so里的native函数。如果需要连续调用很多次，每次都需要寻找一遍，会多花许多时间。此时，如果可以将native函数向VM进行注册，就能加快后续调用native函数的效率。 既然Java native函数和JNI函数是一一对应的，那么是不是会有一个结构来保存这种关联关系呢？答案是肯定的。在JNI技术中，用来记录这种一一对应关系的，是一个叫JNINativeMethod的结构，其定义如下： 1234567891011//源码位于：libnativehelper/include_jni/jni.htypedef struct &#123; // Java中native函数的名字，不用携带包的路径，例如“native_init”。 const char* name; // Java函数的签名信息，用字符串表示，是参数类型和返回值类型的组合。 const char* signature; // JNI层对应函数的函数指针，注意它是void*类型。 void* fnPtr;&#125; JNINativeMethod; 其中比较难以理解的是第二个参数，例如: “()V”，”(II)V”，”(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)V” 实际上这些字符是与函数的参数类型一一对应的。”()” 中的字符表示参数，后面的则代表返回值。例如”()V” 就表示void Func();”(II)V” 表示 void Func(int, int)。具体的每一个字符的对应关系如下：（数组则以”[“开始，用两个字符表示。） 字符 Java类型 C类型 V void void Z jboolean boolean I jint int J jlong long D jdouble double F jfloat float B jbyte byte C jchar char S jshort short [I jintArray int[] 上面的都是基本类型，如果Java函数的参数是class，则以”L”开头，以”;”结尾。中间是用”&#x2F;“ 隔开的包及类名。而其对应的C函数名的参数则为jobject。 一个例外是String类，其对应的类为jstring：Ljava&#x2F;lang&#x2F;String;——–String———jstringLjava&#x2F;net&#x2F;Socket; ——–Socket——–jobject 如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。 例如 “(Ljava&#x2F;lang&#x2F;String;Landroid&#x2F;os&#x2F;FileUtils$FileStatus;)Z” 应该如何使用这个结构体呢？来看MediaPlayer JNI层是如何做的，代码如下所示： 12345678910111213141516171819static const JNINativeMethod gMethods[] = &#123; &#123; // Java中native函数的函数名 &quot;native_init&quot;, // native_init的签名信息 &quot;()V&quot;, // JNI层对应的函数指针 (void *)android_media_MediaPlayer_native_init &#125;,&#125;; // This function only registers the native methodsstatic int register_android_media_MediaPlayer(JNIEnv *env)&#123; // 调用AndroidRuntime的registerNativeMethods函数， // 第二个参数表明是Java中的哪个类 return AndroidRuntime::registerNativeMethods(env, &quot;android/media/MediaPlayer&quot;, gMethods, NELEM(gMethods)); AndroidRunTime类提供了一个registerNativeMethods函数来完成注册工作，下面来看registerNativeMethods的实现，代码如下： 123456789/* * Register native methods using JNI. */ /*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) &#123; // 调用jniRegisterNativeMethods函数完成注册 return jniRegisterNativeMethods(env, className, gMethods, numMethods);&#125; 其中jniRegisterNativeMethods是Android平台中为了方便JNI使用而提供的一个帮助函数，其代码如下所示： 其实显式注册的工作，只用两个函数就能完成。总结如下： jclass clazz&#x3D;（*env）-＞FindClass（env,className）； env指向一个JNIEnv结构体，classname为对应的Java类名，由于JNINativeMethod中使用的函数名并非全路径名，所以要指明是哪个类。 （*env）-＞RegisterNatives（env,clazz,gMethods,numMethods）； 调用JNIEnv的RegisterNatives函数，注册关联关系。 所以，在自己的JNI层代码中使用这种方法，就可以完成显式注册了。那这些动态注册的函数在什么时候和什么地方被调用呢？ 当Java层通过System.loadLibrary加载完JNI动态库后，紧接着会查找该库中一个叫JNI_OnLoad的函数。如果有，就调用它，而显式注册的工作就是在这里完成的。 所以，如果想使用显式注册方法，就必须实现JNI_OnLoad函数，只有在这个函数中才有机会完成显式注册的工作。 那么，libmedia_jni.so的JNI_OnLoad函数是在哪里实现的呢？由于多媒体系统很多地方都使用了JNI，所以它被放到android_media_MediaPlayer.cpp中了。 五、so与 NDKJNI技术调用的C&#x2F;C++代码会被编译成动态链接库(.so)文件，.so文件的文件格式是ELF，也就是linux下的可执行文件。.so文件可以采用多种架构，包括x86、arm等，ARM架构的文件逆向会需要ARM汇编知识。我们直接解压.apk看到lib文件夹下的x86、armeabi文件夹就是不同架构的.so文件，他们通过JNI技术被Android程序的dex文件调用。 NDK(Native Development Kit,原生开发工具包)是一组可以让开发人员在Android应用中调用C和C++代码的工具集。简单来说利用NDK，可以开发纯C&amp;C++的代码，然后编译成库，让Java程序调用。NDK开发可以称为底层开发或者jni(java native interface)层开发。 NDK是一系列工具的集合，NDK提供了一系列的工具，可以帮助开发者进行C&#x2F;C++的开发，并能自动将.so打包成apk。NDK集成了交叉编译器，并提供了相应的mk文件可以做到隔离CPU,平台，ABI等差异，只需修改mk文件即可。开发人员只需要简单修改mk文件，就可以创建出“.so”文件。NDK还提供了一份稳定的功能有限的API头文件声明。 参考： Android下如何通过JNI方法向上提供接口总结_flydream0的博客-CSDN博客_jni接口 深入理解“JNI”_Peter-OK的博客-CSDN博客_深入理解jni Android Jni调用浅述_flydream0的博客-CSDN博客_android jni调用 静态库和共享库的区别_foooooods的博客-CSDN博客_静态库和共享库的区别 Android逆向工程-基础概念:Arm、Art、Dalvik、Smali、dex、NDK、JNI之间的关系_Siphre的博客-CSDN博客_smali和dex的关系","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android源码Log类的实现","slug":"LAB/AOSP/Android-Log分析","date":"2022-05-07T00:00:00.000Z","updated":"2023-12-07T09:39:19.743Z","comments":true,"path":"2022/05/07/LAB/AOSP/Android-Log分析/","link":"","permalink":"https://beichen.link/2022/05/07/LAB/AOSP/Android-Log%E5%88%86%E6%9E%90/","excerpt":"","text":"一、Log日志框架Android 提供的 Logger 日志系统是基于内核的 Logger 日志驱动程序实现的，它将日志记录保存在内核空间内。Logger日志驱动程序会在内部使用一个环形的缓冲区来对日志进行保存，当缓冲区满了之后，新的日志就会覆盖掉旧的日志。 Logger日志驱动程序会根据日志的类型和日志的输出量来对日志记录进行分类。不同的 log 会指定不同的缓冲区然后被写入到不同的设备中，包括 system（系统相关）、radio（无线&#x2F;电话相关）、event（事件相关）、main（主缓冲区，默认）。这四种类型的日志分别通过&#x2F;dev&#x2F;log&#x2F;main, &#x2F;dev&#x2F;log&#x2F;system, &#x2F;dev&#x2F;log&#x2F;radio, &#x2F;dev&#x2F;log&#x2F;events 四个设备文件来进行访问。 main的日志是应用程序级别；system的日志是系统级别的，这个类型的日志相较于程序级别的日志会更重要，所以与main类型的日志记录分开；events类型是用来诊断系统问题的记录；radio的日志记录是无线设备相关的，日志记录量比较大，所以单独记录在一块，这样可以防止覆盖掉其他类型的日志记录。 在Android系统的框架层中提供了android.util.log, android.util.Slog, android.util.Eventlog三个Java接口来向Logger日志驱动程序中写入日志。他们写入的日志类型分别是main, system和events，如果使用android.util.log和android.util.Slog接口写入日志的标签值是以”RIL”开头或是等于”HTC_RIL”, “AT”, “GSM”, “STK”, “CDMA”, “PHONE”和”SMS”时，会转换成radio类型的日志写入到logger日志驱动程序中。 Android系统在运行时库层中也提供了三组C&#x2F;C++宏来向Logger日志驱动程序中写入日志。其中宏ALOGV, ALOGD, ALOGI, ALOGW和ALOGE用来写入main类型的日志，宏SLOGV, SLOGD, SLOGI, SLOGW和SLOGE用来写入system类型的日志，宏LOG_EVENT_INT, LOG_EVENT_LONG, LOG_EVENT_STRING用来写入events类型的日志。 不管Java接口还是C&#x2F;C++日志的写入接口最终都会通过运行库层的日志库liblog来向Logger日志驱动程序中写入日志。系统还提供了一个名为Logcat的工具来读取和显示Logger日志驱动程序中的日志。 Android系统日志系统整体框架如下图所示： 上面提到了Logger驱动程序的日志一共有四种类型，其中main、system和radio三种类型的日志格式是相同的。日志格式为 | priority | tag | message | ，其中 priority 是一个整数，代表的是日志的优先级，按重要程度不同划分为：VERBOSE、DEBUG、INFO、WARN、ERROR和FATAL 六种；tag 是一个字符串，代表的是日志的标签；message 是一个字符串，代表的是日志的内容。events类型的日志格式和前三种有一些差别，它并没有优先级。 二、Log日志 Java 层接口上文介绍了三个Java日志写入接口：android.util.log, android.util.Slog, android.util.Eventlog，这三个Java接口都是通过JNI方法调用liblog日志库提供的函数来实现日志记录的写入功能。其中使用较多的是android.util.Slog和android.util.Log这两个接口，这两个接口的差异不大，所以在这部分就只介绍一下android.util.Log接口。 1. Java层实现android.util.Log源码位于：frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;util&#x2F;Log.java，打印日志的方法实现以及日志级别的定义都在该类中。 该接口提供的日志记录写入成员比较多，不过在应用开发只关注常用的成员函数v、d、i、w和e，并且这些成员函数写入的日志记录的类型都是main。Log日志的优先级按重要程度不同划分为：VERBOSE、DEBUG、INFO、WARN、ERROR和What a Terrible Failure 六种 ，代码定义如下： 1234567public static int v/d/i/w/e/wtf(String tag, String msg) &#123; return println_native(LOG_ID_MAIN, VERBOSE, tag, msg);&#125;------------------------------------------------------------public static int v/d/i/w/e/wtf(String tag, String msg, Throwable tr) &#123; return printlns(LOG_ID_MAIN, VERBOSE, tag, msg, tr);&#125; 使用JNI的println_native方法进行日志的打印，该方法实现的地方在frameworks\\base\\core\\jni\\android_util_Log.cpp中。注：下面这种函数调用带异常记录 tr ，也就是会调用 Log 类内部类 ImediateLogWriter 来写入日志消息，但最终也会调用 println_native 函数。 注意此处的参数 LOG_ID_MAIN，实际上数值定义为： 123456typedef enum &#123; LOG_ID_MAIN = 0, LOG_ID_RADIO = 1, LOG_ID_EVENTS = 2, LOG_ID_SYSTEM = 3&#125; log_id_t; 对应的是Logger日志驱动程序指定的不同缓冲区，包括 system（系统相关）、radio（无线&#x2F;电话相关）、event（事件相关）、main（主缓冲区，默认）。 2. JNI层实现使用println_native方法进行日志打印时，JNI层定义在 &#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Log.cpp： 1234567891011121314151617181920212223static jint android_util_Log_println_native(JNIEnv* env, jobject clazz, jint bufID, jint priority, jstring tagObj, jstring msgObj)&#123; ...... // 核心代码 int res = __android_log_buf_write(bufID, (android_LogPriority)priority, tag, msg); ......&#125;// 以下为JNI注册native方法static const JNINativeMethod gMethods[] = &#123; &#123; &quot;isLoggable&quot;, &quot;(Ljava/lang/String;I)Z&quot;, (void*) android_util_Log_isLoggable &#125;, &#123; &quot;println_native&quot;, &quot;(IILjava/lang/String;Ljava/lang/String;)I&quot;, (void*) android_util_Log_println_native &#125;, &#123; &quot;logger_entry_max_payload_native&quot;, &quot;()I&quot;, (void*) android_util_Log_logger_entry_max_payload_native &#125;,&#125;;int register_android_util_Log(JNIEnv* env)&#123; ...... return RegisterMethodsOrDie(env, &quot;android/util/Log&quot;, gMethods, NELEM(gMethods)); ......&#125; 可以发现，println_native方法最终使用**__android_log_buf_write函数**打印日志，此函数定义在&#x2F;system&#x2F;core&#x2F;liblog&#x2F;logger_write.cpp ，并被编译到 liblog.so库。 3. Native层实现liblog.so 是一个用来和 logger 日志驱动程序进行交互的日志库，会被所有需要日志操作的进程加载，负责处理打印和读取日志的流程。通过 liblog 库提供的接口，应用可以方便的往 logger 日志驱动程序中写入日志记录。 主要代码在 &#x2F;system&#x2F;core&#x2F;liblog&#x2F;logger_write.cpp中，其中实现了一系列的日志写入函数，如下图所示： android_log_assert，android_log_vprint 和 android_log_print 用来写入类型为 main 的日志记录； android_log_buf_print 可以写入任意类型的日志记录。 android_log_btwrite 和android_log_bwrite 用来写入类型为 events 的日志记录； 上述所有类型的写入方式，最终都会调用write_to_log函数将日志记录写入到logger日志驱动中的。 JNI层的**__android_log_buf_write函数最终会调用Native层的write_to_log函数**。 write_to_log 是一个函数指针，初始设置指向 __write_to_log_init，进入 __write_to_log_init 后，首先会去调用 write_to_log_initialize，然后将 write_to_log 设置为指向 write_to_log_daemon，然后又调用一次 write_to_log。 详细的 write_to_log 实现较为复杂，在此不做具体分析。 三、Log日志 C&#x2F;C++ 层接口对于 Android 中 Log 的 Java 层接口，只需要在项目里import android.util.Log，在需要打印Log的地方执行Log.v，Log.d，Log.i，Log.w和Log.e。 而关于Log日志 C&#x2F;C++ 层接口，C&#x2F;C++层定义了几组宏来实现不同类型日志的写入，即要在调用Log的地方执行：ALOGV，ALOGD，ALOGI，ALOGW和ALOGE，使用时需要在 C&#x2F;C++ 层包含此头文件：#include &lt;cutils&#x2F;log.h&gt;。 宏的定义在log.h头文件中，Android10中路径为：system&#x2F;core&#x2F;include&#x2F;log&#x2F;log_main.h 1234567891011121314151617181920212223/* 条件指示符#ifndef的最主要目的是防止头文件的重复包含和编译。 语句1 #ifndef 标识1 语句2 #define 标识1 语句3 #endif 语句4 …… 语句5 …… 该段代码意思是:如果标识1没有被定义，则重定义标识1，即执行语句2、语句3;如果标识1已经被定义，则直接跳过语句2、语句3，直接执行语句4、语句5、……*/#ifndef ALOGW#define ALOGW(...) ((void)ALOG(LOG_WARN, LOG_TAG, __VA_ARGS__))#endif#ifndef ALOG#define ALOG(priority, tag, ...) LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)#endif#ifndef LOG_PRI#define LOG_PRI(priority, tag, ...) android_printLog(priority, tag, __VA_ARGS__)#endif#define android_printLog(prio, tag, ...) \\ __android_log_print(prio, tag, __VA_ARGS__) 显然，Native 层通过定义一系列宏的方式提供 log 功能，最终全部是调用了 _android_log_print 方法，接着调用 __android_log_write方法，再转向__android_log_buf_write方法，这里 Java&#x2F;C++ 层就走到同一个函数，在这个函数中会实现写设备日志文件。 1234LIBLOG_ABI_PUBLIC int __android_log_write(int prio, const char* tag, const char* msg) &#123; return __android_log_buf_write(LOG_ID_MAIN, prio, tag, msg);&#125; 这里 Java&#x2F;C++ 层就走到同一个函数，在这个函数中会实现写设备文件 参考： Android日志系统分析 - 知乎 (zhihu.com) Android_8.1 Log 系统源码分析_喵吉诃德的博客-CSDN博客","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android Java核心库libcore中打印Log（Android10）","slug":"LAB/AOSP/libcore中添加Log","date":"2022-05-06T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/05/06/LAB/AOSP/libcore中添加Log/","link":"","permalink":"https://beichen.link/2022/05/06/LAB/AOSP/libcore%E4%B8%AD%E6%B7%BB%E5%8A%A0Log/","excerpt":"","text":"最近在弄系统定制功能的时候(比如打印File构造函数的参数)，需要修改libcore中的核心代码并打印日志输出。虽然Android提供了android.utils.Log日志工具类，但是不能在Android Java层的核心库libcore中调用。 Android Java 核心库中是无法直接使用 android.util.Log 的，添加后编译不通过，因为 framework 中的 Java API 依赖于 Java 核心库。 在 Android 7.0 之前，Java 核心库源码在libcore&#x2F;luni&#x2F;下，luni 代表 lang、util、net、io，是 Java 中最常见的包；Android 7.0 中，核心库在libcore&#x2F;ojluni&#x2F;下，oj 代表 OpenJDK。 一、使用 Java.util.logging.Loggerjava.util.logging是JDK自带的日志记录包。而Android Java 核心库中也有 java.util.logging.Logger，在 Android 中它也被重定向到 Android 本地的 Log 系统。 使用方法很简单，在需要打印 Log 的源码中添加： 1234567import java.util.logging.Logger; private static final Logger sLogger = Logger.getLogger(&quot;MyTag&quot;);private static void logi(String msg) &#123; sLogger.info(msg);&#125; 使用时只需调用 logi() 方法即可，log标签为“mytag”，会直接在adb logcat里输出。这里使用的是 Level 为 INFO 的 Log。你也可以自定义 Level。 二、移植 android.utils.Log 到 libcore库将android.utils.Log移植到libcore中有两种方式: 在现有的类中添加方法，并在native追加对应的方法，这种方式相对简单； ​ 比如java.lang.System中添加相应的方法，在对应System.c中添加对应的jni方法。 在libcore中添加新的接口类，并实现native的方法，这种方式相对复杂一点。 第一种方法，利用现有类 File.java 之前的源码阅读证明，Java层的 android.utils.Log 输出 log 实际上通过JNI的链接使用的是 println_native()方法，println_native()再去调用native层的__android_log_buf_write方法。 那么我们也可以在想要打印的 Java 类处也实现一个 println_native() ，搭建一个类似的JNI层，这样就能实现类似Log类的效果。 以AOSP&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;io&#x2F;File.java 类为例： 首先，在 File.java 里新建Log()方法，之后想打印的时候可以直接调用类内的方法； 12345678private static final int LOG_ID_MAIN = 0;private static final int DEBUG = 3;/** * @hide */ public static int Log(String tag, String msg) &#123; return println_native(LOG_ID_MAIN, DEBUG, tag, msg); &#125; 注意到那个Public方法中的 @hide，这样就让Android文档生成不自动索引，这样就能使得Log方法也可以被其他类使用，例如在libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;util&#x2F;logging&#x2F;Logger.java中使用File.Log()即可，记得要import java.io.File。 然后，将AOSP&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;util&#x2F;Log.java里面的native方法声明 println_native() copy到 File.java文件里面； 1private static native int println_native(int bufID, int priority, String tag, String msg); 接下来，把&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Log.cpp中对之对应的本地方法copy到libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;native&#x2F;FileSystemPreferences.c，加在static JNINativeMethod gMethods[ ]之前就行； 123456789//头文件一定要加上+++ #include &lt;utils/Log.h&gt; static jint android_util_Log_println_native(JNIEnv* env, jobject clazz, jint bufID, jint priority, jstring tagObj, jstring msgObj)&#123; ...... ......&#125; 对于参考的&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Log.cpp里android_util_Log_println_native方法的实现，如果照搬过来，会报错： Member reference base type ‘JNIEnv’ (aka ‘const struct JNINativeInterface_ *’) is not a structure or union 原因是：env变量在C和C++语法表达不一致引起。 C++：env-&gt;FindClass(“java&#x2F;lang&#x2F;String”)C：(*env)-&gt;FindClass(env, “java&#x2F;lang&#x2F;String”) 不一定非得是修改FileSystemPreferences.c文件，正常来说应该是修改 File.java 对应的native层文件。 之前看的网上教程针对的是android4.4，与android10源码有较大差异，File.java在&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;io&#x2F;File.java，同时对应的native文件在&#x2F;libcore&#x2F;luni&#x2F;src&#x2F;main&#x2F;native&#x2F;java_io_File.cpp。 但对于Android10源码，File.java在&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;io&#x2F;File.java，且File.java并无native函数，也就是说，Android10进入libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;native&#x2F;目录下并未找到java_io_File.cpp。 思考下来，其实并不是一定要找到并修改java_io_File.cpp，只需要修改跟File.java路径差不多的文件对应的native层文件，在此文件内部进行注册JNI的地方插入我们新定义的android_util_Log_println_native方法就可以。 File.java对应的路径为java&#x2F;io&#x2F;File.java，类似的选定了java&#x2F;util&#x2F;prefs&#x2F;FileSystemPreferences.java，对应的native层为&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;native&#x2F;FileSystemPreferences.c。JNI注册修改如下： 123456789101112static JNINativeMethod gMethods[] = &#123; NATIVE_METHOD(FileSystemPreferences, lockFile0, &quot;(Ljava/lang/String;IZ)[I&quot;), NATIVE_METHOD(FileSystemPreferences, unlockFile0, &quot;(I)I&quot;), NATIVE_METHOD(FileSystemPreferences, chmod, &quot;(Ljava/lang/String;I)I&quot;),&#125;;+++ static JNINativeMethod mygMethods[] = &#123;&#123; &quot;println_native&quot;, &quot; (IILjava/lang/String;Ljava/lang/String;)I&quot;, (void*) android_util_Log_println_native &#125;,&#125;;void register_java_util_prefs_FileSystemPreferences(JNIEnv* env) &#123; jniRegisterNativeMethods(env, &quot;java/util/prefs/FileSystemPreferences&quot;, gMethods, NELEM(gMethods));+++ jniRegisterNativeMethods(env, &quot;java/io/File&quot;, mygMethods, NELEM(mygMethods));&#125; 注意：原始的gMethods[] 使用了 NATIVE_METHOD()格式，即宏#define NATIVE_METHOD(className, functionName, signature) { #functionName, signature, (void*)(Java_java_util_prefs_ ## className ## _ ## functionName) }，自动补全了functionName的全路径，但却是关于FileSystemPreferences.c的，对于android_util_Log_println_native方法不可使用。 所以，新定义了一个mygMethods[]，参考了&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Log.cpp里的实现，最后由于类名变化了，也额外进行了一次 jniRegisterNativeMethods方法。这样也就不用在JNI_onload函数里再注册一次register方法。 最后，在File.java里任意处调用 Log(tag,msg); 然后make update-api，编译运行即可。经测试，可打印Log。 第二种方法，在libcore中添加新的接口类，并实现native的方法 不想写了，累了，参考 Java核心库libcore中添加Log接口任意调用（Android10）_哆啦安全的博客-CSDN博客","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android.bp文件语法","slug":"LAB/AOSP/Android.bp语法","date":"2022-05-05T00:00:00.000Z","updated":"2023-12-07T09:39:19.743Z","comments":true,"path":"2022/05/05/LAB/AOSP/Android.bp语法/","link":"","permalink":"https://beichen.link/2022/05/05/LAB/AOSP/Android.bp%E8%AF%AD%E6%B3%95/","excerpt":"","text":"早期的Android系统都是采用Android.mk的配置来编译源码，从Android 7.0开始引入Android.bp。很明显Android.bp的出现就是为了替换掉Android.mk，bp跟mk文件不同，它是纯粹的配置，没有分支、循环等流程控制，不能做算数逻辑运算。如果需要控制逻辑，那么只能通过Go语言编写。 举例说明： 12345678910111213141516171819202122232425cc_library_shared &#123; //编译成动态库，类似于Android.mk中的BUILD_SHARED_LIBRARY name: &quot;libbluetooth_jni&quot;, //编译出的模块的名称，类似于Android.mk中的LOCAL_MODULE srcs: [ //源文件，类似于Android.mk中的LOCAL_SRC_FILES &quot;com_android_bluetooth_btservice_AdapterService.cpp&quot;, &quot;com_android_bluetooth_hfp.cpp&quot;, ], include_dirs: [ //用户指定的头文件查找路径，类似于Android.mk中的LOCAL_C_INCLUDES &quot;libnativehelper/include/nativehelper&quot;, &quot;system/bt/types&quot;, ], shared_libs: [ //编译所依赖的动态库，类似于Android.mk中的LOCAL_SHARED_LIBRARIES &quot;libandroid_runtime&quot;, &quot;libnativehelper&quot;, &quot;libcutils&quot;, &quot;liblog&quot;, ], static_libs: [ //编译所依赖的静态库，类似于Android.mk中的LOCAL_STATIC_LIBRARIES &quot;libbluetooth-types&quot;, ], cflags: [ ///编译flag,类似于Android.mk中的LOCAL_CFLAGS &quot;-Wall&quot;, &quot;-Wextra&quot;, &quot;-Wno-unused-parameter&quot;, ],&#125; 定义一个模块从模块的类型开始，模块有不同的类型，如前面例子中的cc_library_shared，当然类型还有很多种，譬如cc_binary android_app cc_library_static等等； 模块包含一些属性格式为“property-name:property-value”，其中name属性必须指定，其属性值必须是全局唯一的； srcs 属性以字符串列表的形式指定用于编译模块的源文件； 根据链接时期不同，库分为静态库和动态库。静态库是在程序编译时链接的，动态库是在程序运行时链接的。 链接静态库其实从某种意义上来说也是一种粘贴复制，只不过它操作的对象是目标代码而不是源码而已。因为静态库被链接后库就直接嵌入可执行文件中了，这样就带来了两个问题。首先就是系统空间被浪费了。这是显而易见的，想象一下，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间。一旦发现了库中有bug，挽救起来就比较麻烦了。必须一一把链接该库的程序找出来，然后重新编译。 而动态库的出现正弥补了静态库的以上弊端。因为动态库是在程序运行时被链接的，所以磁盘上只须保留一份副本，因此节约了磁盘空间。如果发现了bug或要升级也很简单，只要用新的库把原来的替换掉就行了。那么，是不是静态库就一无是处了呢？答：非也非也。 想象一下这样的情况：如果你用libpcap库编了一个程序，要给被人运行，而他的系统上没有装pcap库，该怎么解决呢？最简单的办法就是编译该程序时把所有要链接的库都链接它们的静态库，这样就可以在别人的系统上直接运行该程序了。 正因为动态库在程序运行时被链接，故程序的运行速度和链接静态库的版本相比必然会打折扣。然而瑕不掩瑜，动态库的不足相对于它带来的好处在现今硬件下简直是微不足道的，所以链接程序在链接时一般是优先链接动态库的，除非用-static参数指定链接静态库。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android系统架构开篇","slug":"LAB/AOSP/Android系统架构开篇","date":"2022-04-23T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/04/23/LAB/AOSP/Android系统架构开篇/","link":"","permalink":"https://beichen.link/2022/04/23/LAB/AOSP/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/","excerpt":"","text":"1. Android系统架构介绍Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和 Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++&#x2F;C)，从而连通整个系统。 应用层 系统内置的应用程序以及非系统级的应用程序都是属于应用层。负责与用户进行直接交互，通常都是用Java进行开发的。 应用框架层（Java API Framework) 应用框架层为开发人员提供了可以开发应用程序所需要的 API ，我们平常开发应用程序都是调用的这一层所提供的 API ，当然也包括系统的应用。这一层是由Java代码编写的，可以称为Java Framework，下面来看这一层所提供的主要的组件。 名称 功能描述 Activity Manager 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager 提供地理位置以及定位功能服务 Package Manager 管理所有安装在Android系统中的应用程序 Notification Manager 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager 管理所有的移动设备功能 Window Manager 管理所有开启的窗口程序 Content Providers 使得不同应用程序之间可以共享数据 View System 构建应用程序的基本组件 系统运行库层（Native) C&#x2F;C++程序库（Native C&#x2F;C++ Libraries） C&#x2F;C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务。 Android运行时库 （Android Runtime） 运行时库又分为 core libraries 和 android runtime (ART)，核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用； ART作为替代Dalvik的Android虚拟机，采用AOT(Ahead-Of-Time)技术，会在应用程序安装时就转换成机器语言，不再在执行时解释，从而优化了应用运行的速度。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。 硬件抽象层（Hardware Abstraction Layer) 硬件抽象层位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 Linux内核层 Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。 2. Android系统启动架构 Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，以下即是以进程的视角，以分层的架构来诠释Android系统的全貌。 图解：Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; Kernel -&gt; Native -&gt; Framework -&gt; App 关于Loader层： Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在 ROM里的预设代码开始执行，然后加载引导程序到 RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 2.1 Linux内核层（Kernel）Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。 启动Kernel的swapper进程(pid&#x3D;0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid&#x3D;2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。 2.2 硬件抽象层 (HAL)硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI&#x2F;蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。 2.3 Native系统库 &amp; Android Runtime这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid&#x3D;1),是Linux系统的用户进程， init进程是所有用户进程的鼻祖。 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动 servicemanager(binder服务管家)、 bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)， Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。 2.4 Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含： 加载ZygoteInit类，注册Zygote Socket服务端套接字 加载虚拟机 提前加载类preloadClasses 提前加载资源preloadResouces System Server进程，是由Zygote进程fork而来， SystemServer是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 2.5 App层 Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。 所有的App进程都是由Zygote进程fork生成的。 2.6 Syscall &amp;&amp; JNI Native与Kernel之间有一层系统调用(SysCall)层，见Linux系统调用(Syscall)原理; 内核提供用户空间程序与内核空间进行交互的一套标准接口，这些接口让用户态程序能受限访问硬件设备，比如申请系统资源，操作设备读写，创建新进程等。用户空间发生请求，内核空间负责执行，这些接口便是用户空间和内核空间共同识别的桥梁，这里提到两个字“受限”，是由于为了保证内核稳定性，而不能让用户空间程序随意更改系统，必须是内核对外开放的且满足权限的程序才能调用相应接口。 在用户空间和内核空间之间，有一个叫做Syscall(系统调用, system call)的中间层，是S连接用户态和内核态的桥梁。这样即提高了内核的安全型，也便于移植，只需实现同一套接口即可。Linux系统，用户空间通过向内核空间发出Syscall，产生软中断，从而让程序陷入内核态，执行相应的操作。 Java层与Native(C&#x2F;C++)层之间的纽带JNI。 Java Native Interface (JNI)标准是java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI 是本地编程接口，它使得在 Java 虚拟机 (VM) 内部运行的 Java 代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序和库进行交互操作。 ​ java代码是无法直接操纵底层设备的，必须借由C来实现，我们使用C语言实现相应功能后，在Java代码中借助JNI直接调用就可以了。例如： 123456789101112131415161718192021// 文件路径:framework/base/media/java/src/android/media/MediaScanner.javapackage android.media;public class MediaScanner implements AutoCloseable &#123; static &#123; // 通过静态代码块首先加载media_jni库 System.loadLibrary(&quot;media_jni&quot;); // 调用native层的函数 native_init(); &#125; public void scanDirectories(String[] directories) &#123; for (int i = 0; i &lt; directories.length; i++) &#123; // 调用native层的函数 test(&quot;tom&quot;, 18, mStudent); &#125; &#125; ... // native关键字表示这个方法由native层实现，这里只需声明就好了 private static native final void native_init(); private native void test(String name, int age, object student);&#125; Java层使用JNI技术是非常方便的，我们只需要两步就够了： 加载JNI库（System.loadLibrary方法会根据平台加载对应的JNI库，如代码中的media_jni，在Linux上会加载libmedia_jni.so，在Window上则是media_jni.dll）; 声明要用到的Native函数，Native是Java的关键字; 然后，我们就可以像调用普通Java方法那样去调用Native函数了。 参考： Android系统架构开篇 - 云+社区 - 腾讯云 (tencent.com) Android系统架构与系统源码目录_刘望舒的博客-CSDN博客_android系统源代码","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Android系统源码目录","slug":"LAB/AOSP/Android系统源码目录","date":"2022-04-23T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/04/23/LAB/AOSP/Android系统源码目录/","link":"","permalink":"https://beichen.link/2022/04/23/LAB/AOSP/Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95/","excerpt":"","text":"1. 整体结构各个版本的源码目录基本是类似，如果是编译后的源码目录会多增加一个out文件夹，用来存储编译产生的文件。Android7.0的根目录结构说明如下表所示。 Android源码根目录 描述 abi 应用程序二进制接口 art 全新的ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发包配置 cts Android兼容性测试套件标准 dalvik dalvik虚拟机 developers 开发者目录 development 应用程序开发相关 device 设备相关配置 docs 参考文档目录 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码，帮助开发人员在应用程序中嵌入C&#x2F;C++代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 底层文件系统库、应用和组件 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 2. 应用层部分 (packages)应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的packages目录对应着系统应用层。它的目录结构如下所示。 packages目录 描述 apps 核心应用程序 experimental 第三方应用程序 inputmethods 输入法目录 providers 内容提供者目录 screensavers 屏幕保护 services 通信服务 wallPapers 壁纸 从目录结构可以发现，packages目录存放着系统核心应用程序、第三方的应用程序和输入法等等，这些应用都是运行在系统应用层的，因此packages目录对应着系统的应用层。 3. 应用框架层部分 （frameworks）应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与C&#x2F;C++程序库以及硬件抽象层等进行衔接。 应用框架层的主要实现代码在&#x2F;frameworks&#x2F;base和&#x2F;frameworks&#x2F;av目录下，其中base目录结构如下所示。 &#x2F;base 描述 &#x2F;base 描述&#x2F; api 定义API cmds 重要命令：am、app_proce等 core 核心库 data 字体和声音等数据文件 docs 文档 graphics 图形图像相关 include 头文件 keystore 和数据签名证书相关 libs 库 location 地理位置相关库 media 多媒体相关库 native 本地库 nfc-extras NFC相关 obex 蓝牙传输 opengl 2D&#x2F;3D 图形API packages 设置、TTS、VPN程序 sax XML解析器 services 系统服务 telephony 电话通讯管理 test-runner 测试工具相关 tests 测试相关 tools 工具 wifi wifi无线网络 4. C&#x2F;C++程序库部分系统运行库层（Native)中的 C&#x2F;C++程序库的类型繁多，功能强大，C&#x2F;C++程序库并不完全在一个目录中，这里给出几个常用且比较重要的C&#x2F;C++程序库所在的目录位置。 目录位置 描述 &#x2F;bonic Google开发的系统C库，以BSD许可形式开源。 &#x2F;frameworks&#x2F;av&#x2F;media 系统媒体库 &#x2F;frameworks&#x2F;native&#x2F;opengl 第三方图形渲染库 &#x2F;frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger 图形显示库，主要负责图形的渲染、叠加和绘制等功能 external&#x2F;sqlite 轻量型关系数据库SQLite的C++实现 余下的部分，Android运行时库的代码放在art&#x2F;目录中。硬件抽象层的代码在hardware&#x2F;目录中，这一部分是手机厂商改动最大的一部分，根据手机终端所采用的硬件平台会有不同的实现。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"}]},{"title":"Docker 搭建android编译环境","slug":"LAB/AOSP/Docker 搭建android6编译环境","date":"2022-04-06T00:00:00.000Z","updated":"2023-12-07T09:39:19.747Z","comments":true,"path":"2022/04/06/LAB/AOSP/Docker 搭建android6编译环境/","link":"","permalink":"https://beichen.link/2022/04/06/LAB/AOSP/Docker%20%E6%90%AD%E5%BB%BAandroid6%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","excerpt":"由于服务器环境不适用于android6的源码编译，所以考虑用Docker搭建AOSP编译环境。","text":"由于服务器环境不适用于android6的源码编译，所以考虑用Docker搭建AOSP编译环境。 docker搭建android6有现成docker镜像，可参考： http://qiushao.net/2019/11/14/Linux/docker-aosp-build-env/ 安装docker 1234curl -sSL https://get.docker.com/ | shsudo usermod -aG docker xiehao #为了使得每次使用docker命令的时候不需要额外敲sudosudo systemctl restart docker #重启docker或重新登陆用户让权限生效docker version #检验操作是否成功 编译docker镜像 123git clone https://github.com/qiushao/aosp_builder.gitcd aosp_builderdocker build -t aosp_builder:V1.0 . 按上面的步骤操作完之后，应该生成一个 aosp_builder:V1.0 的docker 镜像了,构建出来的镜像用户名为 builder。 创建容器：docker run -it --name aosp_builder -v ~/android6:/home/builder/android6 -u builder aosp_builder:V1.0 /bin/bash 其中,-v ~/source:/home/builder/android6 参数是将宿主机目录~/android6映射到 docker 容器的/home/builder/android6目录。因为我宿主机上 Android 的源码放在 ~/android6这个目录里面了。-u builder表示使用 builder 用户登录，不指定的话，会使用 root 用户登录，最好不要用 root 登录，用 root 用户登录的话，编译时产生的文件用户属主就是 root 了，在宿主机上要编辑或删除这些编译生成的文件就得用 sudo 了。 进入docker镜像环境 12docker start aosp_builderdocker exec -it aosp_builder /bin/bash 然后我们就可以按照 Android 的标准编译流程开编了","categories":[{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"},{"name":"Docker","slug":"Docker","permalink":"https://beichen.link/tags/Docker/"}]}],"categories":[{"name":"Study","slug":"Study","permalink":"https://beichen.link/categories/Study/"},{"name":"Paper","slug":"Paper","permalink":"https://beichen.link/categories/Paper/"},{"name":"APP Detection engine","slug":"APP-Detection-engine","permalink":"https://beichen.link/categories/APP-Detection-engine/"},{"name":"Emulator","slug":"Emulator","permalink":"https://beichen.link/categories/Emulator/"},{"name":"AOSP","slug":"AOSP","permalink":"https://beichen.link/categories/AOSP/"}],"tags":[{"name":"逆向知识","slug":"逆向知识","permalink":"https://beichen.link/tags/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86/"},{"name":"Android知识","slug":"Android知识","permalink":"https://beichen.link/tags/Android%E7%9F%A5%E8%AF%86/"},{"name":"OSS Security","slug":"OSS-Security","permalink":"https://beichen.link/tags/OSS-Security/"},{"name":"算法","slug":"算法","permalink":"https://beichen.link/tags/%E7%AE%97%E6%B3%95/"},{"name":"语言学习","slug":"语言学习","permalink":"https://beichen.link/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"实习","slug":"实习","permalink":"https://beichen.link/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Android漏洞","slug":"Android漏洞","permalink":"https://beichen.link/tags/Android%E6%BC%8F%E6%B4%9E/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://beichen.link/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"android，Docker","slug":"android，Docker","permalink":"https://beichen.link/tags/android%EF%BC%8CDocker/"},{"name":"Face Security","slug":"Face-Security","permalink":"https://beichen.link/tags/Face-Security/"},{"name":"android","slug":"android","permalink":"https://beichen.link/tags/android/"},{"name":"Docker","slug":"Docker","permalink":"https://beichen.link/tags/Docker/"}]}